/**
 * Stack Tracker Pro - React Native App
 * Privacy-First Precious Metals Portfolio Tracker
 * "Make Stacking Great Again" Edition ðŸª™
 */

import React, { useState, useEffect, useRef, Component } from 'react';
import {
  View, Text, StyleSheet, TouchableOpacity, ScrollView, TextInput,
  Alert, Modal, Platform, SafeAreaView, StatusBar, ActivityIndicator,
  Keyboard, TouchableWithoutFeedback, KeyboardAvoidingView, Dimensions, AppState, FlatList, Clipboard, Linking,
  useColorScheme, RefreshControl, Switch, Image, Animated, LayoutAnimation, PanResponder,
} from 'react-native';
import { SafeAreaProvider, useSafeAreaInsets } from 'react-native-safe-area-context';
import ErrorBoundary from './ErrorBoundary';
import AsyncStorage from '@react-native-async-storage/async-storage';
import Constants from 'expo-constants';
import * as ImagePicker from 'expo-image-picker';
import * as LocalAuthentication from 'expo-local-authentication';
import * as FileSystem from 'expo-file-system/legacy';
import * as Sharing from 'expo-sharing';
import * as DocumentPicker from 'expo-document-picker';
import * as Haptics from 'expo-haptics';
import Purchases from 'react-native-purchases';
import * as XLSX from 'xlsx';
import * as Notifications from 'expo-notifications';
import * as StoreReview from 'expo-store-review';
import { CloudStorage, CloudStorageScope } from 'react-native-cloud-storage';
import { initializePurchases, loginRevenueCat, hasGoldEntitlement, getUserEntitlements, restorePurchases, logoutRevenueCat } from './src/utils/entitlements';
import { syncWidgetData, isWidgetKitAvailable } from './src/utils/widgetKit';
import { registerBackgroundFetch, getBackgroundFetchStatus } from './src/utils/backgroundTasks';
// LineChart removed â€” all charts now use ScrubChart
import Svg, { Path, Circle, Line, Defs, LinearGradient as SvgLinearGradient, Stop } from 'react-native-svg';
import { Swipeable, GestureHandlerRootView } from 'react-native-gesture-handler';
import GoldPaywall from './src/components/GoldPaywall';
import Tutorial from './src/components/Tutorial';
import TroyCoinIcon from './src/components/TroyCoinIcon';
import GlobeIcon from './src/components/GlobeIcon';
import ViewShot from 'react-native-view-shot';
import { AuthProvider, useAuth } from './src/contexts/AuthContext';
import AuthScreen from './src/screens/AuthScreen';
import AccountScreen from './src/screens/AccountScreen';
import ResetPasswordScreen from './src/screens/ResetPasswordScreen';
import { AppleLogo, GoogleLogo, ProfileIcon, DashboardIcon, HoldingsIcon, AnalyticsIcon, ToolsIcon, SettingsIcon, SortIcon, TodayIcon, BellIcon, TrendingUpIcon, CalculatorIcon, TrophyIcon } from './src/components/icons';
import {
  fetchHoldings,
  addHolding,
  updateHolding,
  deleteHolding as deleteHoldingFromSupabase,
  fullSync,
  findHoldingByLocalId,
} from './src/services/supabaseHoldings';
import { supabase } from './src/lib/supabase';

// Configure notifications behavior
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: false,
  }),
});

// UUID v4 generator for price alert IDs (must be valid UUID for Supabase)
const generateUUID = () => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
};

// iCloud sync key
const ICLOUD_HOLDINGS_KEY = 'stack_tracker_holdings.json';

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const API_BASE_URL = Constants.expoConfig?.extra?.apiUrl || 'https://api.stacktrackergold.com';

// ============================================
// DEALER CSV TEMPLATES
// ============================================
const DEALER_TEMPLATES = {
  'stacktracker': {
    name: 'Stack Tracker Export',
    instructions: 'Re-import a CSV previously exported from this app',
    columnMap: {
      product: ['product'],
      metal: ['metal'],
      quantity: ['qty'],
      unitPrice: ['unit price'],
      date: ['date'],
      time: ['time'],
      dealer: ['source'],
      ozt: ['ozt'],
      taxes: ['taxes'],
      shipping: ['shipping'],
      spotPrice: ['spot'],
      premium: ['premium'],
    },
    detectPattern: null, // Detected by header fingerprint
    headerFingerprint: ['metal', 'product', 'source', 'ozt', 'unit price'],
    autoDealer: null,
  },
  'generic': {
    name: 'Generic / Custom',
    instructions: 'CSV should have columns: Product Name, Metal Type, OZT, Quantity, Price, Date',
    columnMap: {
      product: ['product', 'name', 'item', 'description'],
      metal: ['metal', 'type', 'metal type'],
      quantity: ['quantity', 'qty', 'count'],
      unitPrice: ['price', 'unit price', 'cost', 'unit cost'],
      date: ['date', 'purchased', 'purchase date', 'order date'],
      dealer: ['dealer', 'source', 'vendor', 'seller'],
      ozt: ['oz', 'ozt', 'ounces', 'troy oz', 'weight'],
    },
    detectPattern: null, // Default fallback
    autoDealer: null,
  },
  'apmex': {
    name: 'APMEX',
    instructions: 'Go to My Account â†’ Order History â†’ Export to CSV',
    columnMap: {
      product: ['description', 'item description', 'product'],
      quantity: ['qty', 'quantity'],
      unitPrice: ['unit price', 'price'],
      date: ['order date', 'date'],
      dealer: null, // Will auto-fill with dealer name
    },
    detectPattern: /apmex|order.*id.*apmex/i,
    autoDealer: 'APMEX',
  },
  'jmbullion': {
    name: 'JM Bullion',
    instructions: 'Go to Order History â†’ Download Order History',
    columnMap: {
      product: ['product name', 'product', 'item', 'description'],
      quantity: ['qty', 'quantity'],
      unitPrice: ['price', 'unit price'],
      date: ['date', 'order date', 'purchase date'],
      dealer: null,
    },
    detectPattern: /jm.*bullion|jmbullion/i,
    autoDealer: 'JM Bullion',
  },
  'sdbullion': {
    name: 'SD Bullion',
    instructions: 'Go to My Orders â†’ Export to CSV',
    columnMap: {
      product: ['product', 'item name', 'description'],
      quantity: ['quantity', 'qty'],
      unitPrice: ['price', 'unit price', 'item price'],
      date: ['order date', 'date'],
      dealer: null,
    },
    detectPattern: /sd.*bullion|sdbullion/i,
    autoDealer: 'SD Bullion',
  },
  'providentmetals': {
    name: 'Provident Metals',
    instructions: 'Go to Order History â†’ Export',
    columnMap: {
      product: ['product', 'description', 'item'],
      quantity: ['qty', 'quantity'],
      unitPrice: ['price', 'unit price'],
      date: ['date', 'order date'],
      dealer: null,
    },
    detectPattern: /provident/i,
    autoDealer: 'Provident Metals',
  },
  'herobullion': {
    name: 'Hero Bullion',
    instructions: 'Go to My Account â†’ Order History â†’ Export',
    columnMap: {
      product: ['product', 'description', 'item name'],
      quantity: ['quantity', 'qty'],
      unitPrice: ['price', 'unit price'],
      date: ['date', 'order date'],
      dealer: null,
    },
    detectPattern: /hero.*bullion/i,
    autoDealer: 'Hero Bullion',
  },
  'boldpreciousmetals': {
    name: 'BOLD Precious Metals',
    instructions: 'Go to Account â†’ Orders â†’ Download CSV',
    columnMap: {
      product: ['item', 'product', 'description'],
      quantity: ['qty', 'quantity'],
      unitPrice: ['price', 'unit price'],
      date: ['date', 'order date'],
      dealer: null,
    },
    detectPattern: /bold.*precious|boldprecious/i,
    autoDealer: 'BOLD Precious Metals',
  },
  'moneymetals': {
    name: 'Money Metals Exchange',
    instructions: 'Go to Order History â†’ Export Orders',
    columnMap: {
      product: ['product', 'description', 'item'],
      quantity: ['qty', 'quantity'],
      unitPrice: ['price', 'unit price'],
      date: ['date', 'order date'],
      dealer: null,
    },
    detectPattern: /money.*metals/i,
    autoDealer: 'Money Metals Exchange',
  },
};

// ============================================
// METAL & WEIGHT DETECTION HELPERS
// ============================================

/**
 * Auto-detect metal type from product name
 * Returns 'gold', 'silver', 'platinum', 'palladium', or null
 */
const detectMetalFromName = (productName) => {
  if (!productName) return null;
  const name = productName.toLowerCase();

  // Gold detection patterns
  const goldPatterns = [
    /\bgold\b/,
    /\bau\b/,
    /\b(1|one|half|quarter|tenth)\s*(oz|ounce).*gold/,
    /gold.*(eagle|buffalo|maple|krugerrand|panda|philharmonic|kangaroo|britannia)/,
    /(eagle|buffalo|maple|krugerrand|panda|philharmonic|kangaroo|britannia).*gold/,
    /\b(american|canadian|south african|chinese|austrian|australian|british).*gold/,
    /\b24k\b|\b22k\b|\b14k\b|\b18k\b/,
    /gold\s*(bar|coin|round)/,
    /\bkilo.*gold\b|\bgold.*kilo\b/,
  ];

  // Silver detection patterns
  const silverPatterns = [
    /\bsilver\b/,
    /\bag\b/,
    /silver.*(eagle|maple|britannia|philharmonic|kookaburra|panda|libertad)/,
    /(eagle|maple|britannia|philharmonic|kookaburra|panda|libertad).*silver/,
    /\b(american|canadian|austrian|australian|mexican|chinese).*silver/,
    /\bjunk\s*silver\b/,
    /\b90%\s*(silver|coin)/,
    /\b40%\s*silver/,
    /silver\s*(bar|coin|round)/,
    /\b(morgan|peace|walking liberty|mercury|roosevelt|washington|kennedy)\b/,
    /\bgeneric.*silver\b|\bsilver.*generic\b/,
    /\b999\s*silver\b|\bsilver.*999\b/,
    /\.999\s*fine\s*silver/,
  ];

  // Platinum detection patterns
  const platinumPatterns = [
    /\bplatinum\b/,
    /\bpt\b/,
    /platinum.*(eagle|maple|britannia|philharmonic)/,
  ];

  // Palladium detection patterns
  const palladiumPatterns = [
    /\bpalladium\b/,
    /\bpd\b/,
    /palladium.*(eagle|maple)/,
  ];

  // Check patterns in order of likelihood
  for (const pattern of silverPatterns) {
    if (pattern.test(name)) return 'silver';
  }
  for (const pattern of goldPatterns) {
    if (pattern.test(name)) return 'gold';
  }
  for (const pattern of platinumPatterns) {
    if (pattern.test(name)) return 'platinum';
  }
  for (const pattern of palladiumPatterns) {
    if (pattern.test(name)) return 'palladium';
  }

  return null;
};

/**
 * Auto-detect troy ounces from product name
 * Returns the OZT value as a number, or null if not detected
 */
const detectOztFromName = (productName) => {
  if (!productName) return null;
  const name = productName.toLowerCase();

  // Common fractional gold sizes
  const fractionalPatterns = [
    { pattern: /\b1\/10\s*(oz|ounce|ozt)\b|\btenth\s*(oz|ounce)\b/i, ozt: 0.1 },
    { pattern: /\b1\/4\s*(oz|ounce|ozt)\b|\bquarter\s*(oz|ounce)\b/i, ozt: 0.25 },
    { pattern: /\b1\/2\s*(oz|ounce|ozt)\b|\bhalf\s*(oz|ounce)\b/i, ozt: 0.5 },
    { pattern: /\b1\/20\s*(oz|ounce|ozt)\b/i, ozt: 0.05 },
    { pattern: /\b2\s*(oz|ounce|ozt)\b/i, ozt: 2 },
    { pattern: /\b5\s*(oz|ounce|ozt)\b/i, ozt: 5 },
    { pattern: /\b10\s*(oz|ounce|ozt)\b/i, ozt: 10 },
    { pattern: /\b100\s*(oz|ounce|ozt)\b/i, ozt: 100 },
    { pattern: /\b1000\s*(oz|ounce|ozt)\b|\b1,000\s*(oz|ounce|ozt)\b/i, ozt: 1000 },
    { pattern: /\b1\s*(oz|ounce|ozt)\b/i, ozt: 1 },
  ];

  // Kilo bars
  if (/\bkilo\b|\b1\s*kg\b|\bkilogram\b/i.test(name)) {
    return 32.15; // 1 kilo = 32.15 troy oz
  }

  // Check fractional patterns (order matters - check specific fractions first)
  for (const { pattern, ozt } of fractionalPatterns) {
    if (pattern.test(name)) return ozt;
  }

  // Try to extract numeric oz value: "10oz", "10 oz", "10-oz"
  const ozMatch = name.match(/(\d+(?:\.\d+)?)\s*[-]?\s*(oz|ozt|ounce|troy\s*oz)/i);
  if (ozMatch) {
    const value = parseFloat(ozMatch[1]);
    if (value > 0 && value <= 1000) return value;
  }

  // Gram bars: "1g", "5g", "10g", "50g", "100g"
  const gramMatch = name.match(/(\d+(?:\.\d+)?)\s*[-]?\s*(g|gram|grams)\b/i);
  if (gramMatch) {
    const grams = parseFloat(gramMatch[1]);
    if (grams > 0 && grams <= 1000) {
      return parseFloat((grams / 31.1035).toFixed(4)); // Convert grams to ozt
    }
  }

  // Common coin defaults (if metal detected but no weight)
  // American Silver Eagle, Canadian Maple, etc. are 1oz
  if (/\b(eagle|maple|britannia|philharmonic|buffalo|krugerrand|panda|libertad|kookaburra)\b/i.test(name)) {
    // If no specific weight mentioned, these are typically 1oz
    return 1;
  }

  // Junk silver - 90% silver coins have specific silver content
  if (/\bjunk\b.*silver|90%/i.test(name)) {
    // $1 face value of 90% silver = 0.715 ozt
    // Can't determine without face value, return null
    return null;
  }

  return null;
};

/**
 * Auto-detect dealer from headers/file content
 * Returns the dealer template key or 'generic'
 */
const detectDealerFromHeaders = (headers, fileContent = '') => {
  const headerStr = headers.join(' ').toLowerCase();
  const contentStr = (fileContent || '').toLowerCase();
  const lowerHeaders = headers.map(h => h.toLowerCase().trim());

  // 1. Check header fingerprints first (exact header-based detection)
  for (const [key, template] of Object.entries(DEALER_TEMPLATES)) {
    if (template.headerFingerprint) {
      const matched = template.headerFingerprint.every(fp =>
        lowerHeaders.some(h => h === fp || h.includes(fp))
      );
      if (matched) return key;
    }
  }

  // 2. Check regex detectPattern against headers and filename
  for (const [key, template] of Object.entries(DEALER_TEMPLATES)) {
    if (template.detectPattern && (template.detectPattern.test(headerStr) || template.detectPattern.test(contentStr))) {
      return key;
    }
  }

  // 3. Check if headers match generic column names well enough to skip dealer selection
  //    Need at least: a product-like column AND (a price-like column OR an ozt-like column)
  const genericMap = DEALER_TEMPLATES['generic'].columnMap;
  const hasProduct = genericMap.product.some(name => lowerHeaders.some(h => h.includes(name)));
  const hasPrice = genericMap.unitPrice.some(name => lowerHeaders.some(h => h.includes(name)));
  const hasOzt = genericMap.ozt.some(name => lowerHeaders.some(h => h.includes(name)));
  if (hasProduct && (hasPrice || hasOzt)) return 'generic';

  // 4. Unrecognized format
  return null;
};

// ============================================
// REUSABLE COMPONENTS
// ============================================

const FloatingInput = ({ label, value, onChangeText, placeholder, keyboardType, prefix, editable = true, colors, isDarkMode, scaledFonts, required, error }) => {
  // Default colors for backwards compatibility
  const labelColor = colors ? colors.muted : '#a1a1aa';
  const inputBg = colors ? (isDarkMode ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.05)') : 'rgba(0,0,0,0.3)';
  const borderColor = error ? '#EF4444' : (colors ? colors.border : 'rgba(255,255,255,0.1)');
  const textColor = colors ? colors.text : '#fff';
  const prefixColor = colors ? colors.muted : '#71717a';
  const disabledBg = colors ? (isDarkMode ? 'rgba(0,0,0,0.5)' : 'rgba(0,0,0,0.1)') : 'rgba(0,0,0,0.5)';

  // Font sizes - use scaledFonts if provided, otherwise defaults
  const labelFontSize = scaledFonts ? scaledFonts.small : 12;
  const inputFontSize = scaledFonts ? scaledFonts.normal : 14;
  const prefixFontSize = scaledFonts ? scaledFonts.normal : 14;

  return (
    <View style={styles.floatingContainer}>
      <Text style={[styles.floatingLabel, { color: labelColor, fontSize: labelFontSize }]}>
        {label}{required && <Text style={{ color: '#EF4444' }}> *</Text>}
      </Text>
      <View style={[styles.inputRow, { backgroundColor: inputBg, borderColor: borderColor }, !editable && { backgroundColor: disabledBg }]}>
        {prefix && <Text style={[styles.inputPrefix, { color: prefixColor, fontSize: prefixFontSize }]}>{prefix}</Text>}
        <TextInput
          style={[styles.floatingInput, { color: textColor, fontSize: inputFontSize }, prefix && { paddingLeft: 4 }]}
          placeholder={placeholder}
          placeholderTextColor={colors ? colors.muted : '#52525b'}
          keyboardType={keyboardType || 'default'}
          value={value}
          onChangeText={onChangeText}
          editable={editable}
          returnKeyType="done"
          onSubmitEditing={Keyboard.dismiss}
        />
      </View>
    </View>
  );
};

const PieChart = ({ data, size = 150, cardBgColor, textColor, mutedColor }) => {
  const total = data.reduce((sum, item) => sum + item.value, 0);
  if (total === 0) return null;

  // Filter out 0-value segments and calculate percentages
  const nonZeroSegments = data.filter((item) => item.value > 0);

  // Calculate percentages for legend (all items)
  const allSegments = data.map((item) => ({
    ...item,
    percentage: total > 0 ? item.value / total : 0,
  }));

  const cx = size / 2;
  const cy = size / 2;
  const outerR = size / 2;
  const innerR = size * 0.3; // donut hole

  // Build SVG arc paths for each segment
  const polarToCartesian = (centerX, centerY, radius, angleDeg) => {
    const angleRad = ((angleDeg - 90) * Math.PI) / 180;
    return {
      x: centerX + radius * Math.cos(angleRad),
      y: centerY + radius * Math.sin(angleRad),
    };
  };

  const arcPath = (startAngle, endAngle) => {
    const outerStart = polarToCartesian(cx, cy, outerR, endAngle);
    const outerEnd = polarToCartesian(cx, cy, outerR, startAngle);
    const innerStart = polarToCartesian(cx, cy, innerR, endAngle);
    const innerEnd = polarToCartesian(cx, cy, innerR, startAngle);
    const largeArc = endAngle - startAngle > 180 ? 1 : 0;
    return [
      `M ${outerStart.x} ${outerStart.y}`,
      `A ${outerR} ${outerR} 0 ${largeArc} 0 ${outerEnd.x} ${outerEnd.y}`,
      `L ${innerEnd.x} ${innerEnd.y}`,
      `A ${innerR} ${innerR} 0 ${largeArc} 1 ${innerStart.x} ${innerStart.y}`,
      'Z',
    ].join(' ');
  };

  let currentAngle = 0;
  const segments = nonZeroSegments.map((item) => {
    const sweep = (item.value / total) * 360;
    const startAngle = currentAngle;
    currentAngle += sweep;
    return { ...item, startAngle, sweep };
  });

  return (
    <View style={{ alignItems: 'center' }}>
      <View style={{ width: size, height: size }}>
        <Svg width={size} height={size}>
          {segments.length === 1 ? (
            <>
              <Circle cx={cx} cy={cy} r={outerR} fill={segments[0].color} />
              <Circle cx={cx} cy={cy} r={innerR} fill={cardBgColor || '#1a1a2e'} />
            </>
          ) : (
            segments.map((seg, i) => (
              <Path key={i} d={arcPath(seg.startAngle, seg.startAngle + seg.sweep)} fill={seg.color} />
            ))
          )}
        </Svg>
        <View style={{
          position: 'absolute',
          top: 0, left: 0, right: 0, bottom: 0,
          justifyContent: 'center',
          alignItems: 'center',
        }}>
          <Text style={{ color: textColor || '#fff', fontWeight: '700', fontSize: 14 }}>
            ${(total / 1000).toFixed(1)}k
          </Text>
        </View>
      </View>
      <View style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'center', marginTop: 12, gap: 16 }}>
        {allSegments.map((seg, index) => (
          <View key={index} style={{ flexDirection: 'row', alignItems: 'center' }}>
            <View style={{ width: 12, height: 12, borderRadius: 6, backgroundColor: seg.color, marginRight: 6 }} />
            <Text style={{ color: mutedColor || '#a1a1aa', fontSize: 12 }}>{seg.label} {(seg.percentage * 100).toFixed(0)}%</Text>
          </View>
        ))}
      </View>
    </View>
  );
};

const ProgressBar = ({ value, max, color, label }) => {
  const percentage = max > 0 ? Math.min((value / max) * 100, 100) : 0;
  return (
    <View style={{ marginBottom: 12 }}>
      <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
        <Text style={{ color: '#a1a1aa', fontSize: 12 }}>{label}</Text>
        <Text style={{ color: '#fff', fontSize: 12, fontWeight: '600' }}>{percentage.toFixed(0)}%</Text>
      </View>
      <View style={{ height: 8, backgroundColor: 'rgba(255,255,255,0.1)', borderRadius: 4 }}>
        <View style={{ height: 8, width: `${percentage}%`, backgroundColor: color, borderRadius: 4 }} />
      </View>
    </View>
  );
};

// ============================================
// WHEEL PICKER (scroll-based picker column)
// ============================================
const WHEEL_ITEM_HEIGHT = 44;
const WHEEL_VISIBLE_ITEMS = 5;

const WheelPicker = ({ items, selectedIndex, onSelect, width = 80 }) => {
  const flatListRef = useRef(null);
  const isScrolling = useRef(false);

  const padding = Math.floor(WHEEL_VISIBLE_ITEMS / 2);
  const paddedItems = [
    ...Array(padding).fill({ label: '', value: null }),
    ...items,
    ...Array(padding).fill({ label: '', value: null }),
  ];

  useEffect(() => {
    if (flatListRef.current && !isScrolling.current) {
      setTimeout(() => {
        flatListRef.current?.scrollToOffset({
          offset: selectedIndex * WHEEL_ITEM_HEIGHT,
          animated: false,
        });
      }, 50);
    }
  }, [selectedIndex]);

  return (
    <View style={{ height: WHEEL_ITEM_HEIGHT * WHEEL_VISIBLE_ITEMS, width, overflow: 'hidden' }}>
      <FlatList
        ref={flatListRef}
        data={paddedItems}
        keyExtractor={(_, i) => `wp-${i}`}
        showsVerticalScrollIndicator={false}
        snapToInterval={WHEEL_ITEM_HEIGHT}
        decelerationRate="fast"
        bounces={false}
        nestedScrollEnabled={true}
        getItemLayout={(_, index) => ({ length: WHEEL_ITEM_HEIGHT, offset: WHEEL_ITEM_HEIGHT * index, index })}
        onScrollBeginDrag={() => { isScrolling.current = true; }}
        onMomentumScrollEnd={(e) => {
          isScrolling.current = false;
          const idx = Math.round(e.nativeEvent.contentOffset.y / WHEEL_ITEM_HEIGHT);
          if (idx >= 0 && idx < items.length && idx !== selectedIndex) {
            onSelect(idx);
          }
        }}
        renderItem={({ item, index }) => {
          const realIndex = index - padding;
          const isSelected = realIndex === selectedIndex;
          return (
            <TouchableOpacity
              activeOpacity={0.7}
              onPress={() => {
                if (item.value !== null) {
                  onSelect(realIndex);
                }
              }}
              style={{ height: WHEEL_ITEM_HEIGHT, justifyContent: 'center', alignItems: 'center' }}
            >
              <Text style={{
                fontSize: isSelected ? 20 : 16,
                fontWeight: isSelected ? '700' : '400',
                color: item.value === null ? 'transparent' : (isSelected ? '#fff' : 'rgba(255,255,255,0.35)'),
              }}>
                {item.label}
              </Text>
            </TouchableOpacity>
          );
        }}
      />
      <View pointerEvents="none" style={{
        position: 'absolute',
        top: WHEEL_ITEM_HEIGHT * padding,
        left: 0, right: 0,
        height: WHEEL_ITEM_HEIGHT,
        borderTopWidth: 1, borderBottomWidth: 1,
        borderColor: 'rgba(251, 191, 36, 0.4)',
        backgroundColor: 'rgba(251, 191, 36, 0.08)',
      }} />
    </View>
  );
};

// ============================================
// DATE/TIME PICKERS (rendered as overlays, not nested Modals)
// ============================================
const DatePickerModal = ({ visible, onClose, onConfirm, initialDate }) => {
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const currentYear = new Date().getFullYear();
  const years = Array.from({ length: 50 }, (_, i) => currentYear - 49 + i);

  const parsed = initialDate ? new Date(initialDate + 'T00:00:00') : new Date();
  const [monthIdx, setMonthIdx] = useState(parsed.getMonth());
  const [dayIdx, setDayIdx] = useState(parsed.getDate() - 1);
  const [yearIdx, setYearIdx] = useState(years.indexOf(parsed.getFullYear()) >= 0 ? years.indexOf(parsed.getFullYear()) : years.length - 1);

  useEffect(() => {
    if (visible) {
      const p = initialDate ? new Date(initialDate + 'T00:00:00') : new Date();
      setMonthIdx(p.getMonth());
      setDayIdx(p.getDate() - 1);
      setYearIdx(years.indexOf(p.getFullYear()) >= 0 ? years.indexOf(p.getFullYear()) : years.length - 1);
    }
  }, [visible]);

  if (!visible) return null;

  const daysInMonth = new Date(years[yearIdx], monthIdx + 1, 0).getDate();
  const days = Array.from({ length: daysInMonth }, (_, i) => i + 1);
  const clampedDayIdx = Math.min(dayIdx, daysInMonth - 1);

  const monthItems = months.map((m, i) => ({ label: m, value: i }));
  const dayItems = days.map(d => ({ label: String(d), value: d }));
  const yearItems = years.map(y => ({ label: String(y), value: y }));

  return (
    <View style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, zIndex: 999 }}>
      <TouchableWithoutFeedback onPress={onClose}>
        <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.6)' }} />
      </TouchableWithoutFeedback>
      <View style={{ backgroundColor: '#1a1a2e', borderRadius: 20, marginHorizontal: 16, marginBottom: 20, paddingBottom: 20 }}>
        <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', padding: 16, borderBottomWidth: 1, borderBottomColor: 'rgba(255,255,255,0.1)' }}>
          <TouchableOpacity onPress={onClose} hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}>
            <Text style={{ color: 'rgba(255,255,255,0.5)', fontSize: 16 }}>Cancel</Text>
          </TouchableOpacity>
          <Text style={{ color: '#fff', fontSize: 17, fontWeight: '600' }}>Select Date</Text>
          <TouchableOpacity hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }} onPress={() => {
            const y = years[yearIdx];
            const m = String(monthIdx + 1).padStart(2, '0');
            const d = String(clampedDayIdx + 1).padStart(2, '0');
            onConfirm(`${y}-${m}-${d}`);
          }}>
            <Text style={{ color: '#fbbf24', fontSize: 16, fontWeight: '600' }}>Done</Text>
          </TouchableOpacity>
        </View>
        <View style={{ flexDirection: 'row', justifyContent: 'center', paddingVertical: 8 }}>
          <WheelPicker items={monthItems} selectedIndex={monthIdx} onSelect={setMonthIdx} width={80} />
          <WheelPicker items={dayItems} selectedIndex={clampedDayIdx} onSelect={setDayIdx} width={60} />
          <WheelPicker items={yearItems} selectedIndex={yearIdx} onSelect={setYearIdx} width={80} />
        </View>
      </View>
    </View>
  );
};

const TimePickerModal = ({ visible, onClose, onConfirm, initialTime }) => {
  // Parse 24h time into 12h components
  const parse24h = (t) => {
    const p = (t || '').split(':');
    const h24 = p.length === 2 ? parseInt(p[0]) || 0 : 12;
    const min = p.length === 2 ? parseInt(p[1]) || 0 : 0;
    const h12 = h24 === 0 ? 12 : h24 > 12 ? h24 - 12 : h24;
    const ampm = h24 >= 12 ? 1 : 0;
    return { hourIdx: h12 - 1, minuteIdx: min, amPmIdx: ampm };
  };

  const init = parse24h(initialTime);
  const [hourIdx, setHourIdx] = useState(init.hourIdx);
  const [minuteIdx, setMinuteIdx] = useState(init.minuteIdx);
  const [amPmIdx, setAmPmIdx] = useState(init.amPmIdx);

  useEffect(() => {
    if (visible) {
      const v = parse24h(initialTime);
      setHourIdx(v.hourIdx);
      setMinuteIdx(v.minuteIdx);
      setAmPmIdx(v.amPmIdx);
    }
  }, [visible]);

  if (!visible) return null;

  const hourItems = Array.from({ length: 12 }, (_, i) => ({ label: String(i + 1), value: i + 1 }));
  const minuteItems = Array.from({ length: 60 }, (_, i) => ({ label: String(i).padStart(2, '0'), value: i }));
  const amPmItems = [{ label: 'AM', value: 0 }, { label: 'PM', value: 1 }];

  return (
    <View style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, zIndex: 999 }}>
      <TouchableWithoutFeedback onPress={onClose}>
        <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.6)' }} />
      </TouchableWithoutFeedback>
      <View style={{ backgroundColor: '#1a1a2e', borderRadius: 20, marginHorizontal: 16, marginBottom: 20, paddingBottom: 20 }}>
        <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', padding: 16, borderBottomWidth: 1, borderBottomColor: 'rgba(255,255,255,0.1)' }}>
          <TouchableOpacity onPress={onClose} hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}>
            <Text style={{ color: 'rgba(255,255,255,0.5)', fontSize: 16 }}>Cancel</Text>
          </TouchableOpacity>
          <Text style={{ color: '#fff', fontSize: 17, fontWeight: '600' }}>Select Time</Text>
          <TouchableOpacity hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }} onPress={() => {
            // Convert 12h back to 24h for storage
            const h12 = hourIdx + 1;
            const h24 = amPmIdx === 0 ? (h12 === 12 ? 0 : h12) : (h12 === 12 ? 12 : h12 + 12);
            const h = String(h24).padStart(2, '0');
            const m = String(minuteIdx).padStart(2, '0');
            onConfirm(`${h}:${m}`);
          }}>
            <Text style={{ color: '#fbbf24', fontSize: 16, fontWeight: '600' }}>Done</Text>
          </TouchableOpacity>
        </View>
        <View style={{ flexDirection: 'row', justifyContent: 'center', alignItems: 'center', paddingVertical: 8 }}>
          <WheelPicker items={hourItems} selectedIndex={hourIdx} onSelect={setHourIdx} width={60} />
          <Text style={{ color: '#fff', fontSize: 24, fontWeight: '700', marginHorizontal: 2 }}>:</Text>
          <WheelPicker items={minuteItems} selectedIndex={minuteIdx} onSelect={setMinuteIdx} width={60} />
          <WheelPicker items={amPmItems} selectedIndex={amPmIdx} onSelect={setAmPmIdx} width={56} />
        </View>
      </View>
    </View>
  );
};

// Modal wrapper with proper keyboard handling and smooth scrolling
const ModalWrapper = ({ visible, onClose, title, children, colors, isDarkMode }) => {
  // Default colors for backwards compatibility (dark theme)
  const modalBg = colors ? (isDarkMode ? '#1a1a2e' : '#ffffff') : '#1a1a2e';
  const textColor = colors ? colors.text : '#fff';
  const borderColor = colors ? colors.border : 'rgba(255,255,255,0.1)';
  const buttonBg = colors ? (isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)') : 'rgba(255,255,255,0.1)';

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <View style={styles.modalOverlay}>
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={[styles.modalKeyboardView, { backgroundColor: modalBg }]}
        >
          <View style={[styles.modalContent, { backgroundColor: modalBg }]}>
            {/* Header - always visible */}
            <View style={[styles.modalHeader, { borderBottomColor: borderColor }]}>
              <Text style={[styles.modalTitle, { color: textColor }]}>{title}</Text>
              <TouchableOpacity
                onPress={onClose}
                style={[styles.closeButton, { backgroundColor: buttonBg }]}
                hitSlop={{ top: 20, bottom: 20, left: 20, right: 20 }}
              >
                <Text style={[styles.closeButtonText, { color: textColor }]}>âœ•</Text>
              </TouchableOpacity>
            </View>

            {/* Content - scrollable with keyboard dismiss on scroll */}
            <ScrollView
              keyboardShouldPersistTaps="handled"
              keyboardDismissMode="on-drag"
              showsVerticalScrollIndicator={false}
              contentContainerStyle={{ paddingBottom: 40 }}
            >
              {children}
            </ScrollView>
          </View>
        </KeyboardAvoidingView>
      </View>
    </Modal>
  );
};

// ============================================
// MAIN APP
// ============================================

/**
 * Client-side market hours check (fallback for backend)
 * Markets open: Sunday 6pm ET â†’ Friday 5pm ET
 * Markets closed: Friday 5pm ET â†’ Sunday 6pm ET
 */
function isMarketClosedClientSide() {
  try {
    const now = new Date();
    const fmt = new Intl.DateTimeFormat('en-US', {
      timeZone: 'America/New_York',
      hour12: false,
      weekday: 'short',
      hour: 'numeric',
      minute: 'numeric',
    });
    const parts = {};
    for (const p of fmt.formatToParts(now)) {
      parts[p.type] = p.value;
    }
    const dayMap = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };
    const day = dayMap[parts.weekday];
    const hour = parseInt(parts.hour, 10);

    const closed = (day === 6) || (day === 0 && hour < 18) || (day === 5 && hour >= 17);
    if (__DEV__) console.log(`ðŸ• Client market check: ET ${parts.weekday} ${hour}:${String(parseInt(parts.minute, 10)).padStart(2, '0')} â†’ ${closed ? 'CLOSED' : 'OPEN'}`);
    return closed;
  } catch (e) {
    return false;
  }
}

// Swipeable alert row using react-native-gesture-handler's Swipeable
const SwipeableAlertRow = ({ alert, colors, onDelete, onToggle, spotPrices }) => {
  const metalAccent = { gold: '#D4A843', silver: '#C0C0C0', platinum: '#7BB3D4', palladium: '#6BBF8A' };
  const metalLabel = alert.metal.charAt(0).toUpperCase() + alert.metal.slice(1);
  const accentColor = metalAccent[alert.metal] || metalAccent.silver;
  const currentSpot = spotPrices?.[alert.metal] || 0;
  const isActive = alert.enabled !== false;
  const arrow = alert.direction === 'above' ? 'â†‘' : 'â†“';
  const swipeableRef = useRef(null);

  const renderRightActions = () => (
    <TouchableOpacity
      onPress={() => {
        swipeableRef.current?.close();
        onDelete(alert.id);
      }}
      style={{
        backgroundColor: '#D32F2F', justifyContent: 'center', alignItems: 'center',
        width: 80, borderTopRightRadius: 12, borderBottomRightRadius: 12,
      }}
    >
      <Text style={{ color: '#fff', fontWeight: '700', fontSize: 13 }}>Delete</Text>
    </TouchableOpacity>
  );

  return (
    <View style={{ marginBottom: 10, borderRadius: 12, overflow: 'hidden' }}>
      <Swipeable ref={swipeableRef} renderRightActions={renderRightActions} overshootRight={false} friction={2}>
        <View style={{
          flexDirection: 'row', alignItems: 'center',
          backgroundColor: '#1e1e1e',
          borderRadius: 12, borderWidth: 1, borderColor: 'rgba(255,255,255,0.08)',
          overflow: 'hidden',
        }}>
          {/* Left accent bar */}
          <View style={{ width: 4, alignSelf: 'stretch', backgroundColor: accentColor }} />
          {/* Text content */}
          <View style={{ flex: 1, paddingVertical: 14, paddingLeft: 12, paddingRight: 4 }}>
            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 3 }}>
              <Text style={{ color: accentColor, fontWeight: '700', fontSize: 15 }}>{metalLabel}</Text>
              <Text style={{ color: alert.direction === 'above' ? '#4CAF50' : '#F44336', fontWeight: '700', fontSize: 15 }}>
                {arrow} {alert.direction === 'above' ? 'Above' : 'Below'}
              </Text>
              <Text style={{ color: '#fff', fontWeight: '700', fontSize: 15 }}>${parseFloat(alert.targetPrice).toFixed(2)}</Text>
            </View>
            <Text style={{ color: 'rgba(255,255,255,0.45)', fontSize: 12 }}>
              Current: ${currentSpot > 0 ? currentSpot.toFixed(2) : 'â€”'}/oz
            </Text>
          </View>
          {/* Toggle switch */}
          <View style={{ paddingRight: 12 }}>
            <Switch
              value={isActive}
              onValueChange={(val) => onToggle(alert.id, val)}
              trackColor={{ false: '#555', true: '#4CAF50' }}
              thumbColor="#fff"
              ios_backgroundColor="#555"
              style={{ transform: [{ scale: 0.85 }] }}
            />
          </View>
        </View>
      </Swipeable>
    </View>
  );
};

/**
 * Monotone cubic interpolation (Fritschâ€“Carlson) â€” produces smooth curves that
 * never overshoot data points, matching Recharts' type="monotone" on web.
 * Takes an array of {x, y} points and returns an SVG path string.
 */
const buildMonotonePath = (points) => {
  const n = points.length;
  if (n === 0) return '';
  if (n === 1) return `M${points[0].x.toFixed(1)},${points[0].y.toFixed(1)}`;
  if (n === 2) return `M${points[0].x.toFixed(1)},${points[0].y.toFixed(1)} L${points[1].x.toFixed(1)},${points[1].y.toFixed(1)}`;

  // 1. Compute slopes between consecutive points
  const dx = [], dy = [], m = [];
  for (let i = 0; i < n - 1; i++) {
    dx.push(points[i + 1].x - points[i].x);
    dy.push(points[i + 1].y - points[i].y);
    m.push(dx[i] === 0 ? 0 : dy[i] / dx[i]);
  }

  // 2. Compute tangent at each point (Fritschâ€“Carlson)
  const tangents = new Array(n);
  tangents[0] = m[0];
  tangents[n - 1] = m[n - 2];
  for (let i = 1; i < n - 1; i++) {
    if (m[i - 1] * m[i] <= 0) {
      tangents[i] = 0;
    } else {
      tangents[i] = (m[i - 1] + m[i]) / 2;
    }
  }

  // 3. Adjust tangents to ensure monotonicity
  for (let i = 0; i < n - 1; i++) {
    if (m[i] === 0) {
      tangents[i] = 0;
      tangents[i + 1] = 0;
    } else {
      const a = tangents[i] / m[i];
      const b = tangents[i + 1] / m[i];
      const s = a * a + b * b;
      if (s > 9) {
        const t = 3 / Math.sqrt(s);
        tangents[i] = t * a * m[i];
        tangents[i + 1] = t * b * m[i];
      }
    }
  }

  // 4. Build cubic bezier path
  let d = `M${points[0].x.toFixed(1)},${points[0].y.toFixed(1)}`;
  for (let i = 0; i < n - 1; i++) {
    const seg = dx[i] / 3;
    const cp1x = points[i].x + seg;
    const cp1y = points[i].y + tangents[i] * seg;
    const cp2x = points[i + 1].x - seg;
    const cp2y = points[i + 1].y - tangents[i + 1] * seg;
    d += ` C${cp1x.toFixed(1)},${cp1y.toFixed(1)} ${cp2x.toFixed(1)},${cp2y.toFixed(1)} ${points[i + 1].x.toFixed(1)},${points[i + 1].y.toFixed(1)}`;
  }
  return d;
};

/**
 * ScrubSparkline â€” sparkline with long-press-to-scrub crosshair and tooltip.
 * Uses onTouchStart/Move/End so it doesn't block ScrollView scroll.
 * Long press (~200ms) activates scrubbing; moving before that lets scroll happen.
 */
const ScrubSparkline = ({ dataPoints, timestamps, svgW, svgH, strokeColor, gradientId, formatValue, label, style }) => {
  const [scrubIndex, setScrubIndex] = useState(null);
  const scrubIndexRef = useRef(null);
  const containerRef = useRef(null);
  const containerX = useRef(0);
  const containerW = useRef(0);
  const longPressTimer = useRef(null);
  const isActive = useRef(false);
  const startPageX = useRef(0);
  const startPageY = useRef(0);

  const min = Math.min(...dataPoints);
  const max = Math.max(...dataPoints);
  const range = max - min || 1;

  // Build points array, then use monotone interpolation for smooth curves
  const pts = dataPoints.map((v, i) => ({
    x: (i / (dataPoints.length - 1)) * svgW,
    y: 4 + (svgH - 8) * (1 - (v - min) / range),
  }));
  const pathD = dataPoints.length <= 200 ? buildMonotonePath(pts)
    : pts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
  const fillD = `${pathD} L${svgW},${svgH} L0,${svgH} Z`;

  const getScrubDataIndex = (pageX) => {
    const relX = pageX - containerX.current;
    const pct = Math.max(0, Math.min(1, relX / containerW.current));
    return Math.round(pct * (dataPoints.length - 1));
  };

  const updateScrub = (pageX) => {
    const idx = getScrubDataIndex(pageX);
    if (idx !== scrubIndexRef.current) {
      scrubIndexRef.current = idx;
      setScrubIndex(idx);
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  };

  const handleTouchStart = (e) => {
    const { pageX, pageY } = e.nativeEvent;
    startPageX.current = pageX;
    startPageY.current = pageY;
    // Measure container position fresh on each touch
    containerRef.current?.measureInWindow?.((x, _y, w) => {
      containerX.current = x;
      containerW.current = w;
    });
    longPressTimer.current = setTimeout(() => {
      isActive.current = true;
      updateScrub(pageX);
    }, 200);
  };

  const handleTouchMove = (e) => {
    const { pageX, pageY } = e.nativeEvent;
    if (isActive.current) {
      updateScrub(pageX);
    } else if (longPressTimer.current) {
      // If finger moved >10px before long press fired, cancel â€” let scroll happen
      const dx = Math.abs(pageX - startPageX.current);
      const dy = Math.abs(pageY - startPageY.current);
      if (dx > 10 || dy > 10) {
        clearTimeout(longPressTimer.current);
        longPressTimer.current = null;
      }
    }
  };

  const handleTouchEnd = () => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
    }
    isActive.current = false;
    scrubIndexRef.current = null;
    setScrubIndex(null);
  };

  // Crosshair position in SVG coords
  const scrubXSvg = scrubIndex !== null ? (scrubIndex / (dataPoints.length - 1)) * svgW : 0;
  const scrubYSvg = scrubIndex !== null ? 4 + (svgH - 8) * (1 - (dataPoints[scrubIndex] - min) / range) : 0;

  const formatTime = (isoStr) => {
    if (!isoStr) return '';
    const d = new Date(isoStr);
    const h = d.getHours();
    const m = d.getMinutes();
    const ampm = h >= 12 ? 'PM' : 'AM';
    const h12 = h % 12 || 12;
    return `${h12}:${String(m).padStart(2, '0')} ${ampm}`;
  };

  return (
    <View
      ref={containerRef}
      onLayout={(e) => { containerW.current = e.nativeEvent.layout.width; }}
      style={style}
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      onTouchCancel={handleTouchEnd}
      // When scrub is active, tell parent ScrollView not to steal the touch
      onStartShouldSetResponder={() => false}
      onMoveShouldSetResponder={() => isActive.current}
      onResponderTerminationRequest={() => !isActive.current}
    >
      {/* Floating tooltip */}
      {scrubIndex !== null && (
        <View
          pointerEvents="none"
          style={{
            position: 'absolute',
            top: -38,
            left: Math.max(0, Math.min((scrubIndex / (dataPoints.length - 1)) * containerW.current - 60, containerW.current - 120)),
            backgroundColor: 'rgba(0,0,0,0.85)',
            borderRadius: 8,
            paddingHorizontal: 10,
            paddingVertical: 5,
            zIndex: 10,
            borderWidth: 1,
            borderColor: 'rgba(255,255,255,0.15)',
          }}
        >
          <Text style={{ color: '#fff', fontSize: 12, fontWeight: '700' }}>
            {label ? `${label}: ` : ''}{formatValue ? formatValue(dataPoints[scrubIndex]) : `$${dataPoints[scrubIndex].toFixed(2)}`}
          </Text>
          <Text style={{ color: 'rgba(255,255,255,0.6)', fontSize: 10 }}>
            {timestamps && timestamps[scrubIndex] ? formatTime(timestamps[scrubIndex]) : ''}
          </Text>
        </View>
      )}
      <Svg width="100%" height={svgH} viewBox={`0 0 ${svgW} ${svgH}`} preserveAspectRatio="none">
        <Defs>
          <SvgLinearGradient id={gradientId} x1="0" y1="0" x2="0" y2="1">
            <Stop offset="0" stopColor={strokeColor} stopOpacity="0.3" />
            <Stop offset="1" stopColor={strokeColor} stopOpacity="0" />
          </SvgLinearGradient>
        </Defs>
        <Path d={fillD} fill={`url(#${gradientId})`} />
        <Path d={pathD} stroke={strokeColor} strokeWidth={svgH > 40 ? 2 : 1.5} fill="none" />
        {/* Crosshair line + dot */}
        {scrubIndex !== null && (
          <>
            <Line x1={scrubXSvg} y1={0} x2={scrubXSvg} y2={svgH} stroke="rgba(255,255,255,0.4)" strokeWidth={1} strokeDasharray="3,2" />
            <Circle cx={scrubXSvg} cy={scrubYSvg} r={4} fill={strokeColor} stroke="#fff" strokeWidth={1.5} />
          </>
        )}
      </Svg>
    </View>
  );
};

/**
 * ScrubChart â€” larger chart with y-axis labels, x-axis date labels, and long-press scrubber.
 * Replaces react-native-chart-kit LineChart for Analytics spot price charts.
 */
const ScrubChart = ({ data, color, fillColor, width, height, range, decimalPlaces = 0, chartId = 'default', yFormat, tooltipFormat, secondaryData, secondaryColor }) => {
  const [scrubIndex, setScrubIndex] = useState(null);
  const scrubIndexRef = useRef(null);
  const containerRef = useRef(null);
  const containerX = useRef(0);
  const containerW = useRef(0);
  const longPressTimer = useRef(null);
  const isActive = useRef(false);
  const startPageX = useRef(0);
  const startPageY = useRef(0);
  const gradientId = `scrubChartFill-${chartId}`;

  // Chart layout
  const yLabelW = 52;
  const xLabelH = 18;
  const topPad = 6;
  const rightPad = 8;
  const chartW = width - yLabelW - rightPad;
  const chartH = height - xLabelH - topPad;

  // Filter out invalid data points and ensure ascending date order
  data = data.filter(d => d.value != null && !isNaN(d.value) && d.value > 0);
  data.sort((a, b) => (a.date < b.date ? -1 : a.date > b.date ? 1 : 0));

  // Filter out spike artifacts: drop points where value deviates >35% from neighbors' average
  // (real prices don't jump 35% between 15-min data points; sustained jumps are preserved)
  if (data.length > 2) {
    data = data.filter((pt, i) => {
      if (i === 0 || i === data.length - 1) return true;
      const prev = data[i - 1].value;
      const next = data[i + 1].value;
      const avgNeighbor = (prev + next) / 2;
      if (avgNeighbor === 0) return true;
      return Math.abs(pt.value - avgNeighbor) / avgNeighbor < 0.35;
    });
  }

  // Filter out stale data plateaus: when 3+ consecutive points have identical values,
  // keep only the first and last (these represent missing data where last price was carried forward)
  if (data.length > 3) {
    const filtered = [];
    let i = 0;
    while (i < data.length) {
      let j = i;
      while (j < data.length && data[j].value === data[i].value) j++;
      const runLen = j - i;
      if (runLen >= 3) {
        // Long plateau: keep first and last only
        filtered.push(data[i]);
        if (j - 1 > i) filtered.push(data[j - 1]);
      } else {
        // Short run: keep all points
        for (let k = i; k < j; k++) filtered.push(data[k]);
      }
      i = j;
    }
    data = filtered;
  }

  if (data.length < 2) return <View style={{ height }} />;

  // Data bounds (include secondary data in range if present)
  const values = data.map(d => d.value);
  const secValues = secondaryData ? secondaryData.filter(d => d.value != null && d.value > 0).map(d => d.value) : [];
  const allValues = [...values, ...secValues];
  const minVal = Math.min(...allValues);
  const maxVal = Math.max(...allValues);
  const valRange = maxVal - minVal || 1;
  const niceMin = minVal - valRange * 0.02;
  const niceMax = maxVal + valRange * 0.02;
  const niceRange = niceMax - niceMin;

  // SVG viewBox dimensions
  const svgW = chartW;
  const svgH = chartH;

  // Build path â€” use monotone cubic interpolation when under 200 points for smooth curves
  const pts = data.map((pt, i) => ({
    x: (i / (data.length - 1)) * svgW,
    y: topPad + svgH * (1 - (pt.value - niceMin) / niceRange),
  }));
  const pathD = data.length <= 200 ? buildMonotonePath(pts)
    : pts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
  const fillD = `${pathD} L${svgW},${topPad + svgH} L0,${topPad + svgH} Z`;

  // Build secondary path (optional, e.g. eligible line on vault chart)
  let secondaryPathD = null;
  if (secondaryData && secondaryData.length >= 2) {
    const secFiltered = secondaryData.filter(d => d.value != null && d.value > 0);
    if (secFiltered.length >= 2) {
      const secPts = secFiltered.map((pt, i) => ({
        x: (i / (secFiltered.length - 1)) * svgW,
        y: topPad + svgH * (1 - (pt.value - niceMin) / niceRange),
      }));
      secondaryPathD = secFiltered.length <= 200 ? buildMonotonePath(secPts)
        : secPts.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
    }
  }

  // Y-axis labels (5 levels)
  const yLabelCount = 5;
  const yLabels = [];
  for (let i = 0; i < yLabelCount; i++) {
    yLabels.push(maxVal - (i / (yLabelCount - 1)) * (maxVal - minVal));
  }
  const formatY = yFormat || ((v) => {
    if (v >= 100000) return `$${(v / 1000).toLocaleString('en-US', { maximumFractionDigits: 0 })}k`;
    return `$${Math.round(v).toLocaleString('en-US')}`;
  });

  // X-axis labels (5 evenly spaced, deduplicated)
  const xLabelCount = 5;
  const xLabels = [];
  const seenLabels = new Set();
  for (let n = 0; n < xLabelCount; n++) {
    const i = n === xLabelCount - 1 ? data.length - 1 : Math.round(n * (data.length - 1) / (xLabelCount - 1));
    const dateStr = data[i].date;
    const d = dateStr.includes('T') ? new Date(dateStr) : new Date(dateStr + 'T12:00:00');
    let label;
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    if (isNaN(d.getTime())) label = '';
    else if (range === 'ALL' || range === '5Y') label = `${d.getFullYear()}`;
    else if (range === '1Y' || range === '6M') label = `${monthNames[d.getMonth()]} '${String(d.getFullYear()).slice(-2)}`;
    else label = `${d.getMonth() + 1}/${d.getDate()}`;
    if (!seenLabels.has(label)) {
      seenLabels.add(label);
      xLabels.push({ i, label, x: (i / (data.length - 1)) * svgW });
    }
  }

  // Grid lines
  const gridYs = yLabels.map(v => topPad + svgH * (1 - (v - niceMin) / niceRange));

  // Scrub touch handlers
  const getScrubIndex = (pageX) => {
    const relX = pageX - containerX.current - yLabelW;
    const pct = Math.max(0, Math.min(1, relX / chartW));
    return Math.round(pct * (data.length - 1));
  };

  const updateScrub = (pageX) => {
    const idx = getScrubIndex(pageX);
    if (idx !== scrubIndexRef.current) {
      scrubIndexRef.current = idx;
      setScrubIndex(idx);
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  };

  const handleTouchStart = (e) => {
    const { pageX, pageY } = e.nativeEvent;
    startPageX.current = pageX;
    startPageY.current = pageY;
    containerRef.current?.measureInWindow?.((x, _y, w) => {
      containerX.current = x;
      containerW.current = w;
    });
    longPressTimer.current = setTimeout(() => {
      isActive.current = true;
      updateScrub(pageX);
    }, 200);
  };

  const handleTouchMove = (e) => {
    const { pageX, pageY } = e.nativeEvent;
    if (isActive.current) {
      updateScrub(pageX);
    } else if (longPressTimer.current) {
      const dx = Math.abs(pageX - startPageX.current);
      const dy = Math.abs(pageY - startPageY.current);
      if (dx > 10 || dy > 10) {
        clearTimeout(longPressTimer.current);
        longPressTimer.current = null;
      }
    }
  };

  const handleTouchEnd = () => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
    }
    isActive.current = false;
    scrubIndexRef.current = null;
    setScrubIndex(null);
  };

  // Scrub position
  const scrubXSvg = scrubIndex !== null ? (scrubIndex / (data.length - 1)) * svgW : 0;
  const scrubYSvg = scrubIndex !== null ? topPad + svgH * (1 - (data[scrubIndex].value - niceMin) / niceRange) : 0;

  const formatDate = (dateStr) => {
    const d = dateStr.includes('T') ? new Date(dateStr) : new Date(dateStr + 'T12:00:00');
    if (isNaN(d.getTime())) return dateStr;
    return `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
  };

  const formatPrice = tooltipFormat || ((v) => {
    if (decimalPlaces > 0) return `$${v.toFixed(decimalPlaces)}`;
    return `$${v.toLocaleString('en-US', { maximumFractionDigits: 2 })}`;
  });

  return (
    <View
      ref={containerRef}
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      onTouchCancel={handleTouchEnd}
      onStartShouldSetResponder={() => false}
      onMoveShouldSetResponder={() => isActive.current}
      onResponderTerminationRequest={() => !isActive.current}
    >
      {/* Floating tooltip */}
      {scrubIndex !== null && (
        <View
          pointerEvents="none"
          style={{
            position: 'absolute',
            top: -40,
            left: Math.max(0, Math.min(yLabelW + (scrubIndex / (data.length - 1)) * chartW - 70, width - 140)),
            backgroundColor: 'rgba(0,0,0,0.9)',
            borderRadius: 8,
            paddingHorizontal: 10,
            paddingVertical: 5,
            zIndex: 10,
            borderWidth: 1,
            borderColor: 'rgba(255,255,255,0.15)',
          }}
        >
          <Text style={{ color: '#fff', fontSize: 12, fontWeight: '700' }}>
            {formatPrice(data[scrubIndex].value)}
          </Text>
          <Text style={{ color: 'rgba(255,255,255,0.6)', fontSize: 10 }}>
            {formatDate(data[scrubIndex].date)}
          </Text>
        </View>
      )}
      <View style={{ flexDirection: 'row' }}>
        {/* Y-axis labels */}
        <View style={{ width: yLabelW, height: chartH + topPad, justifyContent: 'space-between', paddingVertical: 2 }}>
          {yLabels.map((v, i) => (
            <Text key={i} style={{ color: 'rgba(255,255,255,0.4)', fontSize: 10, textAlign: 'right', paddingRight: 4 }}>
              {formatY(v)}
            </Text>
          ))}
        </View>
        {/* SVG chart */}
        <Svg width={chartW} height={chartH + topPad}>
          {/* Grid lines */}
          {gridYs.map((y, i) => (
            <Line key={i} x1={0} y1={y} x2={svgW} y2={y} stroke="rgba(255,255,255,0.06)" strokeWidth={1} />
          ))}
          {/* Fill */}
          <Defs>
            <SvgLinearGradient id={gradientId} x1="0" y1="0" x2="0" y2="1">
              <Stop offset="0" stopColor={color} stopOpacity="0.2" />
              <Stop offset="1" stopColor={color} stopOpacity="0" />
            </SvgLinearGradient>
          </Defs>
          <Path d={fillD} fill={`url(#${gradientId})`} />
          <Path d={pathD} stroke={color} strokeWidth={2} fill="none" />
          {/* Secondary line (e.g. eligible inventory) */}
          {secondaryPathD && (
            <Path d={secondaryPathD} stroke={secondaryColor || 'rgba(255,255,255,0.4)'} strokeWidth={1.5} fill="none" strokeDasharray="4,3" />
          )}
          {/* Crosshair */}
          {scrubIndex !== null && (
            <>
              <Line x1={scrubXSvg} y1={0} x2={scrubXSvg} y2={topPad + svgH} stroke="rgba(255,255,255,0.4)" strokeWidth={1} strokeDasharray="3,2" />
              <Circle cx={scrubXSvg} cy={scrubYSvg} r={4} fill={color} stroke="#fff" strokeWidth={1.5} />
            </>
          )}
        </Svg>
      </View>
      {/* X-axis labels */}
      <View style={{ flexDirection: 'row', marginLeft: yLabelW, width: chartW, marginTop: 2 }}>
        {xLabels.map((lbl, i) => (
          <Text
            key={i}
            style={{
              color: 'rgba(255,255,255,0.4)',
              fontSize: 10,
              position: 'absolute',
              left: lbl.x - 18,
              width: 36,
              textAlign: 'center',
            }}
          >
            {lbl.label}
          </Text>
        ))}
      </View>
    </View>
  );
};

// Main app content (wrapped by ErrorBoundary below)
function AppContent() {
  // Safe area insets for proper spacing around system UI (navigation bar, notch, etc.)
  const insets = useSafeAreaInsets();

  // Supabase Auth
  const { user: supabaseUser, session, loading: authLoading, signOut: supabaseSignOut, linkedProviders, linkWithGoogle, linkWithApple } = useAuth();
  const [guestMode, setGuestMode] = useState(null); // null = loading, true = guest, false = require auth
  const [showAuthScreen, setShowAuthScreen] = useState(false);
  const [showAccountScreen, setShowAccountScreen] = useState(false);
  const [showResetPasswordScreen, setShowResetPasswordScreen] = useState(false);

  // Supabase Holdings Sync
  const [isSyncing, setIsSyncing] = useState(false);
  const [syncError, setSyncError] = useState(null);
  const [hasSyncedOnce, setHasSyncedOnce] = useState(false);

  // Theme
  const systemColorScheme = useColorScheme();
  const [themePreference, setThemePreference] = useState('system'); // 'system', 'light', 'dark'
  const [largeText, setLargeText] = useState(false); // Accessibility: increase font sizes
  const [hideWidgetValues, setHideWidgetValues] = useState(false); // Widget: hide dollar amounts

  // Derive actual theme from preference
  const isDarkMode = themePreference === 'system'
    ? systemColorScheme !== 'light'
    : themePreference === 'dark';

  // Font size multiplier for accessibility
  const fontScale = largeText ? 1.25 : 1;

  // Scaled font sizes for accessibility - apply to key text elements
  const scaledFonts = {
    huge: Math.round(32 * fontScale),      // Main portfolio value
    xlarge: Math.round(24 * fontScale),    // Spot prices, section values
    large: Math.round(18 * fontScale),     // Card titles, headers
    medium: Math.round(16 * fontScale),    // Button text, important labels
    normal: Math.round(14 * fontScale),    // Body text
    small: Math.round(12 * fontScale),     // Secondary text, descriptions
    tiny: Math.round(10 * fontScale),      // Timestamps, hints
  };

  // Core State
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [tab, setTab] = useState('today');
  const [metalTab, setMetalTab] = useState('both'); // Changed from 'silver' to 'both'

  // Spot Prices - Updated defaults for Dec 2025
  const [silverSpot, setSilverSpot] = useState(77);
  const [goldSpot, setGoldSpot] = useState(4530);
  const [platinumSpot, setPlatinumSpot] = useState(2100);
  const [palladiumSpot, setPalladiumSpot] = useState(1740);
  const [priceSource, setPriceSource] = useState('cached');
  const [priceTimestamp, setPriceTimestamp] = useState(null);
  const [spotPricesLive, setSpotPricesLive] = useState(false); // True after successful API fetch

  // Spot Price Daily Change
  const [spotChange, setSpotChange] = useState({
    gold: { amount: null, percent: null, prevClose: null },
    silver: { amount: null, percent: null, prevClose: null },
    platinum: { amount: null, percent: null, prevClose: null },
    palladium: { amount: null, percent: null, prevClose: null },
  });
  const [spotChangeDisplayMode, setSpotChangeDisplayMode] = useState('percent'); // 'percent' or 'amount'
  const [marketsClosed, setMarketsClosed] = useState(false); // True when markets are closed (Fri 5pm - Sun 6pm ET)


  // Portfolio Data
  const [silverItems, setSilverItems] = useState([]);
  const [goldItems, setGoldItems] = useState([]);
  const [platinumItems, setPlatinumItems] = useState([]);
  const [palladiumItems, setPalladiumItems] = useState([]);
  const [dataLoaded, setDataLoaded] = useState(false); // Prevents saving until initial load completes

  // Modals
  const [showAddModal, setShowAddModal] = useState(false);
  const [showPrivacyModal, setShowPrivacyModal] = useState(false);
  const [showSpeculationModal, setShowSpeculationModal] = useState(false);
  const [showJunkCalcModal, setShowJunkCalcModal] = useState(false);
  const [showPremiumAnalysisModal, setShowPremiumAnalysisModal] = useState(false);
  const [showPaywallModal, setShowPaywallModal] = useState(false);
  const [showTutorial, setShowTutorial] = useState(false);
  const [showV20Tutorial, setShowV20Tutorial] = useState(false);

  // Screenshot Mode (dev only â€” for App Store screenshots)
  const [screenshotMode, setScreenshotMode] = useState(false);
  const [versionTapCount, setVersionTapCount] = useState(0);
  const versionTapTimer = useRef(null);

  // Troy state
  const [advisorMessages, setAdvisorMessages] = useState([]);
  const [advisorInput, setAdvisorInput] = useState('');
  const [advisorLoading, setAdvisorLoading] = useState(false);
  const [advisorQuestionsToday, setAdvisorQuestionsToday] = useState(0);
  const advisorScrollRef = useRef(null);
  const [showTroyChat, setShowTroyChat] = useState(false);
  const fabScale = useRef(new Animated.Value(1)).current;
  const fabGlow = useRef(new Animated.Value(0.4)).current;
  const fabTapped = useRef(false);
  const [showImportPreview, setShowImportPreview] = useState(false);
  const [importData, setImportData] = useState([]);
  const [showDealerSelector, setShowDealerSelector] = useState(false);
  const [selectedDealer, setSelectedDealer] = useState(null);
  const [pendingImportFile, setPendingImportFile] = useState(null);
  const [showScannedItemsPreview, setShowScannedItemsPreview] = useState(false);
  const [scannedItems, setScannedItems] = useState([]);
  const [scannedMetadata, setScannedMetadata] = useState({ purchaseDate: '', purchaseTime: '', dealer: '' });
  const [showDetailView, setShowDetailView] = useState(false);
  const [detailItem, setDetailItem] = useState(null);
  const [detailMetal, setDetailMetal] = useState(null);
  const [showSortMenu, setShowSortMenu] = useState(false);
  const [showHelpModal, setShowHelpModal] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [showTimePicker, setShowTimePicker] = useState(false);
  const [showBenefitsScreen, setShowBenefitsScreen] = useState(false);
  const [settingsSubPage, setSettingsSubPage] = useState(null); // null, 'notifications', 'appearance', 'display', 'exportBackup', 'advanced'

  // Sort State
  const [sortBy, setSortBy] = useState('date-newest'); // date-newest, date-oldest, value-high, value-low, metal, name

  // Daily Snapshot State - stores oz counts and spot prices at midnight
  // This allows recalculating baseline when items are added/removed
  const [midnightSnapshot, setMidnightSnapshot] = useState(null);
  // Format: { silverOzt, goldOzt, silverSpot, goldSpot, date, timestamp }

  // Entitlements (__DEV__ is automatically false in production builds, so this never affects real users)
  const [hasGold, setHasGold] = useState(__DEV__ ? true : false);
  const [subscriptionLoading, setSubscriptionLoading] = useState(true); // Don't show upgrade prompts until loaded

  // Server-side scan tracking
  const [scanUsage, setScanUsage] = useState({
    scansUsed: 0,
    scansLimit: 5,
    resetsAt: null,
    loading: true
  });

  // Lifetime Access (granted via RevenueCat)
  const [hasLifetimeAccess, setHasLifetimeAccess] = useState(false);
  const [revenueCatUserId, setRevenueCatUserId] = useState(null);

  // iCloud Sync State
  const [iCloudSyncEnabled, setICloudSyncEnabled] = useState(false);
  const [iCloudAvailable, setICloudAvailable] = useState(false);
  const [iCloudSyncing, setICloudSyncing] = useState(false);
  const [lastSyncTime, setLastSyncTime] = useState(null);

  // Scan State
  const [scanStatus, setScanStatus] = useState(null);
  const [scanMessage, setScanMessage] = useState('');
  const [editingItem, setEditingItem] = useState(null);

  // Push Notifications State
  const [expoPushToken, setExpoPushToken] = useState(null);

  // Price Alerts State (free feature)
  const [priceAlerts, setPriceAlerts] = useState([]);
  const [showAddAlertModal, setShowAddAlertModal] = useState(false);
  const [alertsLoading, setAlertsLoading] = useState(false);
  const [newAlert, setNewAlert] = useState({
    metal: 'silver',
    targetPrice: '',
    direction: 'above', // 'above' or 'below'
  });
  // TODO v2.1: Implement ATH alerts with backend tracking

  // Analytics State (Gold/Lifetime feature)
  const [analyticsSnapshots, setAnalyticsSnapshots] = useState([]);
  const [analyticsRange, setAnalyticsRange] = useState('1M');
  const [analyticsLoading, setAnalyticsLoading] = useState(false);

  // Spot Price History State â€” per-metal charts
  const [spotHistoryMetal, setSpotHistoryMetal] = useState({
    gold: { range: '1Y', data: null, loading: false, error: null },
    silver: { range: '1Y', data: null, loading: false, error: null },
    platinum: { range: '1Y', data: null, loading: false, error: null },
    palladium: { range: '1Y', data: null, loading: false, error: null },
  });

  // Sparkline data for Metal Movers + Portfolio Pulse (24-hour trend)
  const [sparklineData, setSparklineData] = useState(null); // { gold: [N numbers], silver: [...], timestamps: [...] }
  const sparklineFetchedRef = useRef(false);

  // Share My Stack
  const shareViewRef = useRef(null);
  const [isGeneratingShare, setIsGeneratingShare] = useState(false);

  // Today Tab - AI Daily Brief
  const [dailyBrief, setDailyBrief] = useState(null); // { brief_text, date }
  const [dailyBriefLoading, setDailyBriefLoading] = useState(false);
  const [briefExpanded, setBriefExpanded] = useState(false);

  // Analytics Tab - Portfolio Intelligence
  const [portfolioIntel, setPortfolioIntel] = useState(null); // { text, costBasis, purchaseStats, date, is_current }
  const [portfolioIntelLoading, setPortfolioIntelLoading] = useState(false);
  const [portfolioIntelExpanded, setPortfolioIntelExpanded] = useState(false);
  const [costBasisIntelExpanded, setCostBasisIntelExpanded] = useState(false);
  const [purchaseStatsIntelExpanded, setPurchaseStatsIntelExpanded] = useState(false);

  // Notification Preferences
  const [notifPrefs, setNotifPrefs] = useState({ daily_brief: true, price_alerts: true, breaking_news: true, comex_alerts: true, comex_gold: true, comex_silver: true, comex_platinum: true, comex_palladium: true });

  // Side Drawer
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [expandedDrawerTab, setExpandedDrawerTab] = useState(null);
  const drawerAnim = useRef(new Animated.Value(-300)).current;
  const drawerOverlayAnim = useRef(new Animated.Value(0)).current;
  const sectionOffsets = useRef({});
  const drawerOpenRef = useRef(false);
  const openDrawerRef = useRef(null);
  const drawerPanResponder = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => false,
      onMoveShouldSetPanResponder: (evt, gestureState) => {
        return !drawerOpenRef.current && evt.nativeEvent.pageX < 60 && gestureState.dx > 10 && Math.abs(gestureState.dy) < 30;
      },
      onPanResponderRelease: (evt, gestureState) => {
        if (gestureState.dx > 50 && openDrawerRef.current) {
          openDrawerRef.current();
        }
      },
    })
  ).current;

  // Today Tab - Intelligence Feed
  const [intelligenceBriefs, setIntelligenceBriefs] = useState([]);
  const [intelligenceLoading, setIntelligenceLoading] = useState(false);
  const [intelligenceLastFetched, setIntelligenceLastFetched] = useState(null);
  const [intelligenceExpanded, setIntelligenceExpanded] = useState(false);

  // Today Tab - Vault Watch (COMEX Warehouse Inventory)
  const [vaultData, setVaultData] = useState({ gold: [], silver: [], platinum: [], palladium: [] });
  const [vaultLoading, setVaultLoading] = useState(false);
  const [vaultLastFetched, setVaultLastFetched] = useState(null);
  const [vaultMetal, setVaultMetal] = useState('silver'); // Default to silver

  // Custom Milestone State
  const [showMilestoneModal, setShowMilestoneModal] = useState(false);
  const [customSilverMilestone, setCustomSilverMilestone] = useState(null); // null means use default
  const [customGoldMilestone, setCustomGoldMilestone] = useState(null);
  const [tempSilverMilestone, setTempSilverMilestone] = useState('');
  const [tempGoldMilestone, setTempGoldMilestone] = useState('');
  const [lastReachedSilverMilestone, setLastReachedSilverMilestone] = useState(null);
  const [lastReachedGoldMilestone, setLastReachedGoldMilestone] = useState(null);

  // Analytics fetch abort controller - allows canceling in-progress fetches
  const analyticsAbortRef = useRef(null);

  // Historical price cache - avoids re-fetching same dates when switching time ranges
  // Format: { "2025-01-15": { gold: 2650, silver: 31.50 }, ... }
  const historicalPriceCache = useRef({});

  // Snapshots cache - stores ALL snapshots to avoid re-fetching on range change
  // We fetch once and filter client-side by range
  // primaryData = the chosen data source with best historical coverage
  const snapshotsCacheRef = useRef({ primaryData: null, fetched: false });

  // Spot price history cache - keyed by "metal-range" to avoid re-fetching
  const spotHistoryCacheRef = useRef({});

  // Scroll ref for scroll-to-top on tab re-tap
  const scrollRef = useRef(null);

  // Form State
  const [form, setForm] = useState({
    productName: '', source: '', datePurchased: '', timePurchased: '', ozt: '',
    quantity: '', unitPrice: '', taxes: '', shipping: '',
    spotPrice: '', premium: '0', costBasis: '',
  });
  const [formErrors, setFormErrors] = useState({});
  const [spotPriceSource, setSpotPriceSource] = useState(null); // Tracks data source for spot price warnings
  const [historicalSpotSuggestion, setHistoricalSpotSuggestion] = useState(null); // Suggested historical spot price for comparison

  // Speculation State
  const [specSilverPrice, setSpecSilverPrice] = useState('100');
  const [specGoldPrice, setSpecGoldPrice] = useState('5000');
  const [specPlatinumPrice, setSpecPlatinumPrice] = useState('2500');
  const [specPalladiumPrice, setSpecPalladiumPrice] = useState('2000');

  // Junk Silver Calculator State
  const [junkType, setJunkType] = useState('90');
  const [junkFaceValue, setJunkFaceValue] = useState('');

  // Screenshot mode triple-tap handler
  const handleVersionTap = () => {
    if (!__DEV__) return;
    const newCount = versionTapCount + 1;
    setVersionTapCount(newCount);
    clearTimeout(versionTapTimer.current);
    if (newCount >= 3) {
      setScreenshotMode(prev => !prev);
      setVersionTapCount(0);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      if (__DEV__) console.log('[Screenshot Mode]', !screenshotMode ? 'ACTIVATED' : 'DEACTIVATED');
    } else {
      versionTapTimer.current = setTimeout(() => setVersionTapCount(0), 600);
    }
  };

  // Generate natural-looking sparkline data for screenshot mode
  const generateDemoSparkline = (basePrice, count, uptrendPct) => {
    const points = [];
    for (let i = 0; i < count; i++) {
      const value = basePrice * (1 + (i / count) * uptrendPct + 0.003 * Math.sin(i * 0.5) + 0.002 * Math.sin(i * 1.3));
      points.push(value);
    }
    return points;
  };

  // Demo data for screenshot mode
  const demoData = screenshotMode ? {
    goldSpot: 5012,
    silverSpot: 78.40,
    platinumSpot: 2065,
    palladiumSpot: 1742,
    spotChange: {
      gold: { amount: 62, percent: 1.25 },
      silver: { amount: 1.85, percent: 2.42 },
      platinum: { amount: 28, percent: 1.37 },
      palladium: { amount: 18, percent: 1.04 },
    },
    totalMeltValue: 502847,
    dailyChange: 8241,
    dailyChangePct: 1.67,
    sparklineData: {
      gold: generateDemoSparkline(4950, 24, 0.012),
      silver: generateDemoSparkline(76.5, 24, 0.024),
      platinum: generateDemoSparkline(2037, 24, 0.014),
      palladium: generateDemoSparkline(1724, 24, 0.010),
      timestamps: Array.from({ length: 24 }, (_, i) => {
        const d = new Date();
        d.setHours(6 + Math.floor(i * 0.5), (i % 2) * 30, 0);
        return d.toISOString();
      }),
    },
    portfolioIntel: {
      text: 'Your portfolio is well-diversified across 4 metals with a strong gold core (68% allocation). Gold\'s sustained breakout above $5,000 positions your stack favorably. Consider your silver allocation â€” at 22%, it provides solid upside exposure to industrial demand catalysts. Your cost basis of $387,204 reflects disciplined accumulation, with an unrealized gain of $115,643 (+29.9%). The gold-to-silver ratio at 63.9 suggests silver remains relatively undervalued historically.',
      costBasis: 'Total cost basis: $387,204. Gold: $263,298 (68.0%), Silver: $85,185 (22.0%), Platinum: $28,933 (7.5%), Palladium: $9,788 (2.5%). Overall gain: +$115,643 (+29.9%).',
      purchaseStats: 'You\'ve made 47 purchases over 18 months. Average purchase: $8,238. Most active month: October 2025 (8 purchases). Preferred dealers: APMEX, JM Bullion, SD Bullion.',
      date: new Date().toDateString(),
      is_current: true,
    },
    analyticsSnapshots: (() => {
      const snaps = [];
      const baseValue = 380000;
      const days = 365;
      for (let i = 0; i < days; i++) {
        const d = new Date();
        d.setDate(d.getDate() - (days - i));
        const trend = baseValue * (1 + (i / days) * 0.32 + 0.015 * Math.sin(i * 0.05) + 0.008 * Math.sin(i * 0.13));
        snaps.push({
          date: d.toISOString().split('T')[0],
          total_value: Math.round(trend),
        });
      }
      return snaps;
    })(),
  } : null;

  // Colors - dynamic based on theme
  const colors = isDarkMode ? {
    // Dark mode colors
    silver: '#94a3b8',
    gold: '#fbbf24',
    platinum: '#7BB3D4',
    palladium: '#6BBF8A',
    success: '#22c55e',
    error: '#ef4444',
    text: '#e4e4e7',
    muted: '#71717a',
    background: '#09090b',
    cardBg: '#18181b',
    border: 'rgba(255,255,255,0.1)',
  } : {
    // Light mode colors
    silver: '#64748b',
    gold: '#fbbf24',
    platinum: '#7BB3D4',
    palladium: '#6BBF8A',
    success: '#16a34a',
    error: '#dc2626',
    text: '#18181b',
    muted: '#71717a',
    background: '#f4f4f5',
    cardBg: '#ffffff',
    border: 'rgba(0,0,0,0.1)',
  };

  // Change theme and save to AsyncStorage
  const changeTheme = async (newTheme) => {
    setThemePreference(newTheme);
    try {
      await AsyncStorage.setItem('stack_theme_preference', newTheme);
    } catch (error) {
      if (__DEV__) console.error('Failed to save theme preference:', error);
    }
  };

  // Toggle large text accessibility setting
  const toggleLargeText = async (enabled) => {
    setLargeText(enabled);
    try {
      await AsyncStorage.setItem('stack_large_text', enabled ? 'true' : 'false');
    } catch (error) {
      if (__DEV__) console.error('Failed to save large text preference:', error);
    }
  };

  // Clear all app data and reset to fresh state
  const clearAllData = async () => {
    try {
      // Clear all AsyncStorage keys
      await AsyncStorage.clear();

      // Reset all state to defaults
      setSilverItems([]);
      setGoldItems([]);
      setPlatinumItems([]);
      setPalladiumItems([]);
      setSilverSpot(77);
      setGoldSpot(4530);
      setPlatinumSpot(2100);
      setPalladiumSpot(1740);
      setPriceSource('cached');
      setPriceTimestamp(null);
      setSpotPricesLive(false);
      setSpotChange({ gold: { amount: null, percent: null, prevClose: null }, silver: { amount: null, percent: null, prevClose: null }, platinum: { amount: null, percent: null, prevClose: null }, palladium: { amount: null, percent: null, prevClose: null } });
      setSpotChangeDisplayMode('percent');
      setMidnightSnapshot(null);
      setThemePreference('system');
      setLargeText(false);

      // Show success message
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      Alert.alert('Data Cleared', 'All your data has been erased. The app has been reset to its initial state.');
    } catch (error) {
      if (__DEV__) console.error('Failed to clear data:', error);
      Alert.alert('Error', 'Failed to clear data. Please try again.');
    }
  };

  // Helper function to format currency with commas (fixed decimals)
  const formatCurrency = (value, decimals = 2) => {
    return value.toLocaleString(undefined, { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
  };

  // Smart currency formatting: shows decimals only if meaningful
  // "$100" not "$100.00", but "$100.50" if cents exist (always 2 decimals when not whole number)
  const formatSmartCurrency = (value, maxDecimals = 2) => {
    const rounded = Math.round(value * Math.pow(10, maxDecimals)) / Math.pow(10, maxDecimals);
    if (rounded === Math.floor(rounded)) {
      return rounded.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
    }
    // If there are cents, always show 2 decimal places (e.g., "$52,868.90" not "$52,868.9")
    return rounded.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: maxDecimals });
  };

  // Format quantity with smart decimals and commas
  const formatQuantity = (value) => {
    if (value === Math.floor(value)) {
      return value.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
    }
    return value.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
  };

  // Helper function to format ounces with smart decimals
  // Shows commas for thousands, removes trailing zeros
  // "12" not "12.000", "2,297" not "2297.00", but "12.5" or "2,297.25" if meaningful
  const formatOunces = (value, maxDecimals = 2) => {
    // Round to max decimals first
    const rounded = Math.round(value * Math.pow(10, maxDecimals)) / Math.pow(10, maxDecimals);
    // Check if it's a whole number
    if (rounded === Math.floor(rounded)) {
      return rounded.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
    }
    // Otherwise, show decimals but strip trailing zeros
    return rounded.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: maxDecimals });
  };

  // Helper function to calculate premium percentage
  const calculatePremiumPercent = (premium, unitPrice) => {
    if (unitPrice <= 0) return 0;
    return (premium / unitPrice) * 100;
  };

  // Helper function to get cost basis for an item (uses custom if set, otherwise calculates)
  const getItemCostBasis = (item) => {
    if (item.costBasis && item.costBasis > 0) {
      return item.costBasis;
    }
    return (item.unitPrice * item.quantity) + item.taxes + item.shipping;
  };

  // Helper function to format date for display (YYYY-MM-DD -> MM-DD-YYYY)
  const formatDateDisplay = (dateStr) => {
    if (!dateStr || dateStr.length !== 10) return dateStr || '';
    const parts = dateStr.split('-');
    if (parts.length !== 3) return dateStr;
    return `${parts[1]}-${parts[2]}-${parts[0]}`;
  };

  // Helper function to parse various date formats into YYYY-MM-DD
  // Handles: 2023-03-21, Mar 21 2023, 03/21/2023, 21/03/2023, March 21, 2023, Excel serial numbers, etc.
  const parseDate = (dateStr) => {
    if (dateStr === null || dateStr === undefined || dateStr === '') return '';

    // Handle numeric input directly (Excel serial numbers from XLSX)
    if (typeof dateStr === 'number') {
      const serial = Math.floor(dateStr); // Ignore time portion (decimal)
      if (serial >= 25000 && serial <= 55000) {
        // Convert Excel serial to JS date
        // Excel epoch is Jan 1, 1900, but has a bug counting Feb 29, 1900 (which didn't exist)
        const excelEpoch = new Date(1899, 11, 30); // Dec 30, 1899 (Excel's actual day 0)
        const jsDate = new Date(excelEpoch.getTime() + serial * 24 * 60 * 60 * 1000);
        const y = jsDate.getFullYear();
        const m = String(jsDate.getMonth() + 1).padStart(2, '0');
        const d = String(jsDate.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
      }
      return ''; // Invalid serial number
    }

    const str = String(dateStr).trim();
    if (!str) return '';

    // Excel serial number as string (integer or float like "46035" or "46035.791666")
    // Range ~25000-55000 covers years 1968-2050
    const serialMatch = str.match(/^(\d{4,5})(\.\d+)?$/);
    if (serialMatch) {
      const serial = parseInt(serialMatch[1]);
      if (serial >= 25000 && serial <= 55000) {
        // Convert Excel serial to JS date
        const excelEpoch = new Date(1899, 11, 30); // Dec 30, 1899 (Excel's actual day 0)
        const jsDate = new Date(excelEpoch.getTime() + serial * 24 * 60 * 60 * 1000);
        const y = jsDate.getFullYear();
        const m = String(jsDate.getMonth() + 1).padStart(2, '0');
        const d = String(jsDate.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
      }
    }

    // Month name mappings
    const months = {
      jan: '01', january: '01',
      feb: '02', february: '02',
      mar: '03', march: '03',
      apr: '04', april: '04',
      may: '05',
      jun: '06', june: '06',
      jul: '07', july: '07',
      aug: '08', august: '08',
      sep: '09', sept: '09', september: '09',
      oct: '10', october: '10',
      nov: '11', november: '11',
      dec: '12', december: '12',
    };

    // Already in YYYY-MM-DD format
    if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
      return str;
    }

    // ISO format with time: 2023-03-21T... -> 2023-03-21
    if (/^\d{4}-\d{2}-\d{2}T/.test(str)) {
      return str.substring(0, 10);
    }

    // MM/DD/YYYY or MM-DD-YYYY (US format)
    let match = str.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
    if (match) {
      const [, m, d, y] = match;
      return `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
    }

    // DD/MM/YYYY or DD-MM-YYYY (European format) - check if day > 12
    match = str.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
    if (match) {
      const [, first, second, y] = match;
      // If first number > 12, it must be day (European format)
      if (parseInt(first) > 12) {
        return `${y}-${second.padStart(2, '0')}-${first.padStart(2, '0')}`;
      }
    }

    // YYYY/MM/DD or YYYY.MM.DD
    match = str.match(/^(\d{4})[\/\.](\d{1,2})[\/\.](\d{1,2})$/);
    if (match) {
      const [, y, m, d] = match;
      return `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
    }

    // Month DD, YYYY or Month DD YYYY (e.g., "March 21, 2023" or "Mar 21 2023")
    match = str.match(/^([a-zA-Z]+)\s+(\d{1,2}),?\s+(\d{4})$/);
    if (match) {
      const [, monthStr, d, y] = match;
      const m = months[monthStr.toLowerCase()];
      if (m) {
        return `${y}-${m}-${d.padStart(2, '0')}`;
      }
    }

    // DD Month YYYY (e.g., "21 March 2023" or "21 Mar 2023")
    match = str.match(/^(\d{1,2})\s+([a-zA-Z]+),?\s+(\d{4})$/);
    if (match) {
      const [, d, monthStr, y] = match;
      const m = months[monthStr.toLowerCase()];
      if (m) {
        return `${y}-${m}-${d.padStart(2, '0')}`;
      }
    }

    // Month YYYY (assume day 1) - e.g., "March 2023"
    match = str.match(/^([a-zA-Z]+)\s+(\d{4})$/);
    if (match) {
      const [, monthStr, y] = match;
      const m = months[monthStr.toLowerCase()];
      if (m) {
        return `${y}-${m}-01`;
      }
    }

    // Try JavaScript's Date parser as last resort
    try {
      const parsed = new Date(str);
      if (!isNaN(parsed.getTime())) {
        const y = parsed.getFullYear();
        const m = String(parsed.getMonth() + 1).padStart(2, '0');
        const d = String(parsed.getDate()).padStart(2, '0');
        // Only accept if year is reasonable (1900-2100)
        if (y >= 1900 && y <= 2100) {
          return `${y}-${m}-${d}`;
        }
      }
    } catch (e) {
      // Ignore parse errors
    }

    // Return empty string if we couldn't parse it (prevents invalid data in Supabase)
    return '';
  };

  // ============================================
  // CALCULATIONS
  // ============================================

  const totalSilverOzt = silverItems.reduce((sum, i) => sum + (i.ozt * i.quantity), 0);
  const totalGoldOzt = goldItems.reduce((sum, i) => sum + (i.ozt * i.quantity), 0);
  const totalPlatinumOzt = platinumItems.reduce((sum, i) => sum + (i.ozt * i.quantity), 0);
  const totalPalladiumOzt = palladiumItems.reduce((sum, i) => sum + (i.ozt * i.quantity), 0);

  const silverMeltValue = totalSilverOzt * silverSpot;
  const goldMeltValue = totalGoldOzt * goldSpot;
  const platinumMeltValue = totalPlatinumOzt * platinumSpot;
  const palladiumMeltValue = totalPalladiumOzt * palladiumSpot;
  const totalMeltValue = silverMeltValue + goldMeltValue + platinumMeltValue + palladiumMeltValue;

  const silverCostBasis = silverItems.reduce((sum, i) => sum + (i.unitPrice * i.quantity) + i.taxes + i.shipping, 0);
  const goldCostBasis = goldItems.reduce((sum, i) => sum + (i.unitPrice * i.quantity) + i.taxes + i.shipping, 0);
  const platinumCostBasis = platinumItems.reduce((sum, i) => sum + (i.unitPrice * i.quantity) + i.taxes + i.shipping, 0);
  const palladiumCostBasis = palladiumItems.reduce((sum, i) => sum + (i.unitPrice * i.quantity) + i.taxes + i.shipping, 0);
  const totalCostBasis = silverCostBasis + goldCostBasis + platinumCostBasis + palladiumCostBasis;

  const silverPremiumsPaid = silverItems.reduce((sum, i) => sum + (i.premium * i.quantity), 0);
  const goldPremiumsPaid = goldItems.reduce((sum, i) => sum + (i.premium * i.quantity), 0);
  const platinumPremiumsPaid = platinumItems.reduce((sum, i) => sum + (i.premium * i.quantity), 0);
  const palladiumPremiumsPaid = palladiumItems.reduce((sum, i) => sum + (i.premium * i.quantity), 0);
  const totalPremiumsPaid = silverPremiumsPaid + goldPremiumsPaid + platinumPremiumsPaid + palladiumPremiumsPaid;
  const totalPremiumsPct = totalCostBasis > 0 ? ((totalPremiumsPaid / totalCostBasis) * 100) : 0;

  const totalGainLoss = totalMeltValue - totalCostBasis;
  const totalGainLossPct = totalCostBasis > 0 ? ((totalGainLoss / totalCostBasis) * 100) : 0;

  const silverGainLoss = silverMeltValue - silverCostBasis;
  const silverGainLossPct = silverCostBasis > 0 ? ((silverGainLoss / silverCostBasis) * 100) : 0;
  const goldGainLoss = goldMeltValue - goldCostBasis;
  const goldGainLossPct = goldCostBasis > 0 ? ((goldGainLoss / goldCostBasis) * 100) : 0;
  const platinumGainLoss = platinumMeltValue - platinumCostBasis;
  const platinumGainLossPct = platinumCostBasis > 0 ? ((platinumGainLoss / platinumCostBasis) * 100) : 0;
  const palladiumGainLoss = palladiumMeltValue - palladiumCostBasis;
  const palladiumGainLossPct = palladiumCostBasis > 0 ? ((palladiumGainLoss / palladiumCostBasis) * 100) : 0;

  const goldSilverRatio = silverSpot > 0 ? (goldSpot / silverSpot) : 0;

  const avgSilverCostPerOz = totalSilverOzt > 0 ? (silverCostBasis / totalSilverOzt) : 0;
  const avgGoldCostPerOz = totalGoldOzt > 0 ? (goldCostBasis / totalGoldOzt) : 0;
  const avgPlatinumCostPerOz = totalPlatinumOzt > 0 ? (platinumCostBasis / totalPlatinumOzt) : 0;
  const avgPalladiumCostPerOz = totalPalladiumOzt > 0 ? (palladiumCostBasis / totalPalladiumOzt) : 0;

  // Daily change calculation - uses holdings owned BEFORE today Ã— spot price changes
  // Holdings purchased today should NOT affect Today's Change (user didn't own them at midnight)
  const todayStr = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format

  // Filter to holdings that existed before today (purchased before today or no date = assume pre-existing)
  const preTodaySilverOzt = silverItems
    .filter(i => !i.datePurchased || i.datePurchased < todayStr)
    .reduce((sum, i) => sum + (i.ozt * i.quantity), 0);
  const preTodayGoldOzt = goldItems
    .filter(i => !i.datePurchased || i.datePurchased < todayStr)
    .reduce((sum, i) => sum + (i.ozt * i.quantity), 0);
  const preTodayPlatinumOzt = platinumItems
    .filter(i => !i.datePurchased || i.datePurchased < todayStr)
    .reduce((sum, i) => sum + (i.ozt * i.quantity), 0);
  const preTodayPalladiumOzt = palladiumItems
    .filter(i => !i.datePurchased || i.datePurchased < todayStr)
    .reduce((sum, i) => sum + (i.ozt * i.quantity), 0);

  // Midnight baseline = pre-today holdings Ã— midnight spot prices
  const midnightBaseline = midnightSnapshot
    ? (preTodaySilverOzt * midnightSnapshot.silverSpot) + (preTodayGoldOzt * midnightSnapshot.goldSpot) + (preTodayPlatinumOzt * (midnightSnapshot.platinumSpot || platinumSpot)) + (preTodayPalladiumOzt * (midnightSnapshot.palladiumSpot || palladiumSpot))
    : null;

  // Current value of pre-today holdings at live prices
  const preTodayCurrentValue = (preTodaySilverOzt * silverSpot) + (preTodayGoldOzt * goldSpot) + (preTodayPlatinumOzt * platinumSpot) + (preTodayPalladiumOzt * palladiumSpot);

  const dailyChange = midnightBaseline !== null ? (preTodayCurrentValue - midnightBaseline) : 0;
  const dailyChangePct = (midnightBaseline !== null && midnightBaseline > 0) ? ((dailyChange / midnightBaseline) * 100) : 0;
  const isDailyChangePositive = dailyChange >= 0;

  // Show daily change only if:
  // 1. We have a midnight snapshot
  // 2. The snapshot date is today
  // 3. We have live prices (not stale defaults)
  const isTodaySnapshot = midnightSnapshot?.date === new Date().toDateString();
  const showDailyChange = midnightSnapshot !== null
    && midnightBaseline > 0
    && isTodaySnapshot
    && spotPricesLive;

  // Speculation
  const specSilverNum = parseFloat(specSilverPrice) || silverSpot;
  const specGoldNum = parseFloat(specGoldPrice) || goldSpot;
  const specPlatinumNum = parseFloat(specPlatinumPrice) || platinumSpot;
  const specPalladiumNum = parseFloat(specPalladiumPrice) || palladiumSpot;
  const specTotalValue = (totalSilverOzt * specSilverNum) + (totalGoldOzt * specGoldNum) + (totalPlatinumOzt * specPlatinumNum) + (totalPalladiumOzt * specPalladiumNum);
  const specGainLoss = specTotalValue - totalCostBasis;
  const specGainLossPct = totalCostBasis > 0 ? ((specGainLoss / totalCostBasis) * 100) : 0;

  // Junk Silver
  const junkMultipliers = { '90': 0.715, '40': 0.295, '35': 0.0563 };
  const junkFaceNum = parseFloat(junkFaceValue) || 0;
  const junkOzt = junkType === '35' ? (junkFaceNum / 0.05) * junkMultipliers['35'] : junkFaceNum * junkMultipliers[junkType];
  const junkMeltValue = junkOzt * silverSpot;

  // Break-even
  const silverBreakeven = totalSilverOzt > 0 ? (silverCostBasis / totalSilverOzt) : 0;
  const goldBreakeven = totalGoldOzt > 0 ? (goldCostBasis / totalGoldOzt) : 0;
  const platinumBreakeven = totalPlatinumOzt > 0 ? (platinumCostBasis / totalPlatinumOzt) : 0;
  const palladiumBreakeven = totalPalladiumOzt > 0 ? (palladiumCostBasis / totalPalladiumOzt) : 0;

  // Milestones - use custom if set, otherwise use defaults
  const defaultSilverMilestones = [10, 50, 100, 250, 500, 1000];
  const defaultGoldMilestones = [1, 5, 10, 25, 50, 100];

  // If custom milestone is set, use it; otherwise find next default milestone
  const nextSilverMilestone = customSilverMilestone
    ? customSilverMilestone
    : (defaultSilverMilestones.find(m => totalSilverOzt < m) || 1000);

  const nextGoldMilestone = customGoldMilestone
    ? customGoldMilestone
    : (defaultGoldMilestones.find(m => totalGoldOzt < m) || 100);

  // ============================================
  // AUTO-CALCULATE PREMIUM
  // ============================================

  useEffect(() => {
    const unitPrice = parseFloat(form.unitPrice) || 0;
    const spotPrice = parseFloat(form.spotPrice) || 0;
    const ozt = parseFloat(form.ozt) || 0;

    if (unitPrice > 0 && spotPrice > 0 && ozt > 0) {
      const calculatedPremium = unitPrice - (spotPrice * ozt);
      // Only auto-fill positive premiums; negative means spot data is likely wrong
      setForm(prev => ({ ...prev, premium: Math.max(0, calculatedPremium).toFixed(2) }));
    }
  }, [form.unitPrice, form.spotPrice, form.ozt]);

  // ============================================
  // AUTHENTICATION & DATA
  // ============================================

  const authenticate = async () => {
    try {
      // Wrap all authentication in defensive try-catch
      let shouldAuthenticate = false;

      try {
        const hasHardware = await LocalAuthentication.hasHardwareAsync();
        const isEnrolled = await LocalAuthentication.isEnrolledAsync();

        if (hasHardware && isEnrolled) {
          const result = await LocalAuthentication.authenticateAsync({
            promptMessage: 'Unlock Stack Tracker Gold',
            fallbackLabel: 'Use Passcode',
          });
          shouldAuthenticate = result?.success === true;
        } else {
          // No biometric hardware or not enrolled - allow access
          shouldAuthenticate = true;
        }
      } catch (authError) {
        if (__DEV__) console.error('Biometric auth error (non-fatal):', authError?.message || authError);
        // If biometric fails, allow access anyway
        shouldAuthenticate = true;
      }

      // Only update state and load data if authentication succeeded or was skipped
      if (shouldAuthenticate) {
        setIsAuthenticated(true);
        // Wrap loadData in setTimeout to ensure state update completes first
        setTimeout(() => {
          loadData().catch(err => {
            if (__DEV__) console.error('loadData failed (non-fatal):', err?.message || err);
            setIsLoading(false); // Still hide loading even if data fails
          });
        }, 50);
      }
    } catch (e) {
      if (__DEV__) console.error('authenticate outer catch:', e?.message || e);
      setIsAuthenticated(true);
      setIsLoading(false);
    }
  };

  const loadData = async () => {
    try {
      const [silver, gold, platinum, palladium, silverS, goldS, platinumS, palladiumS, timestamp, hasSeenTutorial, storedMidnightSnapshot, storedTheme, storedChangeDisplayMode, storedLargeText, storedSilverMilestone, storedGoldMilestone, storedLastSilverReached, storedLastGoldReached, storedGuestMode, storedHideWidgetValues, hasSeenV20Tutorial, storedAdvisorCount] = await Promise.all([
        AsyncStorage.getItem('stack_silver'),
        AsyncStorage.getItem('stack_gold'),
        AsyncStorage.getItem('stack_platinum'),
        AsyncStorage.getItem('stack_palladium'),
        AsyncStorage.getItem('stack_silver_spot'),
        AsyncStorage.getItem('stack_gold_spot'),
        AsyncStorage.getItem('stack_platinum_spot'),
        AsyncStorage.getItem('stack_palladium_spot'),
        AsyncStorage.getItem('stack_price_timestamp'),
        AsyncStorage.getItem('stack_has_seen_tutorial'),
        AsyncStorage.getItem('stack_midnight_snapshot'),
        AsyncStorage.getItem('stack_theme_preference'),
        AsyncStorage.getItem('stack_spot_change_display_mode'),
        AsyncStorage.getItem('stack_large_text'),
        AsyncStorage.getItem('stack_silver_milestone'),
        AsyncStorage.getItem('stack_gold_milestone'),
        AsyncStorage.getItem('stack_last_silver_milestone_reached'),
        AsyncStorage.getItem('stack_last_gold_milestone_reached'),
        AsyncStorage.getItem('stack_guest_mode'),
        AsyncStorage.getItem('stack_hide_widget_values'),
        AsyncStorage.getItem('has_seen_v2_0_tutorial'),
        AsyncStorage.getItem('stack_advisor_count'),
      ]);

      // Safely parse JSON data with fallbacks
      if (silver) {
        try { setSilverItems(JSON.parse(silver)); } catch (e) { if (__DEV__) console.error('Failed to parse silver data'); }
      }
      if (gold) {
        try { setGoldItems(JSON.parse(gold)); } catch (e) { if (__DEV__) console.error('Failed to parse gold data'); }
      }
      if (platinum) {
        try { setPlatinumItems(JSON.parse(platinum)); } catch (e) { if (__DEV__) console.error('Failed to parse platinum data'); }
      }
      if (palladium) {
        try { setPalladiumItems(JSON.parse(palladium)); } catch (e) { if (__DEV__) console.error('Failed to parse palladium data'); }
      }
      if (silverS) setSilverSpot(parseFloat(silverS) || 30);
      if (goldS) setGoldSpot(parseFloat(goldS) || 2600);
      if (platinumS) setPlatinumSpot(parseFloat(platinumS) || 2100);
      if (palladiumS) setPalladiumSpot(parseFloat(palladiumS) || 1740);
      if (timestamp) setPriceTimestamp(timestamp);
      if (storedMidnightSnapshot) {
        try {
          setMidnightSnapshot(JSON.parse(storedMidnightSnapshot));
        } catch (e) {
          if (__DEV__) console.error('Failed to parse midnight snapshot');
        }
      }
      if (storedTheme && ['system', 'light', 'dark'].includes(storedTheme)) {
        setThemePreference(storedTheme);
      }
      if (storedChangeDisplayMode && ['percent', 'amount'].includes(storedChangeDisplayMode)) {
        setSpotChangeDisplayMode(storedChangeDisplayMode);
      }
      if (storedLargeText === 'true') {
        setLargeText(true);
      }

      // Load custom milestones
      if (storedSilverMilestone) {
        const parsed = parseFloat(storedSilverMilestone);
        if (!isNaN(parsed) && parsed > 0) setCustomSilverMilestone(parsed);
      }
      if (storedGoldMilestone) {
        const parsed = parseFloat(storedGoldMilestone);
        if (!isNaN(parsed) && parsed > 0) setCustomGoldMilestone(parsed);
      }
      if (storedLastSilverReached) {
        setLastReachedSilverMilestone(parseFloat(storedLastSilverReached));
      }
      if (storedLastGoldReached) {
        setLastReachedGoldMilestone(parseFloat(storedLastGoldReached));
      }

      // Load guest mode preference
      if (storedGuestMode === 'true') {
        setGuestMode(true);
      } else {
        setGuestMode(false);
      }

      // Load hide widget values preference
      if (storedHideWidgetValues === 'true') {
        setHideWidgetValues(true);
      }

      // Show tutorial if user hasn't seen it
      if (!hasSeenTutorial) {
        setShowTutorial(true);
      }

      // Show v2.0 tutorial if user hasn't seen it (and has seen the original)
      if (hasSeenTutorial && !hasSeenV20Tutorial) {
        setShowV20Tutorial(true);
      }

      // Load advisor daily question count (reset if from a different day)
      if (storedAdvisorCount) {
        try {
          const parsed = JSON.parse(storedAdvisorCount);
          const today = new Date().toDateString();
          if (parsed.date === today) {
            setAdvisorQuestionsToday(parsed.count || 0);
          }
        } catch (e) { /* ignore */ }
      }

      // Mark data as loaded BEFORE fetching prices - this prevents the save useEffect from overwriting
      setDataLoaded(true);

      // Delay fetchSpotPrices to not block the main thread
      setTimeout(() => {
        fetchSpotPrices().catch(err => {
          if (__DEV__ && err?.name !== 'AbortError') console.error('fetchSpotPrices failed:', err?.message);
        });
      }, 100);
    } catch (error) {
      if (__DEV__) console.error('Error loading data:', error?.message || error);
      // Still mark as loaded on error to prevent infinite loop, but data won't be overwritten
      setDataLoaded(true);
    } finally {
      setIsLoading(false);
    }
  };

  const saveData = async (key, data) => {
    try {
      await AsyncStorage.setItem(key, JSON.stringify(data));
    } catch (error) {
      if (__DEV__) console.error('Error saving data:', error);
    }
  };

  // Save custom milestone goals
  const saveMilestones = async () => {
    try {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

      const silverVal = parseFloat(tempSilverMilestone);
      const goldVal = parseFloat(tempGoldMilestone);

      // Validate inputs
      if (tempSilverMilestone && (isNaN(silverVal) || silverVal <= 0)) {
        Alert.alert('Invalid Input', 'Please enter a valid silver milestone (positive number)');
        return;
      }
      if (tempGoldMilestone && (isNaN(goldVal) || goldVal <= 0)) {
        Alert.alert('Invalid Input', 'Please enter a valid gold milestone (positive number)');
        return;
      }

      // Save silver milestone
      if (tempSilverMilestone && silverVal > 0) {
        setCustomSilverMilestone(silverVal);
        await AsyncStorage.setItem('stack_silver_milestone', silverVal.toString());
        // Reset "reached" tracking if new goal is higher than current stack
        if (silverVal > totalSilverOzt) {
          setLastReachedSilverMilestone(null);
          await AsyncStorage.removeItem('stack_last_silver_milestone_reached');
        }
      } else {
        setCustomSilverMilestone(null);
        await AsyncStorage.removeItem('stack_silver_milestone');
      }

      // Save gold milestone
      if (tempGoldMilestone && goldVal > 0) {
        setCustomGoldMilestone(goldVal);
        await AsyncStorage.setItem('stack_gold_milestone', goldVal.toString());
        if (goldVal > totalGoldOzt) {
          setLastReachedGoldMilestone(null);
          await AsyncStorage.removeItem('stack_last_gold_milestone_reached');
        }
      } else {
        setCustomGoldMilestone(null);
        await AsyncStorage.removeItem('stack_gold_milestone');
      }

      setShowMilestoneModal(false);
    } catch (error) {
      if (__DEV__) console.error('Error saving milestones:', error);
      Alert.alert('Error', 'Failed to save milestones. Please try again.');
    }
  };

  // ============================================
  // ICLOUD SYNC FUNCTIONS
  // ============================================

  // Check if iCloud is available
  const checkiCloudAvailability = async () => {
    if (Platform.OS !== 'ios') {
      setICloudAvailable(false);
      return false;
    }
    try {
      const available = await CloudStorage.isCloudAvailable();
      setICloudAvailable(available);
      return available;
    } catch (error) {
      if (__DEV__) console.log('iCloud availability check failed:', error?.message);
      setICloudAvailable(false);
      return false;
    }
  };

  // Load iCloud sync preference
  const loadiCloudSyncPreference = async () => {
    try {
      const enabled = await AsyncStorage.getItem('stack_icloud_sync_enabled');
      const lastSync = await AsyncStorage.getItem('stack_last_sync_time');
      if (enabled === 'true') setICloudSyncEnabled(true);
      if (lastSync) setLastSyncTime(lastSync);
    } catch (error) {
      if (__DEV__) console.error('Failed to load iCloud preference:', error);
    }
  };

  // Check if user has Gold access (Gold subscription or Lifetime)
  const hasGoldAccess = hasGold || hasLifetimeAccess;

  // Troy daily question limits
  const TROY_FREE_LIMIT = 3;
  const TROY_GOLD_LIMIT = 30;

  // Save holdings to iCloud
  const syncToCloud = async (silver = silverItems, gold = goldItems, platinum = platinumItems, palladium = palladiumItems) => {
    if (!hasGoldAccess || !iCloudSyncEnabled || !iCloudAvailable || Platform.OS !== 'ios') return;

    try {
      setICloudSyncing(true);
      const cloudData = {
        silverItems: silver,
        goldItems: gold,
        platinumItems: platinum,
        palladiumItems: palladium,
        lastModified: new Date().toISOString(),
        version: '1.1',
      };

      await CloudStorage.writeFile(
        ICLOUD_HOLDINGS_KEY,
        JSON.stringify(cloudData),
        CloudStorageScope.Documents
      );

      const syncTime = new Date().toISOString();
      setLastSyncTime(syncTime);
      await AsyncStorage.setItem('stack_last_sync_time', syncTime);
      if (__DEV__) console.log('Synced to iCloud successfully');
    } catch (error) {
      if (__DEV__) console.error('iCloud sync failed:', error?.message);
    } finally {
      setICloudSyncing(false);
    }
  };

  // Load holdings from iCloud
  const syncFromCloud = async () => {
    if (!iCloudAvailable || Platform.OS !== 'ios') return null;

    try {
      setICloudSyncing(true);
      const exists = await CloudStorage.exists(ICLOUD_HOLDINGS_KEY, CloudStorageScope.Documents);
      if (!exists) {
        if (__DEV__) console.log('No iCloud data found');
        return null;
      }

      const content = await CloudStorage.readFile(ICLOUD_HOLDINGS_KEY, CloudStorageScope.Documents);
      const cloudData = JSON.parse(content);

      return cloudData;
    } catch (error) {
      if (__DEV__) console.error('Failed to read from iCloud:', error?.message);
      return null;
    } finally {
      setICloudSyncing(false);
    }
  };

  // Toggle iCloud sync
  const toggleiCloudSync = async (enabled) => {
    if (enabled && !iCloudAvailable) {
      Alert.alert('iCloud Unavailable', 'Please sign in to iCloud in your device settings to enable sync.');
      return;
    }

    setICloudSyncEnabled(enabled);
    await AsyncStorage.setItem('stack_icloud_sync_enabled', enabled ? 'true' : 'false');

    if (enabled) {
      // Check for existing cloud data
      const cloudData = await syncFromCloud();
      if (cloudData && cloudData.lastModified) {
        const localTimestamp = await AsyncStorage.getItem('stack_last_modified');
        const cloudTime = new Date(cloudData.lastModified).getTime();
        const localTime = localTimestamp ? new Date(localTimestamp).getTime() : 0;

        if (cloudTime > localTime && (cloudData.silverItems?.length > 0 || cloudData.goldItems?.length > 0 || cloudData.platinumItems?.length > 0 || cloudData.palladiumItems?.length > 0)) {
          // Cloud data is newer - ask user or auto-apply
          Alert.alert(
            'iCloud Data Found',
            'Found newer data in iCloud. Would you like to use it?',
            [
              { text: 'Keep Local', style: 'cancel', onPress: () => syncToCloud() },
              {
                text: 'Use iCloud',
                onPress: () => {
                  if (cloudData.silverItems) setSilverItems(cloudData.silverItems);
                  if (cloudData.goldItems) setGoldItems(cloudData.goldItems);
                  if (cloudData.platinumItems) setPlatinumItems(cloudData.platinumItems);
                  if (cloudData.palladiumItems) setPalladiumItems(cloudData.palladiumItems);
                  setLastSyncTime(cloudData.lastModified);
                  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
                }
              },
            ]
          );
        } else {
          // Local is newer or same - sync to cloud
          await syncToCloud();
        }
      } else {
        // No cloud data - sync local to cloud
        await syncToCloud();
      }
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }
  };

  // Manual sync trigger
  const triggerManualSync = async () => {
    if (!iCloudAvailable) {
      Alert.alert('iCloud Unavailable', 'Please sign in to iCloud in your device settings.');
      return;
    }

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    await syncToCloud();
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    Alert.alert('Synced', 'Your holdings have been synced to iCloud.');
  };

  // Update local timestamp when data changes
  const updateLocalTimestamp = async () => {
    await AsyncStorage.setItem('stack_last_modified', new Date().toISOString());
  };

  // Initialize iCloud on app start
  useEffect(() => {
    if (Platform.OS === 'ios') {
      checkiCloudAvailability();
      loadiCloudSyncPreference();
    }
  }, []);

  // Sync to cloud when holdings change (debounced) - Gold/Lifetime only
  useEffect(() => {
    if (!isAuthenticated || !dataLoaded || !iCloudSyncEnabled || !hasGoldAccess) return;

    updateLocalTimestamp();
    const timeout = setTimeout(() => {
      syncToCloud();
    }, 2000); // Debounce 2 seconds

    return () => clearTimeout(timeout);
  }, [silverItems, goldItems, platinumItems, palladiumItems, iCloudSyncEnabled, isAuthenticated, dataLoaded, hasGoldAccess]);

  useEffect(() => {
    // Only save after initial data has been loaded to prevent overwriting with empty arrays
    if (isAuthenticated && dataLoaded) saveData('stack_silver', silverItems);
  }, [silverItems, isAuthenticated, dataLoaded]);

  useEffect(() => {
    // Only save after initial data has been loaded to prevent overwriting with empty arrays
    if (isAuthenticated && dataLoaded) saveData('stack_gold', goldItems);
  }, [goldItems, isAuthenticated, dataLoaded]);

  useEffect(() => {
    if (isAuthenticated && dataLoaded) saveData('stack_platinum', platinumItems);
  }, [platinumItems, isAuthenticated, dataLoaded]);

  useEffect(() => {
    if (isAuthenticated && dataLoaded) saveData('stack_palladium', palladiumItems);
  }, [palladiumItems, isAuthenticated, dataLoaded]);

  // Manual sync function - can be called on pull-to-refresh or button press
  const syncHoldingsWithSupabase = async (force = false) => {
    // Only sync if user is signed in and data is loaded
    if (!supabaseUser || !dataLoaded) {
      if (__DEV__) console.log('Sync skipped: user not signed in or data not loaded');
      return false;
    }

    // Skip if already syncing
    if (isSyncing) {
      if (__DEV__) console.log('Sync skipped: already syncing');
      return false;
    }

    // Skip if already synced (unless forced)
    if (hasSyncedOnce && !force) {
      if (__DEV__) console.log('Sync skipped: already synced this session (use force=true to override)');
      return false;
    }

    setIsSyncing(true);
    setSyncError(null);

    try {
      // Check if this user has ever synced before (for first-time migration)
      const syncKey = `stack_synced_${supabaseUser.id}`;
      const hasEverSynced = await AsyncStorage.getItem(syncKey);
      const isFirstSync = !hasEverSynced;

      if (__DEV__) console.log(`Starting Supabase holdings sync... (firstSync: ${isFirstSync})`);

      // fullSync will:
      // - If first sync AND Supabase empty: migrate local holdings to Supabase
      // - Otherwise: just fetch from Supabase (source of truth)
      const { silverItems: remoteSilver, goldItems: remoteGold, platinumItems: remotePlatinum, palladiumItems: remotePalladium, syncedToCloud, error } = await fullSync(
        supabaseUser.id,
        silverItems,
        goldItems,
        isFirstSync,
        platinumItems,
        palladiumItems
      );

      if (error) {
        if (__DEV__) console.error('Supabase sync error:', error);
        setSyncError(error.message);
        return false;
      } else {
        // Mark that this user has synced at least once
        await AsyncStorage.setItem(syncKey, 'true');

        // Replace local state with Supabase data (Supabase is source of truth)
        setSilverItems(remoteSilver);
        setGoldItems(remoteGold);
        setPlatinumItems(remotePlatinum);
        setPalladiumItems(remotePalladium);

        if (__DEV__) {
          if (__DEV__) console.log(`Supabase sync complete: ${syncedToCloud} items migrated, ${remoteSilver.length} silver, ${remoteGold.length} gold, ${remotePlatinum.length} platinum, ${remotePalladium.length} palladium from cloud`);
        }
      }

      setHasSyncedOnce(true);
      return true;
    } catch (err) {
      if (__DEV__) console.error('Supabase sync failed:', err);
      setSyncError(err.message || 'Sync failed');
      return false;
    } finally {
      setIsSyncing(false);
    }
  };

  // Supabase Holdings Sync - sync on app load when user is already signed in
  useEffect(() => {
    // Only run auto-sync if:
    // 1. User is signed in with Supabase
    // 2. Data has been loaded from local storage
    // 3. Haven't synced yet this session
    if (supabaseUser && dataLoaded && !hasSyncedOnce && !isSyncing) {
      if (__DEV__) console.log('Auto-sync triggered: user signed in, data loaded');
      syncHoldingsWithSupabase();
    }
  }, [supabaseUser, dataLoaded, hasSyncedOnce, isSyncing]);

  // Reset sync flag when user signs out
  useEffect(() => {
    if (!supabaseUser) {
      setHasSyncedOnce(false);
    }
  }, [supabaseUser]);

  // Milestone Reached Detection
  useEffect(() => {
    const checkMilestoneReached = async () => {
      // Check silver milestone
      if (customSilverMilestone && totalSilverOzt >= customSilverMilestone) {
        if (lastReachedSilverMilestone !== customSilverMilestone) {
          // Milestone reached! Show congratulations alert
          setLastReachedSilverMilestone(customSilverMilestone);
          await AsyncStorage.setItem('stack_last_silver_milestone_reached', customSilverMilestone.toString());

          // Suggest next milestone (1.5x rounded up)
          const suggestedNext = Math.ceil(customSilverMilestone * 1.5 / 10) * 10;

          Alert.alert(
            'Silver Goal Reached!',
            `Congratulations! You've reached your silver goal of ${customSilverMilestone} oz!`,
            [
              { text: 'Keep Current Goal', style: 'cancel' },
              {
                text: 'Set New Goal',
                onPress: () => {
                  setTempSilverMilestone(suggestedNext.toString());
                  setTempGoldMilestone(customGoldMilestone?.toString() || '');
                  setShowMilestoneModal(true);
                }
              },
            ]
          );
        }
      }

      // Check gold milestone
      if (customGoldMilestone && totalGoldOzt >= customGoldMilestone) {
        if (lastReachedGoldMilestone !== customGoldMilestone) {
          setLastReachedGoldMilestone(customGoldMilestone);
          await AsyncStorage.setItem('stack_last_gold_milestone_reached', customGoldMilestone.toString());

          const suggestedNext = Math.ceil(customGoldMilestone * 1.5);

          Alert.alert(
            'Gold Goal Reached!',
            `Congratulations! You've reached your gold goal of ${customGoldMilestone} oz!`,
            [
              { text: 'Keep Current Goal', style: 'cancel' },
              {
                text: 'Set New Goal',
                onPress: () => {
                  setTempGoldMilestone(suggestedNext.toString());
                  setTempSilverMilestone(customSilverMilestone?.toString() || '');
                  setShowMilestoneModal(true);
                }
              },
            ]
          );
        }
      }
    };

    if (dataLoaded) {
      checkMilestoneReached();
    }
  }, [totalSilverOzt, totalGoldOzt, customSilverMilestone, customGoldMilestone, dataLoaded]);

  useEffect(() => { authenticate(); }, []);

  // Register for push notifications (for price alerts)
  const registerForPushNotifications = async () => {
    if (__DEV__) console.log('ðŸ“± [Push] registerForPushNotifications() called');
    if (__DEV__) console.log('ðŸ“± [Push] API_BASE_URL:', API_BASE_URL);
    try {
      // Check existing permissions
      const { status: existingStatus } = await Notifications.getPermissionsAsync();
      if (__DEV__) console.log('ðŸ“± [Push] Current permission status:', existingStatus);
      let finalStatus = existingStatus;

      // Request permission if not granted
      if (existingStatus !== 'granted') {
        if (__DEV__) console.log('ðŸ“± [Notifications] Requesting permission...');
        const { status } = await Notifications.requestPermissionsAsync();
        finalStatus = status;
        if (__DEV__) console.log('ðŸ“± [Notifications] Permission result:', finalStatus);
      }

      if (finalStatus !== 'granted') {
        if (__DEV__) console.log('ðŸ“± [Notifications] Permission not granted, finalStatus:', finalStatus);
        return null;
      }

      // Get Expo push token
      const projectId = Constants.expoConfig?.extra?.eas?.projectId;
      if (__DEV__) console.log('ðŸ“± [Notifications] Getting push token, projectId:', projectId);
      const tokenData = await Notifications.getExpoPushTokenAsync({
        projectId,
      });

      const token = tokenData.data;
      if (__DEV__) console.log('ðŸ“± [Notifications] Push Token:', token);

      // Configure notification channel for Android
      if (Platform.OS === 'android') {
        await Notifications.setNotificationChannelAsync('default', {
          name: 'default',
          importance: Notifications.AndroidImportance.MAX,
          vibrationPattern: [0, 250, 250, 250],
          lightColor: '#fbbf24',
        });
      }

      // Sync token to backend for price alert notifications
      try {
        let deviceId = await AsyncStorage.getItem('device_id');
        if (!deviceId) {
          deviceId = Constants.deviceId || `anon-${Date.now()}`;
          await AsyncStorage.setItem('device_id', deviceId);
        }

        const response = await fetch(`${API_BASE_URL}/v1/push/register`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            expo_push_token: token,
            platform: Platform.OS,
            app_version: Constants.expoConfig?.version,
            user_id: supabaseUser?.id || null,
            device_id: deviceId,
          }),
        });

        const result = await response.json();
        if (!response.ok) {
          if (__DEV__) console.error('âŒ [Notifications] Backend rejected push token:', result);
          if (__DEV__) console.warn('Push notifications may not work for price alerts');
        } else {
          if (__DEV__) console.log('âœ… [Notifications] Push token registered with backend:', result);
        }
      } catch (backendError) {
        if (__DEV__) console.error('âŒ [Notifications] Failed to register token with backend:', backendError);
        if (__DEV__) console.warn('Push notifications for price alerts may not work â€” token sync failed');
      }

      return token;
    } catch (error) {
      if (__DEV__) console.error('âŒ [Notifications] Registration error:', error);
      return null;
    }
  };

  // Register for push notifications after authentication
  useEffect(() => {
    if (isAuthenticated) {
      if (__DEV__) console.log('ðŸ”” [Push] Authenticated â€” registering for push notifications...');
      registerForPushNotifications().then(token => {
        if (token) {
          if (__DEV__) console.log('ðŸ”” [Push] Token obtained:', token);
          setExpoPushToken(token);
        } else {
          if (__DEV__) console.log('ðŸ”” [Push] No token obtained (permission denied or error)');
        }
      });
    }
  }, [isAuthenticated]);

  // Fetch notification preferences from backend
  const fetchNotifPrefs = async () => {
    if (!supabaseUser?.id) return;
    try {
      const response = await fetch(`${API_BASE_URL}/v1/push/notification-preferences?userId=${supabaseUser.id}`);
      if (response.ok) {
        const data = await response.json();
        setNotifPrefs({
          daily_brief: data.daily_brief !== false,
          price_alerts: data.price_alerts !== false,
          breaking_news: data.breaking_news !== false,
          comex_alerts: data.comex_alerts !== false,
          comex_gold: data.comex_gold !== false,
          comex_silver: data.comex_silver !== false,
          comex_platinum: data.comex_platinum !== false,
          comex_palladium: data.comex_palladium !== false,
        });
      }
    } catch (err) {
      if (__DEV__) console.log('ðŸ”” [NotifPrefs] Fetch error:', err.message);
    }
  };

  // Save a single notification preference toggle
  const saveNotifPref = async (key, value) => {
    const updated = { ...notifPrefs, [key]: value };
    setNotifPrefs(updated);
    if (!supabaseUser?.id) return;
    try {
      await fetch(`${API_BASE_URL}/v1/push/notification-preferences`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId: supabaseUser.id, ...updated }),
      });
    } catch (err) {
      if (__DEV__) console.log('ðŸ”” [NotifPrefs] Save error:', err.message);
    }
  };

  // Fetch notification preferences after authentication
  useEffect(() => {
    if (isAuthenticated && supabaseUser?.id) {
      fetchNotifPrefs();
    }
  }, [isAuthenticated]);

  // Sync price alerts from backend on app load (works for anonymous + authenticated users)
  useEffect(() => {
    if (dataLoaded) {
      if (__DEV__) console.log('ðŸ”„ [Push] App loaded â€” syncing price alerts from backend');
      syncAlertsFromBackend();
    }
  }, [dataLoaded]);

  // Handle notification received in foreground (for logging)
  useEffect(() => {
    const receivedSub = Notifications.addNotificationReceivedListener(notification => {
      if (__DEV__) console.log('ðŸ”” [Push] Notification RECEIVED in foreground:', JSON.stringify(notification.request.content));
    });

    return () => receivedSub.remove();
  }, []);

  // Handle notification taps (when user taps on a push notification)
  useEffect(() => {
    const subscription = Notifications.addNotificationResponseReceivedListener(response => {
      const data = response.notification.request.content.data;
      if (__DEV__) console.log('ðŸ”” [Push] Notification TAPPED:', JSON.stringify(data));

      if (data.type === 'price_alert') {
        // Show alert details
        Alert.alert(
          `${data.metal ? data.metal.toUpperCase() : 'Price'} Alert`,
          `Current price: $${data.current_price || 'N/A'}\nTarget: $${data.target_price || 'N/A'}`,
          [{ text: 'OK' }]
        );
      }
    });

    return () => subscription.remove();
  }, []);

  // Check entitlements function (can be called after purchase)
  const checkEntitlements = async () => {
    try {
      const customerInfo = await Purchases.getCustomerInfo();

      // Safety checks for customerInfo structure
      if (!customerInfo) {
        if (__DEV__) console.log('âŒ No customer info returned from RevenueCat');
        return false;
      }

      const activeEntitlements = customerInfo?.entitlements?.active || {};
      const isGold = activeEntitlements['Gold'] !== undefined;
      const isLifetime = activeEntitlements['Lifetime'] !== undefined;
      const userId = customerInfo?.originalAppUserId || null;

      if (__DEV__) console.log('ðŸ“‹ RevenueCat User ID:', userId);
      if (__DEV__) console.log('ðŸ† Has Gold:', isGold, 'Has Lifetime:', isLifetime);

      setHasGold(__DEV__ ? true : isGold);
      setHasLifetimeAccess(__DEV__ ? true : isLifetime);
      setRevenueCatUserId(userId);

      return __DEV__ || isGold || isLifetime;
    } catch (error) {
      if (__DEV__) console.log('âŒ Error checking entitlements:', error);
      return __DEV__ || false;
    }
  };

  // Restore purchases handler (used by inline upgrade bars)
  const handleRestore = async () => {
    try {
      const hasGoldNow = await restorePurchases();
      if (hasGoldNow) {
        setHasGold(true);
        Alert.alert('Purchases Restored!', 'Your Gold subscription has been restored.');
      } else {
        Alert.alert('No Purchases Found', 'No active subscriptions were found to restore.');
      }
    } catch (error) {
      Alert.alert('Restore Failed', 'Could not restore purchases. Please try again.');
    }
  };

  // Initialize RevenueCat (non-blocking, runs after authentication)
  // IMPORTANT: Uses setTimeout to ensure this doesn't block the main render
  useEffect(() => {
    if (!isAuthenticated) return; // Wait for auth to complete first

    // Delay RevenueCat setup slightly to ensure UI renders first
    const timeoutId = setTimeout(() => {
      const setupRevenueCat = async () => {
        try {
          // Use the same API key for all builds - RevenueCat auto-detects sandbox vs production
          // based on the App Store receipt. EAS dev builds use release mode so __DEV__ is false.
          const apiKey = 'appl_WDKPrWsOHfWzfJhxOGluQYsniLW';

          if (__DEV__) console.log('ðŸ”§ Initializing RevenueCat...');

          // Pass Supabase user ID to tie subscriptions to user account (not device)
          // If guest mode, pass null (uses anonymous device ID)
          const appUserId = supabaseUser?.id || null;
          
          if (appUserId) {
            if (__DEV__) console.log('ðŸ‘¤ RevenueCat: Tying subscription to user account:', appUserId.substring(0, 8) + '...');
          } else if (guestMode) {
            if (__DEV__) console.log('ðŸ•¶ï¸ RevenueCat: Guest mode - using anonymous device ID');
          }

          const initialized = await initializePurchases(apiKey, appUserId);
          if (initialized) {
            // Log in to RevenueCat to transfer anonymous purchases to authenticated user
            if (appUserId) {
              try {
                await loginRevenueCat(appUserId);
              } catch (error) {
                if (__DEV__) console.error('RevenueCat login failed (non-fatal):', error?.message || error);
              }
            }
            // Additional delay before checking entitlements
            await new Promise(resolve => setTimeout(resolve, 100));
            await checkEntitlements();
            if (__DEV__) console.log('âœ… RevenueCat setup complete');
          } else {
            if (__DEV__) console.log('âš ï¸ RevenueCat initialization returned false, skipping entitlements');
          }
          setSubscriptionLoading(false); // Done checking subscription status
        } catch (error) {
          // Log but don't crash - RevenueCat is not critical for app function
          if (__DEV__) console.error('RevenueCat setup failed (non-fatal):', error?.message || error);
          setSubscriptionLoading(false); // Done even on error
        }
      };
      setupRevenueCat();
    }, 500); // 500ms delay to let UI settle

    return () => clearTimeout(timeoutId);
  }, [isAuthenticated, supabaseUser?.id, guestMode]); // Re-run when user changes

  // Register background fetch for iOS (keeps widget data fresh when app is closed)
  useEffect(() => {
    if (Platform.OS === 'ios') {
      const setupBackgroundFetch = async () => {
        try {
          const registered = await registerBackgroundFetch();
          if (registered) {
            const status = await getBackgroundFetchStatus();
            if (__DEV__) console.log('ðŸ“¡ Background fetch status:', status);
          }
        } catch (error) {
          // Non-critical - log but don't crash
          if (__DEV__) console.log('Background fetch setup skipped:', error?.message);
        }
      };
      setupBackgroundFetch();
    }
  }, []); // Run once on mount

  // Deep link handler for password reset
  useEffect(() => {
    const handleDeepLink = async (url) => {
      if (!url || !url.includes('auth/reset-password')) return;

      try {
        // Supabase appends tokens as hash fragments: #access_token=...&refresh_token=...
        const hashIndex = url.indexOf('#');
        if (hashIndex !== -1) {
          const hash = url.substring(hashIndex + 1);
          const params = {};
          hash.split('&').forEach(pair => {
            const [key, value] = pair.split('=');
            if (key && value) params[decodeURIComponent(key)] = decodeURIComponent(value);
          });

          if (params.access_token && params.refresh_token) {
            await supabase.auth.setSession({
              access_token: params.access_token,
              refresh_token: params.refresh_token,
            });
          }
        }
      } catch (err) {
        if (__DEV__) console.log('Failed to parse reset password deep link:', err?.message);
      }

      setShowResetPasswordScreen(true);
    };

    const subscription = Linking.addEventListener('url', ({ url }) => handleDeepLink(url));
    Linking.getInitialURL().then(url => {
      if (url) handleDeepLink(url);
    });

    return () => subscription.remove();
  }, []);

  // Fetch scan status when RevenueCat user ID is available
  useEffect(() => {
    if (revenueCatUserId && !hasGold && !hasLifetimeAccess) {
      fetchScanStatus();
    }
  }, [revenueCatUserId, hasGold, hasLifetimeAccess]);

  // Load price alerts from local storage
  useEffect(() => {
    if (hasGold || hasLifetimeAccess) {
      fetchPriceAlerts();
    }
  }, [hasGold, hasLifetimeAccess]);

  // Daily Snapshot: Check if it's a new day and update midnight snapshot
  // Stores oz counts and spot prices so we can recalculate baseline when items change
  useEffect(() => {
    const checkAndUpdateMidnightSnapshot = async () => {
      // IMPORTANT: Wait until data is loaded AND we have live spot prices from API
      // This prevents saving wrong values before prices are fetched
      if (!isAuthenticated || !dataLoaded || !spotPricesLive) {
        if (__DEV__ && !spotPricesLive && dataLoaded) {
          if (__DEV__) console.log('ðŸ“¸ Snapshot deferred: waiting for live spot prices...');
        }
        return;
      }

      // Only update if we have actual portfolio data (items loaded)
      // If totalMeltValue is 0 with no items, that's valid - but if items exist, value should be > 0
      const hasItems = silverItems.length > 0 || goldItems.length > 0 || platinumItems.length > 0 || palladiumItems.length > 0;
      if (hasItems && totalMeltValue === 0) {
        // Items exist but value is 0 - something is wrong, skip
        if (__DEV__) console.log('ðŸ“¸ Snapshot skipped: items exist but value is 0');
        return;
      }

      const today = new Date().toDateString(); // e.g., "Mon Dec 29 2025"

      // If no snapshot or it's a new day, create new snapshot
      if (!midnightSnapshot || midnightSnapshot.date !== today) {
        // Use previous day's closing prices if available (from backend change data)
        // This ensures "Today's Change" reflects actual movement since yesterday's close
        // Fall back to current prices only if prevClose is not available
        const baselineSilverSpot = spotChange.silver.prevClose ?? silverSpot;
        const baselineGoldSpot = spotChange.gold.prevClose ?? goldSpot;
        const baselinePlatinumSpot = spotChange.platinum?.prevClose ?? platinumSpot;
        const baselinePalladiumSpot = spotChange.palladium?.prevClose ?? palladiumSpot;

        const snapshot = {
          silverOzt: totalSilverOzt,
          goldOzt: totalGoldOzt,
          platinumOzt: totalPlatinumOzt,
          palladiumOzt: totalPalladiumOzt,
          silverSpot: baselineSilverSpot,
          goldSpot: baselineGoldSpot,
          platinumSpot: baselinePlatinumSpot,
          palladiumSpot: baselinePalladiumSpot,
          date: today,
          timestamp: new Date().toISOString(),
        };

        await AsyncStorage.setItem('stack_midnight_snapshot', JSON.stringify(snapshot));
        setMidnightSnapshot(snapshot);

        const snapshotValue = (totalSilverOzt * baselineSilverSpot) + (totalGoldOzt * baselineGoldSpot) + (totalPlatinumOzt * baselinePlatinumSpot) + (totalPalladiumOzt * baselinePalladiumSpot);
        const usingPrevClose = spotChange.silver.prevClose != null;
        if (__DEV__) console.log(`ðŸ“¸ Daily snapshot: ${totalSilverOzt.toFixed(2)}oz Ag @ $${baselineSilverSpot}, ${totalGoldOzt.toFixed(3)}oz Au @ $${baselineGoldSpot} = $${snapshotValue.toFixed(2)} (${usingPrevClose ? 'prev close' : 'current'})`);
      }
    };

    // Check on app open and when prices are loaded
    checkAndUpdateMidnightSnapshot();
  }, [isAuthenticated, dataLoaded, spotPricesLive, midnightSnapshot, totalSilverOzt, totalGoldOzt, totalPlatinumOzt, totalPalladiumOzt, silverSpot, goldSpot, platinumSpot, palladiumSpot, totalMeltValue, silverItems.length, goldItems.length, platinumItems.length, palladiumItems.length, spotChange]);

  // Auto-refresh spot prices every 1 minute (when app is active)
  // Track previous app state to detect foreground transitions
  const appStateRef = useRef(AppState.currentState);

  useEffect(() => {
    let priceRefreshInterval = null;

    const startPriceRefresh = () => {
      // Clear any existing interval
      if (priceRefreshInterval) {
        clearInterval(priceRefreshInterval);
      }

      // Fetch prices every 60 seconds (1 minute) when app is active
      priceRefreshInterval = setInterval(() => {
        if (__DEV__) console.log('ðŸ”„ Auto-refreshing spot prices (1-min interval)...');
        fetchSpotPrices(true); // silent = true (no loading indicator)
      }, 60000); // 60,000ms = 1 minute
    };

    const stopPriceRefresh = () => {
      if (priceRefreshInterval) {
        clearInterval(priceRefreshInterval);
        priceRefreshInterval = null;
        if (__DEV__) console.log('â¸ï¸  Paused auto-refresh (app in background)');
      }
    };

    // Listen to app state changes
    const subscription = AppState.addEventListener('change', (nextAppState) => {
      const previousState = appStateRef.current;
      appStateRef.current = nextAppState;

      // App came to foreground from background/inactive
      if (nextAppState === 'active' && previousState !== 'active') {
        if (__DEV__) console.log('â–¶ï¸  App came to foreground - fetching fresh prices immediately');
        // ALWAYS fetch fresh prices when app comes to foreground
        fetchSpotPrices(true).catch(err => {
          // Ignore AbortError, only log actual errors
          if (err?.name !== 'AbortError' && __DEV__) {
            if (__DEV__) console.error('Foreground price fetch failed:', err?.message);
          }
        });
        startPriceRefresh();
      } else if (nextAppState !== 'active') {
        // App went to background - stop auto-refresh
        stopPriceRefresh();
      }
    });

    // Start auto-refresh when component mounts (app is active)
    if (AppState.currentState === 'active') {
      startPriceRefresh();
    }

    // Cleanup on unmount
    return () => {
      stopPriceRefresh();
      subscription.remove();
    };
  }, []); // Empty dependency - set up once on mount

  // Free tier limit check
  const handleAddPurchase = () => {
    const FREE_TIER_LIMIT = 25;
    const totalItems = silverItems.length + goldItems.length + platinumItems.length + palladiumItems.length;

    if (!hasGold && !hasLifetimeAccess && totalItems >= FREE_TIER_LIMIT) {
      // User has reached free tier limit, show paywall
      // Haptic feedback on hitting limit
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);

      Alert.alert(
        'Upgrade to Gold',
        `You've reached the free tier limit of ${FREE_TIER_LIMIT} items. Upgrade to Gold for unlimited items!`,
        [
          { text: 'Maybe Later', style: 'cancel' },
          { text: 'Upgrade Now', onPress: () => setShowPaywallModal(true) }
        ]
      );
    } else {
      // User can add more items
      resetForm();
      // Ensure a valid metal is selected (not 'both') when adding new items
      if (metalTab === 'both' || metalTab === 'all') {
        setMetalTab('silver'); // Default to silver when adding from "All" view
      }
      setShowAddModal(true);
    }
  };

  // Tutorial completion handler
  const handleTutorialComplete = async () => {
    try {
      await AsyncStorage.setItem('stack_has_seen_tutorial', 'true');
      setShowTutorial(false);
    } catch (error) {
      if (__DEV__) console.error('Error saving tutorial status:', error);
      setShowTutorial(false);
    }
  };

  // v2.0 Tutorial completion handler
  const handleV20TutorialComplete = async () => {
    try {
      await AsyncStorage.setItem('has_seen_v2_0_tutorial', 'true');
      setShowV20Tutorial(false);
    } catch (error) {
      if (__DEV__) console.error('Error saving v2.0 tutorial status:', error);
      setShowV20Tutorial(false);
    }
  };

  // v2.0 Tutorial slides
  const v20TutorialSlides = [
    { emoji: 'â˜€ï¸', title: 'Meet Your New Today Tab', description: 'Get AI-powered market intelligence every morning. See what moved, what changed, and what it means for your stack.' },
    { emoji: 'ðŸ¦', title: 'COMEX Vault Watch', description: 'Track real-time COMEX warehouse inventory for gold, silver, platinum, and palladium. See when supply gets tight.' },
    { emoji: '', emojiComponent: <View style={{ marginBottom: 20 }}><TroyCoinIcon size={72} /></View>, title: 'Meet Troy', description: "Your personal stack analyst. Ask Troy anything about your portfolio â€” 'Should I buy more silver?' 'What's my break-even?' Tap the gold button on any screen." },
    { emoji: 'ðŸ”´ðŸŸ¡âšªðŸŸ¢', title: 'Platinum & Palladium', description: 'Now track all four precious metals. Your portfolio just got more powerful.' },
    { emoji: 'ðŸ§­', title: 'New Look, Same Power', description: "We've streamlined your navigation. Stack combines your dashboard and holdings in one place. Settings now lives in the tab bar. Everything you need, fewer taps." },
    { emoji: '', emojiComponent: <View style={{ marginBottom: 20 }}><GlobeIcon size={72} color="#D4A843" /></View>, title: 'Your Stack, Everywhere', description: 'Access your full portfolio on the web at stacktrackergold.com. Same data, same Troy, bigger screen.' },
    { emoji: 'âœ…', title: "You're All Set!", description: 'Enjoy Stack Tracker Gold v2.0. Built for stackers, by stackers.', highlight: 'Stack on! ðŸª™' },
  ];

  // Troy â€” send message
  const sendAdvisorMessage = async (messageText) => {
    const text = (messageText || advisorInput).trim();
    if (!text || advisorLoading) return;

    const dailyLimit = hasGoldAccess ? TROY_GOLD_LIMIT : TROY_FREE_LIMIT;
    const userMsg = { role: 'user', text, timestamp: Date.now() };

    if (advisorQuestionsToday >= dailyLimit) {
      if (!hasGoldAccess) {
        const upgradeMsg = {
          role: 'assistant',
          text: "That's my free limit for today. Upgrade to Gold and I'll analyze your entire stack anytime â€” cost basis, COMEX data, market intel, the works. Your call.",
          timestamp: Date.now(),
          isUpgradeCTA: true,
        };
        setAdvisorMessages(prev => [...prev, userMsg, upgradeMsg]);
        setAdvisorInput('');
        return;
      } else {
        Alert.alert('Daily Limit', "You've reached your daily limit. Check back tomorrow!");
        return;
      }
    }

    setAdvisorMessages(prev => [...prev, userMsg]);
    setAdvisorInput('');
    setAdvisorLoading(true);

    // Update daily count
    const newCount = advisorQuestionsToday + 1;
    setAdvisorQuestionsToday(newCount);
    AsyncStorage.setItem('stack_advisor_count', JSON.stringify({ date: new Date().toDateString(), count: newCount }));

    try {
      const history = advisorMessages.map(m => ({ role: m.role, content: m.text }));
      const response = await fetch(`${API_BASE_URL}/v1/advisor/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: supabaseUser?.id || null,
          message: text,
          conversationHistory: history,
          context: `User is on the ${tab} screen`,
        }),
      });
      const data = await response.json();
      if (data.response) {
        setAdvisorMessages(prev => [...prev, { role: 'assistant', text: data.response, timestamp: Date.now() }]);
      } else {
        setAdvisorMessages(prev => [...prev, { role: 'assistant', text: 'Sorry, I couldn\'t process that. Please try again.', timestamp: Date.now() }]);
      }
    } catch (error) {
      if (__DEV__) console.error('Advisor error:', error);
      setAdvisorMessages(prev => [...prev, { role: 'assistant', text: 'Connection error. Please check your internet and try again.', timestamp: Date.now() }]);
    } finally {
      setAdvisorLoading(false);
      setTimeout(() => advisorScrollRef.current?.scrollToEnd({ animated: true }), 100);
    }
  };

  // Server-side scan tracking functions
  const fetchScanStatus = async () => {
    if (!revenueCatUserId) {
      if (__DEV__) console.log('âš ï¸ No RevenueCat user ID yet, skipping scan status fetch');
      return;
    }

    // Skip for premium users - they have unlimited scans
    if (hasGold || hasLifetimeAccess) {
      setScanUsage(prev => ({ ...prev, loading: false }));
      return;
    }

    try {
      if (__DEV__) console.log(`ðŸ“Š Fetching scan status for user: ${revenueCatUserId.substring(0, 8)}...`);
      const response = await fetch(`${API_BASE_URL}/v1/scan-status?rcUserId=${encodeURIComponent(revenueCatUserId)}`);
      const data = await response.json();

      if (data.success) {
        setScanUsage({
          scansUsed: data.scansUsed,
          scansLimit: data.scansLimit,
          resetsAt: data.resetsAt,
          loading: false
        });
        if (__DEV__) console.log(`ðŸ“Š Scan status: ${data.scansUsed}/${data.scansLimit}, resets at ${data.resetsAt}`);
      } else {
        if (__DEV__) console.log('âš ï¸ Failed to fetch scan status:', data.error);
        setScanUsage(prev => ({ ...prev, loading: false }));
      }
    } catch (error) {
      if (__DEV__) console.log('âŒ Error fetching scan status:', error.message);
      // Fail open - allow scanning if server is unreachable
      setScanUsage(prev => ({ ...prev, loading: false }));
    }
  };

  const incrementScanCount = async () => {
    if (!revenueCatUserId) {
      if (__DEV__) console.log('âš ï¸ No RevenueCat user ID, cannot increment scan count');
      return;
    }

    try {
      if (__DEV__) console.log(`ðŸ“Š Incrementing scan count for user: ${revenueCatUserId.substring(0, 8)}...`);
      const response = await fetch(`${API_BASE_URL}/v1/increment-scan`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ rcUserId: revenueCatUserId })
      });
      const data = await response.json();

      if (data.success) {
        setScanUsage({
          scansUsed: data.scansUsed,
          scansLimit: data.scansLimit,
          resetsAt: data.resetsAt,
          loading: false
        });
        if (__DEV__) console.log(`ðŸ“Š New scan count: ${data.scansUsed}/${data.scansLimit}`);
      }
    } catch (error) {
      if (__DEV__) console.log('âŒ Error incrementing scan count:', error.message);
      // Still update local state optimistically
      setScanUsage(prev => ({ ...prev, scansUsed: prev.scansUsed + 1 }));
    }
  };

  const canScan = () => {
    if (hasGold || hasLifetimeAccess) return true; // Gold tier or lifetime access has unlimited scans
    return scanUsage.scansUsed < scanUsage.scansLimit;
  };

  const checkScanLimit = () => {
    if (hasGold || hasLifetimeAccess) return true; // Gold tier or lifetime access bypass

    if (scanUsage.scansUsed >= scanUsage.scansLimit) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);

      // Format reset date
      let resetDateStr = '';
      if (scanUsage.resetsAt) {
        resetDateStr = new Date(scanUsage.resetsAt).toLocaleDateString();
      }

      Alert.alert(
        'Scan Limit Reached',
        `You've used all ${scanUsage.scansLimit} free scans this month.${resetDateStr ? ` Resets on ${resetDateStr}.` : ''}\n\nUpgrade to Gold for unlimited scans!`,
        [
          { text: 'Maybe Later', style: 'cancel' },
          { text: 'Upgrade to Gold', onPress: () => setShowPaywallModal(true) }
        ]
      );
      return false;
    }
    return true;
  };

  // ============================================
  // PRICE ALERTS (Free Feature)
  // Alerts synced to Supabase price_alerts table via REST API. Backend checker sends push notifications.
  // Backend priceAlertChecker runs every 5 min, sends push via Expo when triggered.
  // TODO v2.1: Implement ATH alerts with backend tracking
  // ============================================

  // Load price alerts from AsyncStorage
  // Get device_id for alert identification (works for anonymous + authenticated users)
  const getDeviceId = async () => {
    let deviceId = await AsyncStorage.getItem('device_id');
    if (!deviceId) {
      deviceId = Constants.deviceId || `anon-${Date.now()}`;
      await AsyncStorage.setItem('device_id', deviceId);
    }
    return deviceId;
  };

  // Load price alerts from local storage
  const fetchPriceAlerts = async () => {
    try {
      const val = await AsyncStorage.getItem('stack_price_alerts');
      if (val) {
        const parsed = JSON.parse(val);
        setPriceAlerts(parsed);
        if (__DEV__) console.log(`ðŸ”” Loaded ${parsed.length} price alerts from local storage`);
      }
    } catch (error) {
      if (__DEV__) console.error('âŒ Error loading price alerts:', error);
    }
  };

  // Save price alerts to AsyncStorage
  const savePriceAlerts = async (alerts) => {
    try {
      await AsyncStorage.setItem('stack_price_alerts', JSON.stringify(alerts));
    } catch (error) {
      if (__DEV__) console.error('âŒ Error saving price alerts:', error);
    }
  };

  // Fetch alerts from backend â€” backend is source of truth, discard orphaned local alerts
  const syncAlertsFromBackend = async () => {
    try {
      const deviceId = await getDeviceId();
      const userId = supabaseUser?.id || null;
      const params = userId ? `user_id=${userId}&device_id=${deviceId}` : `device_id=${deviceId}`;
      const response = await fetch(`${API_BASE_URL}/v1/push/price-alerts?${params}`);
      const result = await response.json();

      if (result.success && result.alerts) {
        const backendAlerts = result.alerts
          .filter(a => !a.triggered && a.enabled !== false)
          .map(a => ({
            id: a.id,
            metal: a.metal,
            direction: a.direction,
            targetPrice: parseFloat(a.target_price),
            enabled: a.enabled,
            createdAt: a.created_at,
          }));

        // Try to push any local-only alerts to backend, keep only those that succeed
        const localAlerts = await AsyncStorage.getItem('stack_price_alerts');
        const localParsed = localAlerts ? JSON.parse(localAlerts) : [];
        const backendIds = new Set(backendAlerts.map(a => a.id));
        const localOnly = localParsed.filter(a => !backendIds.has(a.id));
        const syncedLocal = [];

        for (const alert of localOnly) {
          try {
            const res = await fetch(`${API_BASE_URL}/v1/push/price-alerts`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                id: alert.id,
                userId: userId,
                device_id: deviceId,
                metal: alert.metal,
                targetPrice: alert.targetPrice,
                direction: alert.direction,
                enabled: alert.enabled !== false,
              }),
            });
            const r = await res.json();
            if (r.success) syncedLocal.push(alert);
          } catch (e) { /* discard orphan */ }
        }

        // Only keep backend alerts + successfully synced local alerts
        const final = [...backendAlerts, ...syncedLocal];
        setPriceAlerts(final);
        await savePriceAlerts(final);
        if (__DEV__) console.log(`ðŸ”” [Push] Synced: ${backendAlerts.length} from backend, ${syncedLocal.length} local pushed, ${localOnly.length - syncedLocal.length} orphans discarded`);
      }
    } catch (error) {
      if (__DEV__) console.error('âŒ [Push] Failed to sync alerts from backend:', error);
    }
  };

  // Create a new custom price alert (saves to backend + local)
  const createPriceAlert = async () => {
    const targetPrice = parseFloat(newAlert.targetPrice);
    if (isNaN(targetPrice) || targetPrice <= 0) {
      Alert.alert('Invalid Price', 'Please enter a valid target price.');
      return;
    }

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

    const alertId = generateUUID();
    const deviceId = await getDeviceId();

    // Save to backend first
    try {
      const response = await fetch(`${API_BASE_URL}/v1/push/price-alerts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: alertId,
          userId: supabaseUser?.id || null,
          device_id: deviceId,
          metal: newAlert.metal,
          targetPrice: targetPrice,
          direction: newAlert.direction,
          enabled: true,
        }),
      });
      const result = await response.json();
      if (__DEV__) console.log('ðŸ”” [Push] Backend create response:', JSON.stringify(result));
    } catch (error) {
      if (__DEV__) console.error('âŒ [Push] Failed to create alert on backend:', error);
    }

    // Also save locally
    const alert = {
      id: alertId,
      metal: newAlert.metal,
      direction: newAlert.direction,
      targetPrice: targetPrice,
      enabled: true,
      createdAt: new Date().toISOString(),
    };

    const updated = [alert, ...priceAlerts];
    setPriceAlerts(updated);
    await savePriceAlerts(updated);

    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    setNewAlert({ metal: 'silver', targetPrice: '', direction: 'above' });

    Alert.alert(
      'Alert Created',
      `You'll be notified when ${newAlert.metal} goes ${newAlert.direction} $${targetPrice.toFixed(2)}/oz.`
    );
  };

  // Toggle a price alert enabled/disabled (local + backend PATCH)
  const togglePriceAlert = async (alertId, enabled) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    const updated = priceAlerts.map(a => a.id === alertId ? { ...a, enabled } : a);
    setPriceAlerts(updated);
    await savePriceAlerts(updated);
    try {
      await fetch(`${API_BASE_URL}/v1/push/price-alerts/${alertId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled }),
      });
    } catch (e) { /* silent */ }
  };

  // Delete a price alert (local + backend)
  const deletePriceAlert = async (alertId) => {
    Alert.alert(
      'Delete Alert',
      'Are you sure you want to delete this price alert?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
            if (__DEV__) console.log('ðŸ—‘ï¸ [Push] Deleting price alert:', alertId);
            const updated = priceAlerts.filter(a => a.id !== alertId);
            setPriceAlerts(updated);
            await savePriceAlerts(updated);

            // Delete from backend
            try {
              const response = await fetch(`${API_BASE_URL}/v1/push/price-alerts/${alertId}`, {
                method: 'DELETE',
              });
              const result = await response.json();
              if (__DEV__) console.log('ðŸ—‘ï¸ [Push] Backend delete response:', JSON.stringify(result));
            } catch (error) {
              if (__DEV__) console.error('âŒ [Push] Failed to delete alert from backend:', error);
            }

            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
          },
        },
      ]
    );
  };

  // Direct delete (no confirmation â€” used by swipe gesture)
  const deletePriceAlertDirect = async (alertId) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    const updated = priceAlerts.filter(a => a.id !== alertId);
    setPriceAlerts(updated);
    await savePriceAlerts(updated);
    try {
      await fetch(`${API_BASE_URL}/v1/push/price-alerts/${alertId}`, { method: 'DELETE' });
    } catch (e) { /* silent */ }
  };

  // Clear all price alerts (local + backend batch delete)
  const clearAllAlerts = () => {
    if (priceAlerts.length === 0) return;
    Alert.alert('Delete All Alerts', `Delete all ${priceAlerts.length} price alert${priceAlerts.length > 1 ? 's' : ''}?`, [
      { text: 'Cancel', style: 'cancel' },
      {
        text: 'Delete All', style: 'destructive', onPress: async () => {
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
          setPriceAlerts([]);
          await savePriceAlerts([]);
          try {
            const deviceId = await getDeviceId();
            const params = new URLSearchParams();
            if (supabaseUser?.id) params.append('user_id', supabaseUser.id);
            if (deviceId) params.append('device_id', deviceId);
            await fetch(`${API_BASE_URL}/v1/push/price-alerts?${params.toString()}`, { method: 'DELETE' });
          } catch (e) { /* silent */ }
          Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
        },
      },
    ]);
  };

  // ============================================
  // HOME SCREEN WIDGET (Gold/Lifetime Feature)
  // ============================================

  /**
   * Sync portfolio data to iOS home screen widget
   * Called when prices update or portfolio changes
   */
  const syncWidget = async () => {
    // Debug logging for subscription state
    if (__DEV__) console.log('ðŸ“± [syncWidget] Called with state:', {
      hasGold,
      hasLifetimeAccess,
      combinedSubscription: hasGold || hasLifetimeAccess,
      platform: Platform.OS,
      widgetKitAvailable: isWidgetKitAvailable(),
    });

    // Only sync for Gold/Lifetime subscribers
    if (!hasGold && !hasLifetimeAccess) {
      if (__DEV__) console.log('ðŸ“± [syncWidget] Skipping - no subscription');
      return;
    }

    // Only sync on iOS with WidgetKit available
    if (Platform.OS !== 'ios' || !isWidgetKitAvailable()) {
      if (__DEV__) console.log('ðŸ“± [syncWidget] Skipping - not iOS or WidgetKit unavailable');
      return;
    }

    try {
      // Calculate daily change (only for holdings owned before today)
      let dailyChangeAmt = 0;
      let dailyChangePct = 0;

      if (midnightSnapshot && spotPricesLive) {
        // Use pre-calculated values from main calculations (excludes today's purchases)
        const widgetMidnightBaseline = midnightBaseline;
        if (widgetMidnightBaseline && widgetMidnightBaseline > 0) {
          dailyChangeAmt = preTodayCurrentValue - widgetMidnightBaseline;
          dailyChangePct = (dailyChangeAmt / widgetMidnightBaseline) * 100;
        }
      }

      const widgetPayload = {
        portfolioValue: totalMeltValue,
        dailyChangeAmount: dailyChangeAmt,
        dailyChangePercent: dailyChangePct,
        goldSpot: goldSpot,
        silverSpot: silverSpot,
        goldChangeAmount: spotChange?.gold?.amount || 0,
        goldChangePercent: spotChange?.gold?.percent || 0,
        silverChangeAmount: spotChange?.silver?.amount || 0,
        silverChangePercent: spotChange?.silver?.percent || 0,
        goldValue: totalGoldOzt * goldSpot,
        silverValue: totalSilverOzt * silverSpot,
        platinumValue: totalPlatinumOzt * platinumSpot,
        palladiumValue: totalPalladiumOzt * palladiumSpot,
        goldOzt: totalGoldOzt,
        silverOzt: totalSilverOzt,
        platinumOzt: totalPlatinumOzt,
        palladiumOzt: totalPalladiumOzt,
        platinumSpot: platinumSpot,
        palladiumSpot: palladiumSpot,
        platinumChangeAmount: spotChange?.platinum?.amount || 0,
        platinumChangePercent: spotChange?.platinum?.percent || 0,
        palladiumChangeAmount: spotChange?.palladium?.amount || 0,
        palladiumChangePercent: spotChange?.palladium?.percent || 0,
        hasSubscription: hasGold || hasLifetimeAccess,
        hideValues: hideWidgetValues,
        goldSparkline: sparklineData?.gold || [],
        silverSparkline: sparklineData?.silver || [],
        platinumSparkline: sparklineData?.platinum || [],
        palladiumSparkline: sparklineData?.palladium || [],
      };

      if (__DEV__) console.log('ðŸ“± [syncWidget] Sending payload:', widgetPayload);

      await syncWidgetData(widgetPayload);

      if (__DEV__) console.log('âœ… [syncWidget] Widget data synced successfully');
    } catch (error) {
      if (__DEV__) console.error('âŒ [syncWidget] Failed:', error.message);
    }
  };

  // Sync widget when prices or portfolio changes
  useEffect(() => {
    if (dataLoaded && spotPricesLive && (hasGold || hasLifetimeAccess)) {
      syncWidget();
    }
  }, [totalMeltValue, totalGoldOzt, totalSilverOzt, totalPlatinumOzt, totalPalladiumOzt, silverSpot, goldSpot, platinumSpot, palladiumSpot, spotChange, dataLoaded, spotPricesLive, hasGold, hasLifetimeAccess, hideWidgetValues, sparklineData]);

  // Sync widget when app comes to foreground
  useEffect(() => {
    const subscription = AppState.addEventListener('change', (nextAppState) => {
      if (nextAppState === 'active' && (hasGold || hasLifetimeAccess)) {
        syncWidget();
      }
    });

    return () => subscription.remove();
  }, [hasGold, hasLifetimeAccess]);

  // ============================================
  // ANALYTICS (Gold/Lifetime Feature)
  // ============================================

  /**
   * Save daily portfolio snapshot for analytics
   * Only saves once per day (checks lastSnapshotDate in AsyncStorage)
   */
  const saveDailySnapshot = async () => {
    // Only for Gold/Lifetime subscribers
    if (!hasGold && !hasLifetimeAccess) return;
    if (!revenueCatUserId) return;
    if (!spotPricesLive) return; // Need live prices for accurate snapshot

    try {
      const today = new Date().toISOString().split('T')[0];
      const lastSnapshot = await AsyncStorage.getItem('lastSnapshotDate');

      // Only save one snapshot per day
      if (lastSnapshot === today) {
        if (__DEV__) console.log('ðŸ“Š Snapshot already saved today');
        return;
      }

      // Calculate portfolio values
      const goldValue = totalGoldOzt * goldSpot;
      const silverValue = totalSilverOzt * silverSpot;
      const platinumValue = totalPlatinumOzt * platinumSpot;
      const palladiumValue = totalPalladiumOzt * palladiumSpot;
      const totalValue = goldValue + silverValue + platinumValue + palladiumValue;

      const response = await fetch(`${API_BASE_URL}/v1/snapshots`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: revenueCatUserId,
          totalValue,
          goldValue,
          silverValue,
          platinumValue,
          palladiumValue,
          goldOz: totalGoldOzt,
          silverOz: totalSilverOzt,
          platinumOz: totalPlatinumOzt,
          palladiumOz: totalPalladiumOzt,
          goldSpot,
          silverSpot,
          platinumSpot,
          palladiumSpot,
        }),
      });

      const data = await response.json();

      if (data.success) {
        await AsyncStorage.setItem('lastSnapshotDate', today);
        if (__DEV__) console.log('ðŸ“Š Daily snapshot saved:', data.snapshot?.date);
      }
    } catch (error) {
      if (__DEV__) console.error('âŒ Error saving daily snapshot:', error.message);
    }
  };

  /**
   * Calculate historical portfolio values from holdings + historical spot prices
   * This generates chart data client-side without needing to persist every historical snapshot
   */
  const calculateHistoricalPortfolioData = async (range = '1M') => {
    const allItems = [...silverItems, ...goldItems, ...platinumItems, ...palladiumItems];
    if (allItems.length === 0) return [];

    // Determine date range
    const now = new Date();
    let startDate = new Date();
    switch (range.toUpperCase()) {
      case '1W': startDate.setDate(now.getDate() - 7); break;
      case '1M': startDate.setMonth(now.getMonth() - 1); break;
      case '3M': startDate.setMonth(now.getMonth() - 3); break;
      case '6M': startDate.setMonth(now.getMonth() - 6); break;
      case '1Y': startDate.setFullYear(now.getFullYear() - 1); break;
      case 'ALL':
        // Find oldest purchase date
        const oldestPurchase = allItems.reduce((oldest, item) => {
          if (item.datePurchased && item.datePurchased < oldest) return item.datePurchased;
          return oldest;
        }, now.toISOString().split('T')[0]);
        startDate = new Date(oldestPurchase);
        break;
    }

    // Generate dates with tiered density to ensure enough points for each time range:
    // - Last 7 days: every day (for 1W filter)
    // - Days 8-30: every 3 days (for 1M filter)
    // - Days 31-90: every 7 days (for 3M filter)
    // - Days 91-365: every 14 days (for 6M/1Y filter)
    // - Older than 1 year: every 30 days (for ALL filter)
    const dates = new Set(); // Use Set to avoid duplicates
    const totalDays = Math.ceil((now - startDate) / (1000 * 60 * 60 * 24));

    // Helper to add date if within range
    const addDate = (daysAgo) => {
      if (daysAgo <= totalDays) {
        const d = new Date(now);
        d.setDate(d.getDate() - daysAgo);
        dates.add(d.toISOString().split('T')[0]);
      }
    };

    // Last 7 days: every day (7 points)
    for (let i = 0; i <= 7; i++) {
      addDate(i);
    }

    // Days 8-30: every 3 days (~8 points)
    for (let i = 9; i <= 30; i += 3) {
      addDate(i);
    }

    // Days 31-90: every 7 days (~9 points)
    for (let i = 35; i <= 90; i += 7) {
      addDate(i);
    }

    // Days 91-365: every 14 days (~20 points)
    for (let i = 98; i <= 365; i += 14) {
      addDate(i);
    }

    // Older than 1 year: every 30 days
    for (let i = 395; i <= totalDays; i += 30) {
      addDate(i);
    }

    // Also add the start date if we have one
    if (totalDays > 0) {
      dates.add(startDate.toISOString().split('T')[0]);
    }

    // Convert to sorted array (today is already included via addDate(0))
    const sortedDates = Array.from(dates).sort();
    const today = now.toISOString().split('T')[0];
    if (__DEV__) console.log(`ðŸ“Š Generated ${sortedDates.length} date points for historical calculation`);
    if (__DEV__) console.log(`   First: ${sortedDates[0]}, Last: ${sortedDates[sortedDates.length - 1]}`);

    // Pre-cache today's prices from live spot data (avoids an API call)
    if (goldSpot > 0 && silverSpot > 0 && !historicalPriceCache.current[today]) {
      historicalPriceCache.current[today] = {
        gold: goldSpot,
        silver: silverSpot,
        platinum: platinumSpot,
        palladium: palladiumSpot,
      };
      if (__DEV__) console.log(`   ðŸ“¦ Pre-cached today's prices from live spot: Gold $${goldSpot}, Silver $${silverSpot}`);
    }

    // Check how many dates we need to fetch (not in cache)
    const uncachedDates = sortedDates.filter(d => !historicalPriceCache.current[d]);
    const cachedCount = sortedDates.length - uncachedDates.length;

    if (__DEV__) console.log(`ðŸ“Š Calculating ${sortedDates.length} data points for range ${range}`);
    if (__DEV__) console.log(`   ðŸ“¦ ${cachedCount} cached, ${uncachedDates.length} need fetching`);

    // Fetch historical prices from v1/prices/history per metal (batch endpoint doesn't exist on v1)
    if (uncachedDates.length > 0) {
      try {
        if (__DEV__) console.log(`   ðŸš€ Fetching price history for portfolio calculation...`);
        const metals = ['gold', 'silver', 'platinum', 'palladium'];
        const histResults = await Promise.all(
          metals.map(async (metal) => {
            try {
              const res = await fetch(`${API_BASE_URL}/v1/prices/history?range=ALL&metal=${metal}&maxPoints=500`);
              if (!res.ok) return [];
              const data = await res.json();
              return (data.prices || []).map(p => ({
                date: p.date.split('T')[0],
                price: p.price,
              }));
            } catch { return []; }
          })
        );

        // Build dateâ†’prices map, keeping the last price for each date per metal
        const dateMap = {};
        metals.forEach((metal, idx) => {
          for (const pt of histResults[idx]) {
            if (!pt.price || pt.price <= 0) continue;
            if (!dateMap[pt.date]) dateMap[pt.date] = {};
            dateMap[pt.date][metal] = pt.price;
          }
        });

        // Populate cache with entries that have at least gold and silver
        let fetchedCount = 0;
        for (const [date, prices] of Object.entries(dateMap)) {
          if (prices.gold && prices.silver && !historicalPriceCache.current[date]) {
            historicalPriceCache.current[date] = prices;
            fetchedCount++;
          }
        }

        // For dates not in the history data, interpolate from nearest available
        if (fetchedCount > 0) {
          const availDates = Object.keys(dateMap).filter(d => dateMap[d].gold && dateMap[d].silver).sort();
          for (const targetDate of uncachedDates) {
            if (historicalPriceCache.current[targetDate]) continue;
            // Find nearest available date
            let nearest = null;
            let minDist = Infinity;
            for (const d of availDates) {
              const dist = Math.abs(new Date(targetDate) - new Date(d));
              if (dist < minDist) { minDist = dist; nearest = d; }
            }
            if (nearest && minDist < 7 * 24 * 60 * 60 * 1000) { // within 7 days
              historicalPriceCache.current[targetDate] = dateMap[nearest];
              fetchedCount++;
            }
          }
        }

        if (__DEV__) console.log(`   âœ… History fetch complete: ${fetchedCount} date/prices cached`);
      } catch (error) {
        if (__DEV__) console.log('âš ï¸ Historical price fetch error:', error.message);
      }
    }

    const finalCachedCount = Object.keys(historicalPriceCache.current).length;
    if (__DEV__) console.log(`ðŸ“Š Fetch phase complete: ${finalCachedCount} total prices cached`);

    // Now calculate portfolio values using cached prices
    const historicalData = [];

    for (const date of sortedDates) {
      const cached = historicalPriceCache.current[date];
      if (!cached) continue; // Skip dates we couldn't fetch

      // Get items owned on this date (purchased on or before this date)
      // Items WITHOUT a purchase date are included at all dates (assumed always owned)
      const ownedItems = allItems.filter(item => !item.datePurchased || item.datePurchased <= date);
      if (ownedItems.length === 0) continue;

      // Calculate oz owned
      const silverOz = ownedItems
        .filter(i => silverItems.includes(i))
        .reduce((sum, i) => sum + (i.ozt * i.quantity), 0);
      const goldOz = ownedItems
        .filter(i => goldItems.includes(i))
        .reduce((sum, i) => sum + (i.ozt * i.quantity), 0);
      const platinumOz = ownedItems
        .filter(i => platinumItems.includes(i))
        .reduce((sum, i) => sum + (i.ozt * i.quantity), 0);
      const palladiumOz = ownedItems
        .filter(i => palladiumItems.includes(i))
        .reduce((sum, i) => sum + (i.ozt * i.quantity), 0);

      const silverSpotHist = cached.silver || silverSpot;
      const goldSpotHist = cached.gold || goldSpot;
      const platinumSpotHist = cached.platinum || platinumSpot;
      const palladiumSpotHist = cached.palladium || palladiumSpot;
      const totalValue = (silverOz * silverSpotHist) + (goldOz * goldSpotHist) + (platinumOz * platinumSpotHist) + (palladiumOz * palladiumSpotHist);

      historicalData.push({
        date,
        total_value: totalValue,
        gold_value: goldOz * goldSpotHist,
        silver_value: silverOz * silverSpotHist,
        platinum_value: platinumOz * platinumSpotHist,
        palladium_value: palladiumOz * palladiumSpotHist,
        gold_oz: goldOz,
        silver_oz: silverOz,
        platinum_oz: platinumOz,
        palladium_oz: palladiumOz,
        gold_spot: goldSpotHist,
        silver_spot: silverSpotHist,
        platinum_spot: platinumSpotHist,
        palladium_spot: palladiumSpotHist,
      });
    }

    if (__DEV__) console.log(`ðŸ“Š Historical calculation complete: ${historicalData.length} data points`);

    return historicalData;
  };

  /**
   * Filter snapshots array by time range (client-side filtering)
   */
  const filterSnapshotsByRange = (snapshots, range) => {
    if (!snapshots || snapshots.length === 0) return [];

    const now = new Date();
    let startDate;

    switch (range.toUpperCase()) {
      case '1D':
        // Return empty - the chart will handle 1D specially using midnightSnapshot
        return [];
      case '1W':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case '1M':
        startDate = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate());
        break;
      case '3M':
        startDate = new Date(now.getFullYear(), now.getMonth() - 3, now.getDate());
        break;
      case '6M':
        startDate = new Date(now.getFullYear(), now.getMonth() - 6, now.getDate());
        break;
      case '1Y':
        startDate = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
        break;
      case '5Y':
        startDate = new Date(now.getFullYear() - 5, now.getMonth(), now.getDate());
        break;
      case 'ALL':
      default:
        return snapshots; // Return all
    }

    const startDateStr = startDate.toISOString().split('T')[0];
    return snapshots.filter(s => s.date >= startDateStr);
  };

  /**
   * Apply the selected range filter to cached snapshots and update state
   */
  const applyRangeFilter = (range) => {
    const cache = snapshotsCacheRef.current;
    if (cache.primaryData && cache.primaryData.length > 0) {
      const filtered = filterSnapshotsByRange(cache.primaryData, range);
      // If filter returned empty but we have data, use all cached data as fallback
      if (filtered.length === 0 && range !== '1D') {
        if (__DEV__) console.log(`ðŸ“Š Range ${range}: 0 points after filter, using all ${cache.primaryData.length} points`);
        setAnalyticsSnapshots(cache.primaryData);
      } else {
        setAnalyticsSnapshots(filtered);
      }
      if (__DEV__) console.log(`ðŸ“Š Range ${range}: ${filtered.length} points`);
    }
  };

  /**
   * Fetch spot price history for a single metal chart.
   * Uses cache to avoid re-fetching when switching between ranges.
   */
  const fetchSpotPriceHistoryForMetal = async (metal, range) => {
    const cacheKey = `${metal}-${range}`;
    const cached = spotHistoryCacheRef.current[cacheKey];
    const cacheMaxAge = ['1M', '3M'].includes(range) ? 15 * 60 * 1000 : 60 * 60 * 1000;

    if (cached && (Date.now() - cached.fetchedAt) < cacheMaxAge) {
      setSpotHistoryMetal(prev => ({ ...prev, [metal]: { ...prev[metal], data: cached.data, loading: false, error: null } }));
      return;
    }

    setSpotHistoryMetal(prev => ({ ...prev, [metal]: { ...prev[metal], loading: true, error: null } }));

    try {
      const response = await fetch(
        `${API_BASE_URL}/v1/prices/history?range=${range}&metal=${metal}&maxPoints=500`
      );
      const result = await response.json();

      if (result.prices && result.prices.length > 0) {
        const minDate = (range === 'ALL' && (metal === 'platinum' || metal === 'palladium')) ? '2010-01-01' : null;
        const metalData = result.prices.map(pt => ({ date: pt.date, value: pt.price || 0 })).filter(pt => pt.value > 0 && (!minDate || pt.date >= minDate));
        if (metalData.length > 1) {
          spotHistoryCacheRef.current[cacheKey] = { data: metalData, fetchedAt: Date.now() };
          setSpotHistoryMetal(prev => ({ ...prev, [metal]: { ...prev[metal], data: metalData, loading: false, error: null } }));
        } else {
          setSpotHistoryMetal(prev => ({ ...prev, [metal]: { ...prev[metal], data: null, loading: false, error: 'no_data' } }));
        }
      } else {
        setSpotHistoryMetal(prev => ({ ...prev, [metal]: { ...prev[metal], data: null, loading: false, error: 'Historical data not available' } }));
      }
    } catch (error) {
      if (__DEV__) console.log(`Spot price history fetch error (${metal}):`, error.message);
      setSpotHistoryMetal(prev => ({ ...prev, [metal]: { ...prev[metal], data: null, loading: false, error: 'Failed to load' } }));
    }
  };

  /** Change range for a single metal chart */
  const setMetalRange = (metal, range) => {
    setSpotHistoryMetal(prev => ({ ...prev, [metal]: { ...prev[metal], range } }));
  };

  /** Fetch 24-hour sparkline data from /v1/sparkline-24h */
  const fetchSparklineData = async () => {
    if (sparklineFetchedRef.current) return;
    try {
      const res = await fetch(`${API_BASE_URL}/v1/sparkline-24h`);
      if (!res.ok) return;
      const data = await res.json();
      if (data.success && data.sparklines && data.sparklines.gold?.length >= 2) {
        setSparklineData({
          gold: data.sparklines.gold,
          silver: data.sparklines.silver,
          platinum: data.sparklines.platinum,
          palladium: data.sparklines.palladium,
          timestamps: data.timestamps || [],
        });
        sparklineFetchedRef.current = true;
      }
    } catch (e) {
      if (__DEV__) console.log('Sparkline fetch error:', e.message);
    }
  };

  /**
   * Fetch portfolio snapshots for analytics charts
   * Fetches ALL data once and caches it - subsequent range changes filter client-side
   * If user has holdings but no snapshots, calculates historical data
   * Uses AsyncStorage cache for instant render on app load
   */
  const fetchAnalyticsSnapshots = async (forceRefresh = false) => {
    if (!hasGold && !hasLifetimeAccess) return;

    const cache = snapshotsCacheRef.current;

    // If we have in-memory cached data and not forcing refresh, just apply the filter
    if (!forceRefresh && cache.fetched && cache.primaryData) {
      if (__DEV__) console.log('ðŸ“Š Using in-memory cached snapshots data');
      applyRangeFilter(analyticsRange);
      return;
    }

    // Try to load from AsyncStorage for instant render (before network)
    const diskCacheKey = 'portfolio_chart_cache';
    let showedCachedData = false;
    if (!forceRefresh && !cache.fetched) {
      try {
        const diskRaw = await AsyncStorage.getItem(diskCacheKey);
        if (diskRaw) {
          const diskCache = JSON.parse(diskRaw);
          const cacheAge = Date.now() - (diskCache.timestamp || 0);
          const fifteenMin = 15 * 60 * 1000;
          if (diskCache.data && diskCache.data.length > 0) {
            // Show cached data immediately
            cache.primaryData = diskCache.data;
            cache.fetched = true;
            const filtered = filterSnapshotsByRange(diskCache.data, analyticsRange);
            if (filtered.length === 0 && analyticsRange !== '1D' && diskCache.data.length > 0) {
              setAnalyticsSnapshots(diskCache.data);
            } else {
              setAnalyticsSnapshots(filtered);
            }
            showedCachedData = true;
            if (__DEV__) console.log(`ðŸ“Š Loaded ${diskCache.data.length} points from disk cache (${Math.round(cacheAge / 1000)}s old)`);

            // If cache is fresh (<15 min) and it's outside market hours, skip network fetch
            if (cacheAge < fifteenMin) {
              const now = new Date();
              const hour = now.getUTCHours();
              const day = now.getUTCDay();
              const isWeekend = day === 0 || day === 6;
              const isAfterHours = hour < 13 || hour > 22; // rough market hours UTC
              if (isWeekend || isAfterHours) {
                if (__DEV__) console.log('ðŸ“Š Disk cache is fresh and markets closed â€” skipping fetch');
                return;
              }
            }
          }
        }
      } catch (e) {
        // Disk cache read failed, proceed normally
      }
    }

    // Cancel any in-progress fetch
    if (analyticsAbortRef.current) {
      analyticsAbortRef.current.abort();
    }

    // Create new abort controller for this fetch
    const controller = new AbortController();
    analyticsAbortRef.current = controller;

    // Only show loading spinner if we don't have cached data to display
    if (!showedCachedData) setAnalyticsLoading(true);
    const hasHoldings = silverItems.length > 0 || goldItems.length > 0 || platinumItems.length > 0 || palladiumItems.length > 0;

    try {
      let apiSnapshots = [];

      // Only fetch from API if we have a userId
      if (revenueCatUserId) {
        try {
          // Add timeout
          const timeoutId = setTimeout(() => controller.abort(), 10000);

          // Always fetch ALL data - we filter client-side
          const response = await fetch(
            `${API_BASE_URL}/v1/snapshots/${encodeURIComponent(revenueCatUserId)}?range=ALL`,
            { signal: controller.signal }
          );
          clearTimeout(timeoutId);

          if (controller.signal.aborted) return;

          const data = await response.json();
          if (controller.signal.aborted) return;

          if (data.success) {
            apiSnapshots = data.snapshots || [];
            // Save current snapshot if user has holdings (don't await)
            if (hasHoldings) {
              saveDailySnapshot().catch(err => { if (__DEV__) console.log('Snapshot save error:', err.message); });
            }
          }
        } catch (apiError) {
          if (apiError.name === 'AbortError' || controller.signal.aborted) return;
          if (__DEV__) console.log('âš ï¸ API snapshot fetch failed:', apiError.message);
        }
      } else {
        if (__DEV__) console.log('ðŸ“Š No revenueCatUserId, skipping API fetch - using local calculation');
      }

      // Calculate historical data from holdings + historical spot prices
      let calculatedData = null;
      if (hasHoldings) {
        try {
          if (__DEV__) console.log('ðŸ“Š Calculating historical data from holdings...');
          calculatedData = await calculateHistoricalPortfolioData('ALL');
          if (controller.signal.aborted) return;
          if (__DEV__) console.log(`ðŸ“Š Calculated ${calculatedData?.length || 0} historical points`);
        } catch (histError) {
          if (controller.signal.aborted) return;
          if (__DEV__) console.log('âš ï¸ Historical calculation failed:', histError.message);
        }
      }

      // Determine best data source
      let finalData = [];
      const apiOldestDate = apiSnapshots.length > 0 ? apiSnapshots[0]?.date : null;
      const calcOldestDate = calculatedData?.length > 0 ? calculatedData[0]?.date : null;

      if (calculatedData && calculatedData.length > 0) {
        if (!apiOldestDate || (calcOldestDate && calcOldestDate < apiOldestDate)) {
          finalData = calculatedData;
          if (__DEV__) console.log(`ðŸ“Š Using calculated data (oldest: ${calcOldestDate}) over API (oldest: ${apiOldestDate})`);
        } else {
          finalData = apiSnapshots;
          if (__DEV__) console.log(`ðŸ“Š Using API snapshots (oldest: ${apiOldestDate})`);
        }
      } else if (apiSnapshots.length > 0) {
        finalData = apiSnapshots;
        if (__DEV__) console.log(`ðŸ“Š Using API snapshots only (${apiSnapshots.length} points)`);
      } else if (hasHoldings) {
        // Fallback: show today's data only
        finalData = [{
          date: new Date().toISOString().split('T')[0],
          total_value: totalMeltValue,
          gold_value: totalGoldOzt * goldSpot,
          silver_value: totalSilverOzt * silverSpot,
          gold_oz: totalGoldOzt,
          silver_oz: totalSilverOzt,
          gold_spot: goldSpot,
          silver_spot: silverSpot,
        }];
        if (__DEV__) console.log('ðŸ“Š Using today-only fallback');
      }

      // Only update UI if data actually changed from what we're showing
      const prevJson = showedCachedData ? JSON.stringify(cache.primaryData) : '';
      const newJson = JSON.stringify(finalData);
      const dataChanged = prevJson !== newJson;

      // Store and apply
      cache.primaryData = finalData;
      cache.fetched = true;

      if (dataChanged || !showedCachedData) {
        const filtered = filterSnapshotsByRange(finalData, analyticsRange);
        if (filtered.length === 0 && analyticsRange !== '1D' && finalData.length > 0) {
          setAnalyticsSnapshots(finalData);
        } else {
          setAnalyticsSnapshots(filtered);
        }
      }
      if (__DEV__) console.log(`ðŸ“Š Final: ${finalData.length} total points, dataChanged=${dataChanged}`);

      // Persist to AsyncStorage for next app launch
      AsyncStorage.setItem(diskCacheKey, JSON.stringify({
        data: finalData,
        timestamp: Date.now(),
      })).catch(() => {});
    } catch (error) {
      if (error.name === 'AbortError' || controller.signal.aborted) return;
      if (__DEV__) console.error('âŒ Error in analytics fetch:', error.message);
      cache.fetched = true;
      if (!showedCachedData) setAnalyticsSnapshots([]);
    } finally {
      if (!controller.signal.aborted) {
        setAnalyticsLoading(false);
      }
    }
  };

  // Save snapshot when data is loaded and prices are live
  useEffect(() => {
    if (dataLoaded && spotPricesLive && revenueCatUserId && (hasGold || hasLifetimeAccess)) {
      saveDailySnapshot();
    }
  }, [dataLoaded, spotPricesLive, revenueCatUserId, hasGold, hasLifetimeAccess]);

  // Fetch analytics when tab opens (data is cached, so only fetches once per session)
  // This effect triggers when: user navigates to Analytics tab, OR RevenueCat values become available while on Analytics
  useEffect(() => {
    // Early exit if not on analytics tab
    if (tab !== 'analytics') return;

    // Need subscription access (but NOT revenueCatUserId - we can calculate locally without it)
    if (!hasGold && !hasLifetimeAccess) {
      if (__DEV__) console.log('ðŸ“Š Analytics: waiting for subscription info...', { revenueCatUserId: !!revenueCatUserId, hasGold, hasLifetimeAccess });
      return;
    }

    // Fetch portfolio intelligence if not already loaded
    if (!portfolioIntel && supabaseUser) fetchPortfolioIntelligence();

    // Check if we already have cached data
    const cache = snapshotsCacheRef.current;
    if (cache.fetched && cache.primaryData && cache.primaryData.length > 0) {
      if (__DEV__) console.log('ðŸ“Š Analytics: using cached data');
      applyRangeFilter(analyticsRange);
      return;
    }

    // Trigger fetch - use small delay to ensure state is settled after React batch updates
    if (__DEV__) console.log('ðŸ“Š Analytics: triggering fetch...');
    const fetchTimeout = setTimeout(() => {
      fetchAnalyticsSnapshots();
    }, 100);

    // Cleanup: cancel timeout and any in-progress fetch
    return () => {
      clearTimeout(fetchTimeout);
      if (analyticsAbortRef.current) {
        analyticsAbortRef.current.abort();
      }
    };
  }, [tab, revenueCatUserId, hasGold, hasLifetimeAccess]); // revenueCatUserId still triggers re-run when it becomes available

  // Apply filter when range changes (instant, no API call)
  useEffect(() => {
    const cache = snapshotsCacheRef.current;
    if (tab === 'analytics' && cache.fetched && cache.primaryData) {
      applyRangeFilter(analyticsRange);
    }
  }, [analyticsRange]);

  // Fetch spot price history for all metals when analytics tab becomes active or ranges change
  useEffect(() => {
    if (tab === 'analytics' && (hasGold || hasLifetimeAccess)) {
      ['gold', 'silver', 'platinum', 'palladium'].forEach(metal => {
        fetchSpotPriceHistoryForMetal(metal, spotHistoryMetal[metal].range);
      });
    }
  }, [tab, hasGold, hasLifetimeAccess, spotHistoryMetal.gold.range, spotHistoryMetal.silver.range, spotHistoryMetal.platinum.range, spotHistoryMetal.palladium.range]);

  // Fetch sparkline data when Today tab loads
  useEffect(() => {
    if (tab === 'today') fetchSparklineData();
  }, [tab]);

  // Troy FAB pulse animation â€” subtle glow pulse every 5s until first tap
  useEffect(() => {
    if (fabTapped.current) return;
    const pulse = Animated.loop(
      Animated.sequence([
        Animated.timing(fabGlow, { toValue: 0.6, duration: 1500, useNativeDriver: true }),
        Animated.timing(fabGlow, { toValue: 0.4, duration: 1500, useNativeDriver: true }),
      ])
    );
    pulse.start();
    return () => pulse.stop();
  }, []);

  // ============================================
  // CLOUD BACKUP
  // ============================================

  const createBackup = async () => {
    try {
      const backup = {
        version: '1.1',
        timestamp: new Date().toISOString(),
        data: { silverItems, goldItems, platinumItems, palladiumItems }
      };

      const json = JSON.stringify(backup, null, 2);
      const filename = `stack-tracker-backup-${new Date().toISOString().split('T')[0]}.json`;
      const filepath = `${FileSystem.documentDirectory}${filename}`;

      await FileSystem.writeAsStringAsync(filepath, json);
      await Sharing.shareAsync(filepath, {
        mimeType: 'application/json',
        dialogTitle: 'Save Backup to Cloud',
        UTI: 'public.json'
      });

      Alert.alert('Backup Created', 'Save to iCloud Drive, Google Drive, or your preferred storage.');
    } catch (error) {
      Alert.alert('Error', 'Failed to create backup: ' + error.message);
    }
  };

  const restoreBackup = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: 'application/json',
        copyToCacheDirectory: true,
      });

      if (result.canceled) return;

      // Safety check for assets array
      if (!result.assets || result.assets.length === 0) {
        Alert.alert('Error', 'No file selected');
        return;
      }

      const file = result.assets[0];
      const content = await FileSystem.readAsStringAsync(file.uri);
      const backup = JSON.parse(content);

      if (!backup.data || !backup.version) {
        Alert.alert('Invalid Backup', 'This file is not a valid Stack Tracker backup.');
        return;
      }

      Alert.alert(
        'Restore Backup',
        `Replace current data with backup from ${backup.timestamp}?`,
        [
          { text: 'Cancel', style: 'cancel' },
          {
            text: 'Restore',
            onPress: async () => {
              if (backup.data.silverItems) setSilverItems(backup.data.silverItems);
              if (backup.data.goldItems) setGoldItems(backup.data.goldItems);
              if (backup.data.platinumItems) setPlatinumItems(backup.data.platinumItems);
              if (backup.data.palladiumItems) setPalladiumItems(backup.data.palladiumItems);
              Alert.alert('Success', 'Backup restored!');
            }
          }
        ]
      );
    } catch (error) {
      Alert.alert('Error', 'Failed to restore: ' + error.message);
    }
  };

  // ============================================
  // IN-APP REVIEW PROMPT
  // ============================================

  /**
   * Check if we should show the review prompt
   * Conditions:
   * - Max 3 prompts per year
   * - At least 30 days between prompts
   * - Triggered after 10th holding OR 7 days of use
   */
  const checkAndRequestReview = async (trigger = 'holdings') => {
    try {
      // Check if store review is available
      const isAvailable = await StoreReview.isAvailableAsync();
      if (!isAvailable) {
        if (__DEV__) console.log('ðŸ“± Store review not available on this device');
        return;
      }

      // Get review prompt history
      const reviewHistoryStr = await AsyncStorage.getItem('stack_review_prompts');
      const reviewHistory = reviewHistoryStr ? JSON.parse(reviewHistoryStr) : [];
      const now = Date.now();
      const oneYear = 365 * 24 * 60 * 60 * 1000;
      const thirtyDays = 30 * 24 * 60 * 60 * 1000;

      // Filter to prompts within the last year
      const promptsThisYear = reviewHistory.filter(ts => now - ts < oneYear);

      // Check if we've hit max prompts (3 per year)
      if (promptsThisYear.length >= 3) {
        if (__DEV__) console.log('ðŸ“± Max review prompts reached this year');
        return;
      }

      // Check if at least 30 days since last prompt
      const lastPrompt = promptsThisYear.length > 0 ? Math.max(...promptsThisYear) : 0;
      if (lastPrompt && now - lastPrompt < thirtyDays) {
        if (__DEV__) console.log('ðŸ“± Too soon since last review prompt');
        return;
      }

      // Check trigger conditions
      if (trigger === 'holdings') {
        const totalHoldings = silverItems.length + goldItems.length + platinumItems.length + palladiumItems.length;
        if (totalHoldings < 10) {
          return; // Not enough holdings yet
        }
        if (__DEV__) console.log(`ðŸ“± Triggering review prompt: ${totalHoldings} holdings`);
      } else if (trigger === 'days') {
        const firstOpenStr = await AsyncStorage.getItem('stack_first_open_date');
        if (!firstOpenStr) {
          // First time opening, save the date
          await AsyncStorage.setItem('stack_first_open_date', new Date().toISOString());
          return;
        }
        const firstOpen = new Date(firstOpenStr).getTime();
        const sevenDays = 7 * 24 * 60 * 60 * 1000;
        if (now - firstOpen < sevenDays) {
          return; // Not 7 days yet
        }
        if (__DEV__) console.log('ðŸ“± Triggering review prompt: 7+ days of use');
      }

      // Request the review
      await StoreReview.requestReview();

      // Save the prompt timestamp
      promptsThisYear.push(now);
      await AsyncStorage.setItem('stack_review_prompts', JSON.stringify(promptsThisYear));
      if (__DEV__) console.log('ðŸ“± Review prompt shown successfully');

    } catch (error) {
      if (__DEV__) console.error('âŒ Error with review prompt:', error.message);
    }
  };

  // Check for 7-day review trigger on app load
  useEffect(() => {
    if (dataLoaded && isAuthenticated) {
      // Small delay to not interfere with initial load
      const timer = setTimeout(() => {
        checkAndRequestReview('days');
      }, 3000);
      return () => clearTimeout(timer);
    }
  }, [dataLoaded, isAuthenticated]);

  // ============================================
  // SPOT PRICE CHANGE DISPLAY TOGGLE
  // ============================================

  const toggleSpotChangeDisplayMode = async () => {
    const newMode = spotChangeDisplayMode === 'percent' ? 'amount' : 'percent';
    setSpotChangeDisplayMode(newMode);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    try {
      await AsyncStorage.setItem('stack_spot_change_display_mode', newMode);
    } catch (error) {
      if (__DEV__) console.error('Failed to save spot change display mode:', error);
    }
  };

  // ============================================
  // API CALLS
  // ============================================

  const fetchSpotPrices = async (silent = false) => {
    if (!silent) setPriceSource('loading...');
    try {
      if (__DEV__) console.log('ðŸ“¡ Fetching spot prices from:', `${API_BASE_URL}/v1/prices`);

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);

      const response = await fetch(`${API_BASE_URL}/v1/prices`, {
        signal: controller.signal
      });
      clearTimeout(timeoutId);

      if (__DEV__) console.log('âœ… API Response Status:', response.status, response.statusText);

      const raw = await response.json();
      if (__DEV__) console.log('ðŸ“Š API Response Data:', JSON.stringify(raw).substring(0, 300));

      if (raw.prices) {
        // Transform v1 nested response: { prices: { gold: { price, change_pct }, ... } }
        const goldPrice = raw.prices.gold?.price;
        const silverPrice = raw.prices.silver?.price;
        const platinumPrice = raw.prices.platinum?.price;
        const palladiumPrice = raw.prices.palladium?.price;

        if (silverPrice && silverPrice > 10) {
          setSilverSpot(silverPrice);
          await AsyncStorage.setItem('stack_silver_spot', silverPrice.toString());
        }
        if (goldPrice && goldPrice > 1000) {
          setGoldSpot(goldPrice);
          await AsyncStorage.setItem('stack_gold_spot', goldPrice.toString());
        }
        if (platinumPrice && platinumPrice > 100) {
          setPlatinumSpot(platinumPrice);
          await AsyncStorage.setItem('stack_platinum_spot', platinumPrice.toString());
        }
        if (palladiumPrice && palladiumPrice > 100) {
          setPalladiumSpot(palladiumPrice);
          await AsyncStorage.setItem('stack_palladium_spot', palladiumPrice.toString());
        }
        setPriceSource(raw.source || 'live');
        setPriceTimestamp(raw.timestamp || new Date().toISOString());
        setSpotPricesLive(true);
        await AsyncStorage.setItem('stack_price_timestamp', raw.timestamp || new Date().toISOString());

        // Compute daily change data from change_pct
        const computeChange = (metalData) => {
          if (!metalData) return { amount: null, percent: null, prevClose: null };
          const pct = metalData.change_pct || 0;
          const price = metalData.price || 0;
          const prevClose = pct !== 0 ? price / (1 + pct / 100) : price;
          return { amount: price - prevClose, percent: pct, prevClose };
        };

        setSpotChange({
          gold: computeChange(raw.prices.gold),
          silver: computeChange(raw.prices.silver),
          platinum: computeChange(raw.prices.platinum),
          palladium: computeChange(raw.prices.palladium),
        });
        if (__DEV__) console.log('ðŸ“ˆ Change data computed from change_pct');

        // Capture markets closed status (client-side fallback since v1 doesn't send marketsClosed)
        const clientClosed = isMarketClosedClientSide();
        setMarketsClosed(clientClosed);
        if (clientClosed) {
          if (__DEV__) console.log(`ðŸ”’ Markets closed â€” client: ${clientClosed}`);
        }

        if (__DEV__) console.log(`ðŸ’° Prices updated: Gold $${goldPrice}, Silver $${silverPrice} (Source: ${raw.source})`);
      } else {
        if (__DEV__) console.log('âš ï¸  API returned no prices data');
        setPriceSource('cached');
      }
    } catch (error) {
      if (error.name === 'AbortError') {
        if (__DEV__) console.log('â±ï¸ Spot prices fetch aborted (timeout or unmount)');
        return;
      }
      if (__DEV__) console.error('âŒ Error fetching spot prices:', error.message);
      if (__DEV__) console.error('   Error details:', error);
      setPriceSource('cached');
    }
  };

  // Pull-to-refresh handler for dashboard
  const onRefreshDashboard = async () => {
    setIsRefreshing(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    // Fetch spot prices and sync holdings in parallel
    const promises = [fetchSpotPrices()];

    // Also sync holdings if user is signed in
    if (supabaseUser) {
      promises.push(syncHoldingsWithSupabase(true)); // force=true to re-sync
    }

    await Promise.all(promises);
    setIsRefreshing(false);
  };

  const onRefreshAnalytics = async () => {
    setIsRefreshing(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    // Clear cache and force refresh
    snapshotsCacheRef.current = { primaryData: null, fetched: false };
    await Promise.all([
      fetchAnalyticsSnapshots(true),
      fetchPortfolioIntelligence(),
    ]);
    setIsRefreshing(false);
  };

  // ============================================
  // TODAY TAB - INTELLIGENCE FEED
  // ============================================

  const fetchDailyBrief = async () => {
    if (!supabaseUser) {
      if (__DEV__) console.log(`ðŸ“° [Brief] Skipped: supabaseUser=${!!supabaseUser}`);
      return;
    }
    try {
      setDailyBriefLoading(true);
      // Use EST date to match backend
      const todayEST = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
      const url = `${API_BASE_URL}/v1/daily-brief?userId=${supabaseUser.id}&date=${todayEST}`;
      if (__DEV__) console.log(`ðŸ“° [Brief] Fetching: ${url}`);
      const response = await fetch(url);
      if (__DEV__) console.log(`ðŸ“° [Brief] HTTP ${response.status}`);
      const data = await response.json();
      if (__DEV__) console.log(`ðŸ“° [Brief] Response:`, JSON.stringify(data).slice(0, 200));
      if (data.brief) {
        setDailyBrief(data.brief);
      } else {
        if (__DEV__) console.log(`ðŸ“° [Brief] No brief returned (brief=${!!data.brief}, error=${data.error})`);
        setDailyBrief(null);
      }
    } catch (error) {
      if (__DEV__) console.error('ðŸ“° [Brief] Fetch error:', error.message);
    } finally {
      setDailyBriefLoading(false);
    }
  };

  const fetchPortfolioIntelligence = async () => {
    if (!supabaseUser) return;
    try {
      setPortfolioIntelLoading(true);
      const response = await fetch(`${API_BASE_URL}/v1/portfolio-intelligence?userId=${supabaseUser.id}`);
      const data = await response.json();
      if (__DEV__) console.log('ðŸ§  [Portfolio Intel] Response:', JSON.stringify(data).slice(0, 300));

      // Helper: extract the first string value from an object (any key)
      const extractString = (obj) => {
        if (!obj || typeof obj !== 'object') return null;
        for (const val of Object.values(obj)) {
          if (typeof val === 'string' && val.length > 20) return val;
        }
        return null;
      };

      // v1 returns intelligence.text as a JSON string like {"portfolio":"actual text..."}
      // The JSON may be truncated/malformed. Extract the text content robustly.
      let text = null;
      const intel = data.intelligence || data;

      // Helper: strip JSON wrapper from a string like {"key":"value..."} â†’ value...
      const stripJsonWrapper = (str) => {
        if (!str || typeof str !== 'string') return str;
        // If it starts with { it's likely a JSON wrapper â€” extract the first string value
        if (str.trimStart().startsWith('{')) {
          const match = str.match(/:\s*"([\s\S]+)/);
          if (match) {
            // Remove trailing ", } and whitespace
            return match[1].replace(/"\s*\}?\s*$/, '').replace(/\\n/g, '\n').replace(/\\"/g, '"');
          }
        }
        return str;
      };

      if (typeof intel === 'string' && intel.length > 20) {
        text = stripJsonWrapper(intel);
      } else if (intel && typeof intel === 'object') {
        if (typeof intel.text === 'string' && intel.text.length > 20) {
          // Try JSON.parse first for well-formed JSON
          try {
            const parsed = JSON.parse(intel.text);
            text = extractString(parsed);
          } catch {
            // JSON is malformed/truncated â€” strip the wrapper with regex
          }
          if (!text) text = stripJsonWrapper(intel.text);
        } else if (typeof intel.text === 'object' && intel.text) {
          text = extractString(intel.text);
        }
        if (!text) text = extractString(intel);
      }

      if (text) {
        setPortfolioIntel({
          text,
          costBasis: intel?.costBasis || intel?.cost_basis || null,
          purchaseStats: intel?.purchaseStats || intel?.purchase_stats || null,
          date: intel?.date || new Date().toISOString().split('T')[0],
          is_current: intel?.is_current ?? true,
        });
      } else {
        setPortfolioIntel(null);
      }
    } catch (error) {
      if (__DEV__) console.error('ðŸ§  [Portfolio Intel] Fetch error:', error.message);
    } finally {
      setPortfolioIntelLoading(false);
    }
  };

  const fetchIntelligenceBriefs = async () => {
    try {
      setIntelligenceLoading(true);
      const today = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
      const response = await fetch(`${API_BASE_URL}/v1/market-intel?date=${today}`);
      const raw = await response.json();
      // Transform v1 articles â†’ briefs format
      const severityToScore = { high: 9, medium: 5, info: 2, low: 1 };
      if (raw.articles && raw.articles.length > 0) {
        const briefs = raw.articles.map(a => ({
          id: a.id,
          date: a.published_at?.split('T')[0] || today,
          category: a.category || 'general',
          title: a.title,
          summary: a.summary,
          source: a.source || '',
          source_url: a.source_url || '',
          relevance_score: severityToScore[a.severity] || 5,
          created_at: a.published_at || '',
        }));
        // Filter out test/placeholder briefs
        const filtered = briefs.filter(b =>
          !b.title?.toLowerCase().includes('test alert') &&
          !b.summary?.toLowerCase().includes('this is a test')
        );
        setIntelligenceBriefs(filtered);
      }
      setIntelligenceLastFetched(new Date());
    } catch (error) {
      if (__DEV__) console.error('Intelligence fetch error:', error);
    } finally {
      setIntelligenceLoading(false);
    }
  };

  // Fetch vault data (COMEX warehouse inventory) â€” v1 returns per-metal snapshots
  const fetchVaultData = async () => {
    try {
      setVaultLoading(true);
      const metals = ['gold', 'silver', 'platinum', 'palladium'];
      // Fetch both latest snapshot and 30-day history for each metal
      const [latestResults, historyResults] = await Promise.all([
        Promise.all(metals.map(async (metal) => {
          try {
            const res = await fetch(`${API_BASE_URL}/v1/vault-watch?metal=${metal}`);
            if (!res.ok) return null;
            return res.json();
          } catch { return null; }
        })),
        Promise.all(metals.map(async (metal) => {
          try {
            const res = await fetch(`${API_BASE_URL}/v1/vault-watch?metal=${metal}&days=30`);
            if (!res.ok) return null;
            return res.json();
          } catch { return null; }
        })),
      ]);
      const data = {};
      for (let i = 0; i < metals.length; i++) {
        const latest = latestResults[i];
        const histRaw = historyResults[i];
        const historyArr = (histRaw?.data?.[metals[i]] || histRaw?.history || []).map(h => ({
          date: h.date,
          registered_oz: h.registered_oz || 0,
          eligible_oz: h.eligible_oz || 0,
          combined_oz: h.combined_oz || 0,
          registered_change_oz: h.registered_change_oz || 0,
          eligible_change_oz: h.eligible_change_oz || 0,
          oversubscribed_ratio: h.oversubscribed_ratio || 0,
        }));
        // Append latest if not already in history
        if (latest) {
          const latestDate = latest.date || new Date().toISOString().split('T')[0];
          const latestEntry = {
            date: latestDate,
            registered_oz: latest.registered_oz || 0,
            eligible_oz: latest.eligible_oz || 0,
            combined_oz: latest.combined_oz || 0,
            registered_change_oz: latest.registered_change_oz || 0,
            eligible_change_oz: latest.eligible_change_oz || 0,
            oversubscribed_ratio: latest.oversubscribed_ratio || 0,
          };
          if (!historyArr.some(h => h.date === latestDate)) {
            historyArr.push(latestEntry);
          }
        }
        // Sort by date ascending
        historyArr.sort((a, b) => a.date.localeCompare(b.date));
        data[metals[i]] = historyArr.length > 0 ? historyArr : (latest ? [{
          date: latest.date || new Date().toISOString().split('T')[0],
          registered_oz: latest.registered_oz || 0,
          eligible_oz: latest.eligible_oz || 0,
          combined_oz: latest.combined_oz || 0,
          registered_change_oz: latest.registered_change_oz || 0,
          eligible_change_oz: latest.eligible_change_oz || 0,
          oversubscribed_ratio: latest.oversubscribed_ratio || 0,
        }] : []);
      }
      setVaultData(data);
      setVaultLastFetched(new Date());
    } catch (error) {
      if (__DEV__) console.error('Vault data fetch error:', error);
    } finally {
      setVaultLoading(false);
    }
  };

  // Fetch intelligence + vault data when switching to Today tab
  useEffect(() => {
    if (tab === 'today') {
      if (!intelligenceLastFetched) fetchIntelligenceBriefs();
      if (!vaultLastFetched) fetchVaultData();
    }
  }, [tab]);

  // Fetch daily brief when tab or user changes
  useEffect(() => {
    if (tab === 'today' && supabaseUser && (!dailyBrief || !dailyBrief.is_current)) {
      fetchDailyBrief();
    }
  }, [tab, supabaseUser]);

  const onRefreshToday = async () => {
    setIsRefreshing(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    await Promise.all([
      fetchIntelligenceBriefs(),
      fetchVaultData(),
      fetchSpotPrices(true),
      fetchDailyBrief(),
    ]);
    setIsRefreshing(false);
  };

  /**
   * Fetch historical spot price for a given date
   *
   * The API returns a three-tier response:
   * - Pre-2006: Monthly averages (granularity: 'monthly')
   * - 2006+: ETF-derived daily prices (granularity: 'daily' or 'estimated_intraday')
   * - Recent: Minute-level from our database (granularity: 'minute')
   *
   * @param {string} date - Date in YYYY-MM-DD format
   * @param {string} metal - 'gold' or 'silver'
   * @param {string} time - Optional time in HH:MM format for intraday estimation
   * @returns {Object} { price, source, granularity, dailyRange, note }
   */
  const fetchHistoricalSpot = async (date, metal, time = null) => {
    if (!date || date.length < 10) return { price: null, source: null };
    try {
      let url = `${API_BASE_URL}/v1/historical-spot?date=${date}`;
      if (metal) url += `&metal=${metal}`;
      if (time) url += `&time=${time}`;

      if (__DEV__) console.log(`ðŸ“… Fetching historical spot: ${url}`);
      const response = await fetch(url);
      const data = await response.json();

      if (__DEV__) {
        if (__DEV__) console.log('ðŸ“… Historical spot API response:', JSON.stringify(data, null, 2));

        // Log granularity-based warnings
        if (data.granularity === 'monthly' || data.granularity === 'monthly_fallback') {
          if (__DEV__) console.log('âš ï¸ Using monthly average (pre-2006 or fallback)');
        } else if (data.granularity === 'estimated_intraday') {
          if (__DEV__) console.log('ðŸ“Š Using time-weighted intraday estimate');
        } else if (data.granularity === 'minute') {
          if (__DEV__) console.log('âœ… Using exact minute-level price from our records');
        }

        if (data.note) {
          if (__DEV__) console.log(`ðŸ“ Note: ${data.note}`);
        }
      }

      if (data.success) {
        // Get the price for the requested metal (or default to the response format)
        const metalKey = metal || metalTab;
        const price = data.price || data[metalKey];

        return {
          price: price,
          source: data.source,
          granularity: data.granularity,
          dailyRange: data.dailyRange ? data.dailyRange[metalKey] : null,
          note: data.note,
          // Also return full response for all metals if needed
          gold: data.gold,
          silver: data.silver,
          platinum: data.platinum,
          palladium: data.palladium,
        };
      }
    } catch (error) {
      if (__DEV__) console.log('âŒ Could not fetch historical spot:', error.message);
    }
    // No historical data available - return null instead of current spot
    // to prevent contaminating saved spotPrice with today's price
    return {
      price: null,
      source: 'unavailable',
      granularity: null
    };
  };

  const handleDateChange = async (date) => {
    setForm(prev => ({ ...prev, datePurchased: date }));
    setSpotPriceSource(null);
    setHistoricalSpotSuggestion(null);

    if (date.length === 10) {
      const result = await fetchHistoricalSpot(date, metalTab, form.timePurchased || null);
      if (result.price) {
        setHistoricalSpotSuggestion({ price: result.price, source: result.source, date });
        setForm(prev => ({ ...prev, spotPrice: result.price.toString() }));
        setSpotPriceSource(result.source);
      }
    }
  };

  // Handle time change - refetch historical spot with time for minute-level precision
  const handleTimeChange = async (time) => {
    setForm(prev => ({ ...prev, timePurchased: time }));

    const timeValid = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/.test(time);
    const hasDate = form.datePurchased && form.datePurchased.length === 10;

    if (timeValid && hasDate) {
      setSpotPriceSource(null);
      setHistoricalSpotSuggestion(null);

      const result = await fetchHistoricalSpot(form.datePurchased, metalTab, time);
      if (result.price) {
        setHistoricalSpotSuggestion({ price: result.price, source: result.source, date: form.datePurchased });
        setForm(prev => ({ ...prev, spotPrice: result.price.toString() }));
        setSpotPriceSource(result.source);
      }
    }
  };

  // Handle metal tab change â€” auto-update spot price for the new metal
  const handleMetalTabChange = async (newMetal) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setMetalTab(newMetal);

    // Map metal keys to current live spot prices
    const liveSpots = { gold: goldSpot, silver: silverSpot, platinum: platinumSpot, palladium: palladiumSpot };

    if (form.datePurchased && form.datePurchased.length === 10) {
      // Date is set â€” fetch historical spot for the new metal
      setSpotPriceSource(null);
      setHistoricalSpotSuggestion(null);
      const result = await fetchHistoricalSpot(form.datePurchased, newMetal, form.timePurchased || null);
      if (result.price) {
        setForm(prev => ({ ...prev, spotPrice: result.price.toString() }));
        setSpotPriceSource(result.source);
        setHistoricalSpotSuggestion({ price: result.price, source: result.source, date: form.datePurchased });
      } else {
        // Fallback to current live spot
        setForm(prev => ({ ...prev, spotPrice: String(liveSpots[newMetal] || 0) }));
        setSpotPriceSource('current-fallback');
      }
    } else {
      // No date â€” use current live spot price for the new metal
      setForm(prev => ({ ...prev, spotPrice: String(liveSpots[newMetal] || 0) }));
      setSpotPriceSource('current-spot');
    }
  };

  // ============================================
  // RECEIPT SCANNING
  // ============================================

  // Show scanning tips before opening picker
  const showScanningTips = (source) => {
    const tips = source === 'camera'
      ? "For best results:\n\nâ€¢ Lay paper receipt flat with good lighting\nâ€¢ Avoid shadows and glare\nâ€¢ Include all line items in frame"
      : "For best results:\n\nâ€¢ Use screenshots from dealer apps or emails\nâ€¢ For paper receipts: lay flat with good lighting\nâ€¢ Select multiple images for long receipts";

    Alert.alert(
      'ðŸ“· Scanning Tips',
      tips,
      [
        { text: 'Cancel', style: 'cancel' },
        { text: 'Continue', onPress: () => performScan(source) }
      ]
    );
  };

  // Process a single image and return items
  const processImage = async (asset, imageIndex, totalImages) => {
    if (__DEV__) console.log(`ðŸ“· Processing image ${imageIndex + 1}/${totalImages}`);
    if (__DEV__) console.log(`   URI: ${asset.uri}`);
    if (__DEV__) console.log(`   Width: ${asset.width}px, Height: ${asset.height}px`);

    // Read file as base64
    const fileInfo = await FileSystem.getInfoAsync(asset.uri, { size: true });
    const fullBase64 = await FileSystem.readAsStringAsync(asset.uri, {
      encoding: FileSystem.EncodingType.Base64
    });

    if (__DEV__) console.log(`   File size: ${fileInfo.size ? (fileInfo.size / 1024).toFixed(2) + ' KB' : 'unknown'}`);
    if (__DEV__) console.log(`   Base64 length: ${fullBase64.length} characters`);

    const mimeType = asset.mimeType || asset.type || 'image/jpeg';

    const response = await fetch(`${API_BASE_URL}/v1/scan-receipt`, {
      method: 'POST',
      body: JSON.stringify({
        image: fullBase64,
        mimeType: mimeType,
        originalSize: fileInfo.size
      }),
      headers: { 'Content-Type': 'application/json' },
    });

    const data = await response.json();
    return data;
  };

  // Perform the actual scan after tips
  const performScan = async (source) => {
    // Check scan limit first
    if (!checkScanLimit()) return;

    let result;

    if (source === 'camera') {
      const permissionResult = await ImagePicker.requestCameraPermissionsAsync();
      if (!permissionResult.granted) {
        Alert.alert('Permission Required', 'Please allow access to your camera to take photos of receipts.');
        return;
      }
      result = await ImagePicker.launchCameraAsync({ mediaTypes: ['images'], quality: 1.0 });
    } else {
      const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (!permissionResult.granted) {
        Alert.alert('Permission Required', 'Please allow access to your photos.');
        return;
      }
      // Allow multiple selection for gallery (up to 5 images)
      result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ['images'],
        quality: 1.0,
        allowsMultipleSelection: true,
        selectionLimit: 5
      });
    }

    if (result.canceled) return;

    if (!result.assets || result.assets.length === 0) {
      Alert.alert('Error', 'No image selected');
      return;
    }

    const totalImages = result.assets.length;
    setScanStatus('scanning');
    setScanMessage(`Analyzing ${totalImages} image${totalImages > 1 ? 's' : ''}...`);

    try {
      // Process all images and combine results
      let allItems = [];
      let dealer = '';
      let purchaseDate = '';
      let purchaseTime = '';
      let successCount = 0;

      for (let i = 0; i < result.assets.length; i++) {
        const asset = result.assets[i];
        setScanMessage(`Analyzing image ${i + 1} of ${totalImages}...`);

        try {
          const data = await processImage(asset, i, totalImages);

          if (data.success && data.items && data.items.length > 0) {
            allItems = [...allItems, ...data.items];
            // Use first found dealer/date/time
            if (!dealer && data.dealer) dealer = data.dealer;
            if (!purchaseDate && data.purchaseDate) purchaseDate = parseDate(data.purchaseDate);
            if (!purchaseTime && data.purchaseTime) purchaseTime = data.purchaseTime;
            successCount++;
            if (__DEV__) console.log(`âœ… Image ${i + 1}: Found ${data.items.length} items`);
          } else {
            if (__DEV__) console.log(`âš ï¸ Image ${i + 1}: No items found`);
          }
        } catch (imgError) {
          if (__DEV__) console.error(`âŒ Image ${i + 1} failed:`, imgError.message);
        }
      }

      // Only increment scan count once for the batch
      if (allItems.length > 0) {
        await incrementScanCount();
      }

      // Deduplicate items (same description, quantity, and unit price)
      const uniqueItems = [];
      const seen = new Set();
      for (const item of allItems) {
        const key = `${item.description}|${item.quantity}|${item.unitPrice}`;
        if (!seen.has(key)) {
          seen.add(key);
          uniqueItems.push(item);
        }
      }
      const duplicatesRemoved = allItems.length - uniqueItems.length;
      if (duplicatesRemoved > 0 && __DEV__) {
        if (__DEV__) console.log(`ðŸ”„ Removed ${duplicatesRemoved} duplicate item(s)`);
      }

      const data = { success: uniqueItems.length > 0, items: uniqueItems, dealer, purchaseDate, purchaseTime };
      if (__DEV__) console.log(`ðŸ“„ Combined results: ${uniqueItems.length} unique items from ${successCount}/${totalImages} images`);

      // Handle multi-item receipt response
      if (data.success && data.items && data.items.length > 0) {
        const items = data.items;

        if (__DEV__) console.log(`âœ… Found ${items.length} item(s) on receipt`);

        // Count items by metal type
        const silverCount = items.filter(item => item.metal === 'silver').length;
        const goldCount = items.filter(item => item.metal === 'gold').length;
        const otherCount = items.length - silverCount - goldCount;

        // Build summary message
        let summary = `Found ${items.length} item${items.length > 1 ? 's' : ''}`;
        if (silverCount > 0 || goldCount > 0) {
          const parts = [];
          if (silverCount > 0) parts.push(`${silverCount} Silver`);
          if (goldCount > 0) parts.push(`${goldCount} Gold`);
          if (otherCount > 0) parts.push(`${otherCount} Other`);
          summary += `: ${parts.join(', ')}`;
        }

        // Process ALL items and prepare them for preview
        const processedItems = [];
        for (const item of items) {
          const extractedMetal = item.metal === 'gold' ? 'gold' : 'silver';

          // Get historical spot price for this item (with time if available)
          let spotPrice = '';
          if (purchaseDate.length === 10) {
            const result = await fetchHistoricalSpot(purchaseDate, extractedMetal, purchaseTime || null);
            if (result.price) spotPrice = result.price.toString();
          }

          let unitPrice = parseFloat(item.unitPrice) || 0;
          const ozt = parseFloat(item.ozt) || 0;
          const spotNum = parseFloat(spotPrice) || 0;
          const qty = parseInt(item.quantity) || 1;
          const extPrice = item.extPrice ? parseFloat(item.extPrice) : unitPrice * qty;

          // Spot price sanity check - precious metals almost never sell below spot
          let priceWarning = null;
          if (spotNum > 0 && ozt > 0) {
            const minExpectedPrice = spotNum * ozt;

            if (unitPrice < minExpectedPrice) {
              // Price is suspiciously low - try recalculating from ext price
              if (__DEV__) console.log(`âš ï¸ Price sanity check: $${unitPrice} < spot value $${minExpectedPrice.toFixed(2)}`);

              if (extPrice > 0 && qty > 0) {
                const recalculatedPrice = Math.round((extPrice / qty) * 100) / 100;
                if (__DEV__) console.log(`   Trying extPrice/qty: $${extPrice} / ${qty} = $${recalculatedPrice}`);

                if (recalculatedPrice >= minExpectedPrice) {
                  // Recalculated price makes sense, use it
                  if (__DEV__) console.log(`   âœ“ Using recalculated price: $${recalculatedPrice}`);
                  unitPrice = recalculatedPrice;
                } else {
                  // Still below spot - flag for manual review
                  priceWarning = `Price $${unitPrice.toFixed(2)} is below spot value ($${minExpectedPrice.toFixed(2)}) - please verify`;
                  if (__DEV__) console.log(`   âš ï¸ Still below spot, adding warning`);
                }
              } else {
                // No ext price to verify with - flag for manual review
                priceWarning = `Price $${unitPrice.toFixed(2)} is below spot value ($${minExpectedPrice.toFixed(2)}) - please verify`;
                if (__DEV__) console.log(`   âš ï¸ No ext price to verify, adding warning`);
              }
            }
          }

          let premium = '0';
          if (unitPrice > 0 && spotNum > 0 && ozt > 0) {
            premium = (unitPrice - (spotNum * ozt)).toFixed(2);
          }

          processedItems.push({
            metal: extractedMetal,
            productName: item.description || '',
            source: dealer,
            datePurchased: purchaseDate,
            timePurchased: purchaseTime || undefined,
            ozt: parseFloat(item.ozt) || 0,
            quantity: qty,
            unitPrice: unitPrice,
            extPrice: extPrice,
            taxes: 0,
            shipping: 0,
            spotPrice: parseFloat(spotPrice) || 0,
            premium: parseFloat(premium) || 0,
            priceWarning: priceWarning,
          });
        }

        // Store scanned items and metadata
        setScannedItems(processedItems);
        setScannedMetadata({ purchaseDate, purchaseTime, dealer });

        // Show success message with haptic feedback
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
        setScanStatus('success');
        setScanMessage(summary);

        // Close the add modal and show preview modal
        setShowAddModal(false);
        setShowScannedItemsPreview(true);

        if (__DEV__) console.log(`âœ… Processed ${processedItems.length} items for preview`);
      } else {
        if (__DEV__) console.log('âš ï¸ Server returned success=false or no items found');
        setScanStatus('error');
        setScanMessage("Couldn't read receipt. This scan didn't count against your limit.");
      }
    } catch (error) {
      if (__DEV__) console.error('âŒ Scan receipt error:', error);
      if (__DEV__) console.error('Error message:', error.message);
      if (__DEV__) console.error('Error stack:', error.stack);
      setScanStatus('error');
      setScanMessage("Scan failed. This didn't count against your limit.");
    }

    setTimeout(() => { setScanStatus(null); setScanMessage(''); }, 5000);
  };

  // ============================================
  // SPREADSHEET IMPORT (with Dealer Templates)
  // ============================================

  const importSpreadsheet = async () => {
    // Check scan limit first
    if (!checkScanLimit()) return;

    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ['text/csv', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],
        copyToCacheDirectory: true,
      });

      if (result.canceled) return;

      // Safety check for assets array
      if (!result.assets || result.assets.length === 0) {
        Alert.alert('Error', 'No file selected');
        setScanStatus(null);
        return;
      }

      const file = result.assets[0];
      if (__DEV__) console.log('ðŸ“Š Spreadsheet selected:', file.name);

      // Read file content
      const fileContent = await FileSystem.readAsStringAsync(file.uri, {
        encoding: FileSystem.EncodingType.Base64,
      });

      // Convert base64 to binary
      const binaryString = atob(fileContent);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }

      // Parse with XLSX - use raw:true to prevent date conversion to serial numbers
      const workbook = XLSX.read(bytes, { type: 'array', cellDates: true, raw: false });
      const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(firstSheet, { header: 1, raw: false, dateNF: 'yyyy-mm-dd' });

      if (rows.length < 2) {
        Alert.alert('Invalid Spreadsheet', "Spreadsheet must have at least a header row and one data row. This didn't count against your scan limit.");
        return;
      }

      // Get headers for detection
      const headers = rows[0].map(h => String(h || '').toLowerCase().trim());

      // Try to auto-detect format from headers and filename
      const detectedDealer = detectDealerFromHeaders(headers, file.name);

      if (detectedDealer) {
        // Auto-detected format - process immediately
        if (__DEV__) console.log(`ðŸª Auto-detected format: ${DEALER_TEMPLATES[detectedDealer].name}`);
        await processSpreadsheetWithDealer(rows, headers, detectedDealer);
      } else {
        // Unrecognized format - show dealer selector
        setPendingImportFile({ rows, headers, fileName: file.name });
        setShowDealerSelector(true);
      }

    } catch (error) {
      if (__DEV__) console.error('âŒ Import error:', error);
      Alert.alert('Import Failed', `Could not import spreadsheet. This didn't count against your scan limit.\n\n${error.message}`);
    }
  };

  // Process spreadsheet with selected dealer template
  const processSpreadsheetWithDealer = async (rows, headers, dealerKey) => {
    try {
      const template = DEALER_TEMPLATES[dealerKey];
      if (__DEV__) console.log(`ðŸ“Š Processing with template: ${template.name}`);

      // Build column finder for this template
      const findColumn = (possibleNames) => {
        if (!possibleNames) return -1;
        for (const name of possibleNames) {
          const index = headers.findIndex(h => h.includes(name.toLowerCase()));
          if (index !== -1) return index;
        }
        return -1;
      };

      // Map columns based on template
      const colMap = {
        productName: findColumn(template.columnMap.product),
        metal: findColumn(template.columnMap.metal || []),
        quantity: findColumn(template.columnMap.quantity),
        unitPrice: findColumn(template.columnMap.unitPrice),
        date: findColumn(template.columnMap.date),
        time: findColumn(template.columnMap.time || []),
        dealer: findColumn(template.columnMap.dealer || []),
        ozt: findColumn(template.columnMap.ozt || []),
        taxes: findColumn(template.columnMap.taxes || []),
        shipping: findColumn(template.columnMap.shipping || []),
        spotPrice: findColumn(template.columnMap.spotPrice || []),
        premium: findColumn(template.columnMap.premium || []),
      };

      // For dealer-specific templates, also check generic column names as fallback
      if (dealerKey !== 'generic' && dealerKey !== 'stacktracker') {
        const genericTemplate = DEALER_TEMPLATES['generic'];
        if (colMap.productName === -1) colMap.productName = findColumn(genericTemplate.columnMap.product);
        if (colMap.metal === -1) colMap.metal = findColumn(genericTemplate.columnMap.metal);
        if (colMap.quantity === -1) colMap.quantity = findColumn(genericTemplate.columnMap.quantity);
        if (colMap.unitPrice === -1) colMap.unitPrice = findColumn(genericTemplate.columnMap.unitPrice);
        if (colMap.date === -1) colMap.date = findColumn(genericTemplate.columnMap.date);
        if (colMap.ozt === -1) colMap.ozt = findColumn(genericTemplate.columnMap.ozt);
      }

      // Check if we have at least a product name column
      if (colMap.productName === -1) {
        Alert.alert(
          'Missing Columns',
          `Couldn't find a product name column in this ${template.name} export. This didn't count against your scan limit.\n\nExpected columns: ${template.columnMap.product?.join(', ')}`
        );
        return;
      }

      // Parse data rows
      const parsedData = [];
      let skippedCount = 0;

      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        if (!row || row.length === 0) continue;

        const productName = String(row[colMap.productName] || '').trim();
        if (!productName) continue;

        // Get metal from column or auto-detect from product name
        let metal = null;
        if (colMap.metal !== -1) {
          const metalRaw = String(row[colMap.metal] || '').toLowerCase().trim();
          metal = metalRaw.includes('gold') ? 'gold'
            : metalRaw.includes('silver') ? 'silver'
            : metalRaw.includes('platinum') ? 'platinum'
            : metalRaw.includes('palladium') ? 'palladium'
            : null;
        }
        if (!metal) {
          metal = detectMetalFromName(productName);
        }

        // Skip if we still can't determine the metal
        if (!metal) {
          if (__DEV__) console.log(`â­ï¸ Skipping (no metal detected): ${productName}`);
          skippedCount++;
          continue;
        }

        // Get OZT from column or auto-detect from product name
        let ozt = colMap.ozt !== -1 ? parseFloat(row[colMap.ozt]) : null;
        if (!ozt || ozt <= 0) {
          ozt = detectOztFromName(productName);
        }
        if (!ozt || ozt <= 0) {
          ozt = 1; // Default to 1 oz if can't detect
        }

        // Get dealer from column or use template's auto-dealer
        let source = '';
        if (colMap.dealer !== -1 && row[colMap.dealer]) {
          source = String(row[colMap.dealer]);
        } else if (template.autoDealer) {
          source = template.autoDealer;
        }

        // Parse other fields
        const quantity = colMap.quantity !== -1 ? (parseInt(row[colMap.quantity]) || 1) : 1;
        const unitPrice = colMap.unitPrice !== -1 ? (parseFloat(row[colMap.unitPrice]) || 0) : 0;
        const dateRaw = colMap.date !== -1 ? row[colMap.date] : null;
        const datePurchased = dateRaw ? parseDate(String(dateRaw)) : '';
        const timeRaw = colMap.time !== -1 ? row[colMap.time] : null;
        const timePurchased = timeRaw ? String(timeRaw).trim() : '';

        // Parse optional extra fields (Stack Tracker export has these)
        const taxes = colMap.taxes !== -1 ? (parseFloat(row[colMap.taxes]) || 0) : 0;
        const shipping = colMap.shipping !== -1 ? (parseFloat(row[colMap.shipping]) || 0) : 0;
        const spotPrice = colMap.spotPrice !== -1 ? (parseFloat(row[colMap.spotPrice]) || 0) : 0;
        const premium = colMap.premium !== -1 ? (parseFloat(row[colMap.premium]) || 0) : 0;

        parsedData.push({
          productName,
          metal,
          quantity,
          unitPrice,
          datePurchased,
          timePurchased,
          source,
          ozt,
          taxes,
          shipping,
          spotPrice,
          premium,
          autoDetected: {
            metal: colMap.metal === -1 || !row[colMap.metal],
            ozt: colMap.ozt === -1 || !row[colMap.ozt] || parseFloat(row[colMap.ozt]) <= 0,
          },
        });
      }

      if (parsedData.length === 0) {
        Alert.alert(
          'No Data Found',
          `No valid items found in spreadsheet.${skippedCount > 0 ? ` ${skippedCount} items skipped (couldn't detect metal type).` : ''}\n\nThis didn't count against your scan limit.`
        );
        return;
      }

      // Deduplicate within the CSV (same product name, quantity, unit price, date)
      const uniqueParsedData = [];
      const seenItems = new Set();
      let duplicatesInFile = 0;
      for (const item of parsedData) {
        const key = `${item.productName}|${item.quantity}|${item.unitPrice}|${item.datePurchased}`;
        if (!seenItems.has(key)) {
          seenItems.add(key);
          uniqueParsedData.push(item);
        } else {
          duplicatesInFile++;
        }
      }
      if (duplicatesInFile > 0 && __DEV__) {
        if (__DEV__) console.log(`ðŸ”„ Removed ${duplicatesInFile} duplicate rows from CSV`);
      }

      // Only increment scan count on successful parsing
      await incrementScanCount();

      // Clear pending file and dealer selector
      setPendingImportFile(null);
      setShowDealerSelector(false);
      setSelectedDealer(null);

      // Show preview
      setImportData(uniqueParsedData);
      setShowImportPreview(true);

      const message = skippedCount > 0
        ? `ðŸ“Š Parsed ${uniqueParsedData.length} items from ${template.name} (${skippedCount} skipped${duplicatesInFile > 0 ? `, ${duplicatesInFile} duplicates removed` : ''})`
        : `ðŸ“Š Parsed ${uniqueParsedData.length} items from ${template.name}${duplicatesInFile > 0 ? ` (${duplicatesInFile} duplicates removed)` : ''}`;
      if (__DEV__) console.log(message);

    } catch (error) {
      if (__DEV__) console.error('âŒ Process spreadsheet error:', error);
      Alert.alert('Import Failed', `Could not process spreadsheet. This didn't count against your scan limit.\n\n${error.message}`);
    }
  };

  // Handle dealer selection from modal
  const handleDealerSelected = async (dealerKey) => {
    if (!pendingImportFile) return;
    await processSpreadsheetWithDealer(pendingImportFile.rows, pendingImportFile.headers, dealerKey);
  };

  const confirmImport = () => {
    try {
      let silverCount = 0;
      let goldCount = 0;
      let skippedDuplicates = 0;
      const newItems = [];

      // Build a set of existing items for duplicate detection
      const existingKeys = new Set();
      silverItems.forEach(item => {
        existingKeys.add(`silver|${item.productName}|${item.quantity}|${item.unitPrice}|${item.datePurchased || ''}`);
      });
      goldItems.forEach(item => {
        existingKeys.add(`gold|${item.productName}|${item.quantity}|${item.unitPrice}|${item.datePurchased || ''}`);
      });

      importData.forEach((item, index) => {
        // Check for duplicate against existing holdings
        const itemKey = `${item.metal}|${item.productName}|${item.quantity}|${item.unitPrice}|${item.datePurchased || ''}`;
        if (existingKeys.has(itemKey)) {
          skippedDuplicates++;
          if (__DEV__) console.log(`â­ï¸ Skipping duplicate: ${item.productName}`);
          return; // Skip this item
        }
        existingKeys.add(itemKey); // Prevent duplicates within the same import batch

        const newItem = {
          id: Date.now() + index,
          productName: item.productName,
          source: item.source,
          datePurchased: item.datePurchased,
          timePurchased: item.timePurchased || undefined,
          ozt: item.ozt,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          taxes: item.taxes || 0,
          shipping: item.shipping || 0,
          spotPrice: item.spotPrice || 0,
          premium: item.premium || 0,
        };

        const importSetters = { silver: setSilverItems, gold: setGoldItems, platinum: setPlatinumItems, palladium: setPalladiumItems };
        const metalKey = (item.metal || 'silver').toLowerCase();
        const setter = importSetters[metalKey] || setSilverItems;
        setter(prev => [...prev, newItem]);
        if (metalKey === 'silver') silverCount++;
        else if (metalKey === 'gold') goldCount++;
        newItems.push({ ...newItem, metal: metalKey });
      });

      // Sync to Supabase if signed in
      if (supabaseUser && newItems.length > 0) {
        (async () => {
          try {
            for (const item of newItems) {
              await addHolding(supabaseUser.id, item, item.metal);
            }
            if (__DEV__) console.log(`Synced ${newItems.length} imported items to Supabase`);
          } catch (err) {
            if (__DEV__) console.error('Failed to sync imported items to Supabase:', err);
          }
        })();
      }

      // Haptic feedback
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);

      const totalImported = newItems.length;
      const duplicateMsg = skippedDuplicates > 0 ? `\n(${skippedDuplicates} duplicate${skippedDuplicates > 1 ? 's' : ''} skipped)` : '';

      Alert.alert(
        'Import Successful',
        `Imported ${totalImported} items${duplicateMsg}`,
        [{ text: 'Great!', onPress: () => {
          setShowImportPreview(false);
          setImportData([]);
          setMetalTab('both');
        }}]
      );
    } catch (error) {
      if (__DEV__) console.error('âŒ Confirm import error:', error);
      Alert.alert('Import Failed', error.message);
    }
  };

  // Add all scanned items at once
  const confirmScannedItems = () => {
    try {
      let silverCount = 0;
      let goldCount = 0;
      const newItems = [];

      scannedItems.forEach((item, index) => {
        const newItem = {
          id: Date.now() + index,
          productName: item.productName,
          source: item.source,
          datePurchased: item.datePurchased,
          timePurchased: item.timePurchased || undefined,
          ozt: item.ozt,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          taxes: item.taxes,
          shipping: item.shipping,
          spotPrice: item.spotPrice,
          premium: item.premium,
        };

        const scanSetters = { silver: setSilverItems, gold: setGoldItems, platinum: setPlatinumItems, palladium: setPalladiumItems };
        const metalKey = (item.metal || 'silver').toLowerCase();
        const setter = scanSetters[metalKey] || setSilverItems;
        setter(prev => [...prev, newItem]);
        if (metalKey === 'silver') silverCount++;
        else if (metalKey === 'gold') goldCount++;
        newItems.push({ ...newItem, metal: metalKey });
      });

      // Sync to Supabase if signed in
      if (supabaseUser && newItems.length > 0) {
        (async () => {
          try {
            for (const item of newItems) {
              await addHolding(supabaseUser.id, item, item.metal);
            }
            if (__DEV__) console.log(`Synced ${newItems.length} scanned items to Supabase`);
          } catch (err) {
            if (__DEV__) console.error('Failed to sync scanned items to Supabase:', err);
          }
        })();
      }

      // Haptic feedback
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);

      Alert.alert(
        'Items Added Successfully',
        `Added ${scannedItems.length} item${scannedItems.length > 1 ? 's' : ''} from receipt`,
        [{ text: 'Great!', onPress: () => {
          setShowScannedItemsPreview(false);
          setScannedItems([]);
          setScannedMetadata({ purchaseDate: '', purchaseTime: '', dealer: '' });
          setMetalTab('both');
          setTab('portfolio');
        }}]
      );
    } catch (error) {
      if (__DEV__) console.error('âŒ Add scanned items error:', error);
      Alert.alert('Add Failed', error.message);
    }
  };

  // Add a single scanned item and go to next or close
  const addScannedItemIndividually = (index) => {
    const item = scannedItems[index];
    const newItem = {
      id: Date.now(),
      productName: item.productName,
      source: item.source,
      datePurchased: item.datePurchased,
      timePurchased: item.timePurchased || undefined,
      ozt: item.ozt,
      quantity: item.quantity,
      unitPrice: item.unitPrice,
      taxes: item.taxes,
      shipping: item.shipping,
      spotPrice: item.spotPrice,
      premium: item.premium,
    };

    if (item.metal === 'silver') {
      setSilverItems(prev => [...prev, newItem]);
    } else {
      setGoldItems(prev => [...prev, newItem]);
    }

    // Remove this item from scannedItems
    const remainingItems = scannedItems.filter((_, i) => i !== index);
    setScannedItems(remainingItems);

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

    // If no more items, close the modal
    if (remainingItems.length === 0) {
      Alert.alert('All Items Added', 'All scanned items have been added to your holdings!', [
        { text: 'View Holdings', onPress: () => {
          setShowScannedItemsPreview(false);
          setTab('portfolio');
        }}
      ]);
    }
  };

  // Update scanned item price inline (with auto-recalculation)
  const updateScannedItemPrice = (index, field, value) => {
    const updatedItems = [...scannedItems];
    const item = updatedItems[index];
    const numValue = parseFloat(value) || 0;
    const qty = item.quantity || 1;

    if (field === 'unitPrice') {
      // User edited unit price - recalculate ext price
      item.unitPrice = numValue;
      item.extPrice = Math.round(numValue * qty * 100) / 100;
    } else if (field === 'extPrice') {
      // User edited ext price - recalculate unit price
      item.extPrice = numValue;
      item.unitPrice = Math.round((numValue / qty) * 100) / 100;
    }

    // Recalculate premium
    if (item.unitPrice > 0 && item.spotPrice > 0 && item.ozt > 0) {
      item.premium = Math.round((item.unitPrice - (item.spotPrice * item.ozt)) * 100) / 100;

      // Clear warning if price is now valid (at or above spot value)
      const minExpectedPrice = item.spotPrice * item.ozt;
      if (item.unitPrice >= minExpectedPrice) {
        item.priceWarning = null;
      }
    }

    setScannedItems(updatedItems);
  };

  // Edit a scanned item before adding
  const editScannedItem = (index) => {
    const item = scannedItems[index];

    // Calculate default cost basis
    const defaultCostBasis = (item.unitPrice * item.quantity) + item.taxes + item.shipping;

    // Pre-fill form with scanned item data
    setForm({
      productName: item.productName,
      source: item.source,
      datePurchased: item.datePurchased,
      ozt: item.ozt.toString(),
      quantity: item.quantity.toString(),
      unitPrice: item.unitPrice.toString(),
      taxes: item.taxes.toString(),
      shipping: item.shipping.toString(),
      spotPrice: item.spotPrice.toString(),
      premium: item.premium.toString(),
      costBasis: item.costBasis ? item.costBasis.toString() : defaultCostBasis.toString(),
    });
    setSpotPriceSource(null); // Clear source warning when editing

    // Set metal tab
    setMetalTab(item.metal);

    // Store the index so we can update it after editing
    setEditingItem({ ...item, scannedIndex: index });
    setFormErrors({});

    // Close preview modal and open edit modal
    setShowScannedItemsPreview(false);
    setShowAddModal(true);
  };

  // Edit an imported item before confirming import
  const editImportedItem = (index) => {
    const item = importData[index];

    // Calculate default cost basis
    const unitPrice = item.unitPrice || 0;
    const quantity = item.quantity || 1;
    const defaultCostBasis = unitPrice * quantity;

    // Pre-fill form with imported item data
    setForm({
      productName: item.productName || '',
      source: item.source || '',
      datePurchased: item.datePurchased || '',
      ozt: item.ozt ? item.ozt.toString() : '',
      quantity: item.quantity ? item.quantity.toString() : '',
      unitPrice: item.unitPrice ? item.unitPrice.toString() : '',
      taxes: '',
      shipping: '',
      spotPrice: '0',
      premium: '0',
      costBasis: defaultCostBasis.toString(),
    });
    setSpotPriceSource(null); // Clear source warning when editing

    // Set metal tab
    setMetalTab(item.metal || 'silver');

    // Store the index so we can update it after editing
    setEditingItem({ ...item, importIndex: index });
    setFormErrors({});

    // Close preview modal and open edit modal
    setShowImportPreview(false);
    setShowAddModal(true);
  };

  // ============================================
  // CRUD OPERATIONS
  // ============================================

  const savePurchase = () => {
    Keyboard.dismiss();

    const errors = {};
    if (!form.productName) errors.productName = true;
    if (!form.ozt || parseFloat(form.ozt) <= 0) errors.ozt = true;
    if (!form.quantity || parseInt(form.quantity) <= 0) errors.quantity = true;
    if (!form.unitPrice || parseFloat(form.unitPrice) <= 0) errors.unitPrice = true;
    setFormErrors(errors);
    if (Object.keys(errors).length > 0) {
      const names = [];
      if (errors.productName) names.push('Product Name');
      if (errors.ozt) names.push('OZT per unit');
      if (errors.quantity) names.push('Quantity');
      if (errors.unitPrice) names.push('Unit Price');
      Alert.alert('Required Fields', `Please fill in: ${names.join(', ')}`);
      return;
    }

    const item = {
      id: editingItem?.id || Date.now(),
      productName: form.productName, source: form.source, datePurchased: form.datePurchased,
      timePurchased: form.timePurchased || undefined, // Optional time field
      ozt: parseFloat(form.ozt) || 0, quantity: parseInt(form.quantity) || 1,
      unitPrice: parseFloat(form.unitPrice) || 0, taxes: parseFloat(form.taxes) || 0,
      shipping: parseFloat(form.shipping) || 0, spotPrice: parseFloat(form.spotPrice) || 0,
      premium: parseFloat(form.premium) || 0,
      costBasis: form.costBasis ? parseFloat(form.costBasis) : undefined,
    };

    // Check if editing a scanned item
    if (editingItem && editingItem.scannedIndex !== undefined) {
      // Update the scanned item and return to preview
      const updatedItem = {
        ...item,
        metal: metalTab,
      };

      const updatedScannedItems = [...scannedItems];
      updatedScannedItems[editingItem.scannedIndex] = updatedItem;
      setScannedItems(updatedScannedItems);

      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      resetForm();
      setShowAddModal(false);
      setShowScannedItemsPreview(true);
      return;
    }

    // Check if editing an imported item
    if (editingItem && editingItem.importIndex !== undefined) {
      // Update the imported item and return to preview
      const updatedItem = {
        productName: form.productName,
        source: form.source,
        datePurchased: form.datePurchased,
        ozt: parseFloat(form.ozt) || 0,
        quantity: parseInt(form.quantity) || 1,
        unitPrice: parseFloat(form.unitPrice) || 0,
        metal: metalTab,
      };

      const updatedImportData = [...importData];
      updatedImportData[editingItem.importIndex] = updatedItem;
      setImportData(updatedImportData);

      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      resetForm();
      setShowAddModal(false);
      setShowImportPreview(true);
      return;
    }

    // Normal add/edit flow for holdings
    // IMPORTANT: metalTab can be 'silver', 'gold', 'platinum', 'palladium', or 'both' - we must check explicitly
    const targetMetal = metalTab === 'both' ? 'silver' : metalTab; // Default to silver if 'both' (shouldn't happen but safety)

    const settersMap = {
      silver: setSilverItems,
      gold: setGoldItems,
      platinum: setPlatinumItems,
      palladium: setPalladiumItems,
    };
    const setter = settersMap[targetMetal] || setSilverItems;

    if (editingItem) {
      setter(prev => prev.map(i => i.id === editingItem.id ? item : i));
    } else {
      setter(prev => [...prev, item]);
      checkAndRequestReview('holdings');
    }

    // Sync to Supabase if signed in
    if (supabaseUser) {
      (async () => {
        try {
          if (editingItem && editingItem.supabase_id) {
            // Update existing item in Supabase
            await updateHolding(editingItem.supabase_id, item, targetMetal);
            if (__DEV__) console.log('Updated holding in Supabase');
          } else if (editingItem) {
            // Editing a local item that might exist in Supabase - find it first
            const existingHolding = await findHoldingByLocalId(supabaseUser.id, item.id, targetMetal);
            if (existingHolding) {
              await updateHolding(existingHolding.id, item, targetMetal);
              if (__DEV__) console.log('Updated existing holding in Supabase');
            } else {
              // Not in Supabase yet, add it
              const { data } = await addHolding(supabaseUser.id, item, targetMetal);
              if (data && __DEV__) console.log('Added holding to Supabase (was local only)');
            }
          } else {
            // New item - add to Supabase
            const { data } = await addHolding(supabaseUser.id, item, targetMetal);
            if (data && __DEV__) console.log('Added new holding to Supabase');
          }
        } catch (err) {
          if (__DEV__) console.error('Failed to sync holding to Supabase:', err);
          // Don't block the user - local save already succeeded
        }
      })();
    }

    // Haptic feedback on successful add
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);

    resetForm();
    setShowAddModal(false);
  };

  const resetForm = () => {
    setForm({
      productName: '', source: '', datePurchased: '', timePurchased: '', ozt: '',
      quantity: '', unitPrice: '', taxes: '', shipping: '',
      spotPrice: '', premium: '0', costBasis: '',
    });
    setEditingItem(null);
    setSpotPriceSource(null);
    setHistoricalSpotSuggestion(null);
    setFormErrors({});
  };

  const deleteItem = (id, metal) => {
    // Haptic feedback
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

    // Find the item to get its supabase_id if it exists
    const itemsMap = { silver: silverItems, gold: goldItems, platinum: platinumItems, palladium: palladiumItems };
    const items = itemsMap[metal] || silverItems;
    const itemToDelete = items.find(i => i.id === id);

    Alert.alert(
      'Delete Item',
      'Are you sure you want to delete this item? This action cannot be undone.',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            // Haptic feedback on delete
            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);

            const settersMap = { silver: setSilverItems, gold: setGoldItems, platinum: setPlatinumItems, palladium: setPalladiumItems };
            const setter = settersMap[metal] || setSilverItems;
            setter(prev => prev.filter(i => i.id !== id));

            // Delete from Supabase if signed in
            if (supabaseUser && itemToDelete) {
              try {
                if (itemToDelete.supabase_id) {
                  await deleteHoldingFromSupabase(itemToDelete.supabase_id);
                  if (__DEV__) console.log('Deleted holding from Supabase');
                } else {
                  // Find in Supabase by local_id
                  const existingHolding = await findHoldingByLocalId(supabaseUser.id, id, metal);
                  if (existingHolding) {
                    await deleteHoldingFromSupabase(existingHolding.id);
                    if (__DEV__) console.log('Deleted holding from Supabase (found by local_id)');
                  }
                }
              } catch (err) {
                if (__DEV__) console.error('Failed to delete holding from Supabase:', err);
                // Don't block - local delete already succeeded
              }
            }

            // Close detail view if open
            if (showDetailView) {
              setShowDetailView(false);
              setDetailItem(null);
              setDetailMetal(null);
            }
          },
        },
      ]
    );
  };

  const viewItemDetail = (item, metal) => {
    setDetailItem(item);
    setDetailMetal(metal);
    setShowDetailView(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  };

  const sortItems = (items, metal) => {
    const itemsWithMetal = items.map(item => ({ ...item, metal }));
    const spotMap = { silver: silverSpot, gold: goldSpot, platinum: platinumSpot, palladium: palladiumSpot };
    const spot = spotMap[metal] || silverSpot;

    switch (sortBy) {
      case 'date-newest':
        return [...itemsWithMetal].sort((a, b) => {
          if (!a.datePurchased) return 1;
          if (!b.datePurchased) return -1;
          return new Date(b.datePurchased) - new Date(a.datePurchased);
        });
      case 'date-oldest':
        return [...itemsWithMetal].sort((a, b) => {
          if (!a.datePurchased) return 1;
          if (!b.datePurchased) return -1;
          return new Date(a.datePurchased) - new Date(b.datePurchased);
        });
      case 'value-high':
        return [...itemsWithMetal].sort((a, b) => (b.ozt * b.quantity * spot) - (a.ozt * a.quantity * spot));
      case 'value-low':
        return [...itemsWithMetal].sort((a, b) => (a.ozt * a.quantity * spot) - (b.ozt * b.quantity * spot));
      case 'name':
        return [...itemsWithMetal].sort((a, b) => a.productName.localeCompare(b.productName));
      case 'metal':
        // Already filtered by metal in most cases
        return itemsWithMetal;
      default:
        return itemsWithMetal;
    }
  };

  const editItem = async (item, metal) => {
    setMetalTab(metal);
    // Calculate default cost basis if not set
    const defaultCostBasis = (item.unitPrice * item.quantity) + item.taxes + item.shipping;
    setForm({
      productName: item.productName, source: item.source, datePurchased: item.datePurchased,
      timePurchased: item.timePurchased || '',
      ozt: item.ozt.toString(), quantity: item.quantity.toString(), unitPrice: item.unitPrice.toString(),
      taxes: item.taxes.toString(), shipping: item.shipping.toString(), spotPrice: item.spotPrice.toString(),
      premium: item.premium.toString(),
      costBasis: item.costBasis ? item.costBasis.toString() : defaultCostBasis.toString(),
    });
    setEditingItem(item);
    setSpotPriceSource(null); // Clear source warning when editing existing item
    setHistoricalSpotSuggestion(null); // Clear any previous suggestion
    setFormErrors({});
    setShowAddModal(true);

    // Always fetch historical spot price if date is present (for comparison/auto-fill)
    const spotPrice = item.spotPrice || 0;
    const hasDate = item.datePurchased && item.datePurchased.length === 10;

    if (hasDate) {
      const result = await fetchHistoricalSpot(item.datePurchased, metal, item.timePurchased);
      if (result.price) {
        // Always store suggestion for comparison (enables warning display)
        setHistoricalSpotSuggestion({
          price: result.price,
          source: result.source,
          date: item.datePurchased,
        });

        // Auto-fill only if no spot price recorded
        if (spotPrice === 0) {
          setForm(prev => ({ ...prev, spotPrice: result.price.toString() }));
          setSpotPriceSource(result.source);
        }
        // If spotPrice exists, the warning will auto-show if difference > 10%
      }
    }
  };

  const exportCSV = async () => {
    try {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

      const all = [
        ...silverItems.map(i => ({ ...i, metal: 'Silver' })),
        ...goldItems.map(i => ({ ...i, metal: 'Gold' })),
        ...platinumItems.map(i => ({ ...i, metal: 'Platinum' })),
        ...palladiumItems.map(i => ({ ...i, metal: 'Palladium' })),
      ];

      if (all.length === 0) {
        Alert.alert('No Data', 'You have no holdings to export.');
        return;
      }

      const headers = 'Metal,Product,Source,Date,Time,OZT,Qty,Unit Price,Taxes,Shipping,Spot,Premium,Total Premium\n';
      const rows = all.map(i =>
        `${i.metal},"${i.productName}","${i.source}",${i.datePurchased},${i.timePurchased || ''},${i.ozt},${i.quantity},${i.unitPrice},${i.taxes},${i.shipping},${i.spotPrice},${i.premium},${i.premium * i.quantity}`
      ).join('\n');

      const filepath = `${FileSystem.documentDirectory}stack-export-${Date.now()}.csv`;
      await FileSystem.writeAsStringAsync(filepath, headers + rows);
      await Sharing.shareAsync(filepath);

      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } catch (error) {
      if (__DEV__) console.error('Export CSV error:', error);
      Alert.alert('Export Failed', error.message || 'Could not export CSV file.');
    }
  };

  // ============================================
  // SHARE MY STACK
  // ============================================
  const shareMyStack = async () => {
    try {
      if (!shareViewRef.current) {
        Alert.alert('Error', 'Unable to generate share image');
        return;
      }

      setIsGeneratingShare(true);
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

      // Brief delay to ensure view is rendered
      await new Promise(resolve => setTimeout(resolve, 100));

      // Capture the view as an image
      const uri = await shareViewRef.current.capture();

      // Share the image
      await Sharing.shareAsync(uri, {
        mimeType: 'image/png',
        dialogTitle: 'Share My Stack',
        UTI: 'public.png',
      });

      setIsGeneratingShare(false);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } catch (error) {
      if (__DEV__) console.error('Share My Stack error:', error);
      setIsGeneratingShare(false);
      Alert.alert('Share Failed', error.message || 'Could not generate share image.');
    }
  };

  // ============================================
  // LOADING & AUTH SCREENS
  // ============================================

  // Helper to enable guest mode
  const enableGuestMode = async () => {
    setGuestMode(true);
    try {
      await AsyncStorage.setItem('stack_guest_mode', 'true');
    } catch (error) {
      if (__DEV__) console.error('Failed to save guest mode:', error);
    }
  };

  // Helper to disable guest mode (when user signs in)
  const disableGuestMode = async () => {
    setGuestMode(false);
    try {
      await AsyncStorage.removeItem('stack_guest_mode');
    } catch (error) {
      if (__DEV__) console.error('Failed to remove guest mode:', error);
    }
  };

  // Handle successful auth from AuthScreen
  const handleAuthSuccess = () => {
    setShowAuthScreen(false);
    disableGuestMode();
  };

  // Show reset password screen when opened via deep link
  if (showResetPasswordScreen) {
    return (
      <View style={[styles.container, { backgroundColor: '#09090b' }]}>
        <StatusBar barStyle="light-content" />
        <ResetPasswordScreen onComplete={() => setShowResetPasswordScreen(false)} />
      </View>
    );
  }

  if (isLoading || authLoading || guestMode === null) {
    return (
      <View style={[styles.container, { justifyContent: 'center', alignItems: 'center' }]}>
        <ActivityIndicator size="large" color={colors.silver} />
        <Text style={{ color: colors.muted, marginTop: 16 }}>Loading your stack...</Text>
      </View>
    );
  }

  // Show AuthScreen if user is not signed in with Supabase AND not in guest mode
  if (!supabaseUser && !guestMode) {
    return (
      <View style={[styles.container, { backgroundColor: colors.background }]}>
        <StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} />
        <AuthScreen onAuthSuccess={handleAuthSuccess} />
        {/* Skip for now button */}
        <View style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          paddingHorizontal: 24,
          paddingBottom: Platform.OS === 'ios' ? 50 : 30,
          backgroundColor: colors.background,
        }}>
          <TouchableOpacity
            style={{
              paddingVertical: 16,
              alignItems: 'center',
            }}
            onPress={enableGuestMode}
          >
            <Text style={{ color: colors.muted, fontSize: 15 }}>
              Continue without signing in
            </Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  // Show biometric auth screen (Face ID / Touch ID)
  if (!isAuthenticated) {
    return (
      <View style={[styles.container, { justifyContent: 'center', alignItems: 'center' }]}>
        <Image source={require('./assets/icon.png')} style={{ width: 80, height: 80, borderRadius: 16, marginBottom: 16 }} />
        <Text style={{ color: colors.text, fontSize: 24, fontWeight: '700', marginBottom: 8 }}>Stack Tracker Gold</Text>
        <Text style={{ color: colors.muted, marginBottom: 32 }}>Authenticate to continue</Text>
        <TouchableOpacity style={[styles.button, { backgroundColor: colors.silver }]} onPress={authenticate}>
          <Text style={{ color: '#000', fontWeight: '600' }}>Unlock</Text>
        </TouchableOpacity>
      </View>
    );
  }

  const metalColorMap = { silver: colors.silver, gold: colors.gold, platinum: colors.platinum, palladium: colors.palladium };
  const currentColor = metalColorMap[metalTab] || colors.gold;
  const metalItemsMap = { silver: silverItems, gold: goldItems, platinum: platinumItems, palladium: palladiumItems };
  const items = metalItemsMap[metalTab] || [];
  const metalSpotMap = { silver: silverSpot, gold: goldSpot, platinum: platinumSpot, palladium: palladiumSpot };
  const spot = metalSpotMap[metalTab] || goldSpot;

  // ============================================
  // SIDE DRAWER
  // ============================================

  const drawerSections = [
    { key: 'today', label: 'Today', items: [
      { key: 'morningBrief', label: "Troy's Take" },
      { key: 'portfolioPulse', label: 'Portfolio Pulse' },
      { key: 'metalMovers', label: 'Metal Movers' },
      { key: 'whatChanged', label: 'What Changed Today' },
      { key: 'vaultWatch', label: 'Vault Watch' },
      { key: 'intelligenceFeed', label: 'Intelligence Feed' },
    ]},
    { key: 'portfolio', label: 'Stack', items: [
      { key: 'portfolioSummary', label: 'Summary' },
      { key: 'holdings', label: 'Holdings' },
    ]},
    { key: 'analytics', label: 'Analytics', items: [
      { key: 'portfolioValueChart', label: 'Portfolio Value Chart' },
      { key: 'spotPriceHistory', label: 'Spot Price History' },
      { key: 'holdingsBreakdown', label: 'Holdings Breakdown' },
      { key: 'purchaseStatistics', label: 'Purchase Statistics' },
      { key: 'breakEvenAnalysis', label: 'Break-Even Analysis' },
    ]},
    { key: 'tools', label: 'Tools', items: [
      { key: 'priceAlerts', label: 'Price Alerts' },
      { key: 'speculationTool', label: 'Speculation Tool' },
      { key: 'junkSilver', label: 'Junk Silver Calculator' },
      { key: 'stackMilestones', label: 'Stack Milestones' },
      { key: 'shareMyStack', label: 'Share My Stack' },
    ]},
    { key: 'settings', label: 'Settings', items: [
      ...(Platform.OS !== 'ios' ? [{ key: 'webApp', label: 'Web App' }] : []),
      { key: 'account', label: 'Account' },
      { key: 'notifications', label: 'Notifications' },
      { key: 'whatsNew', label: "What's New in v2.0" },
      { key: 'about', label: 'About' },
    ]},
  ];

  const openDrawer = () => {
    drawerOpenRef.current = true;
    setDrawerOpen(true);
    Animated.parallel([
      Animated.timing(drawerAnim, { toValue: 0, duration: 250, useNativeDriver: true }),
      Animated.timing(drawerOverlayAnim, { toValue: 1, duration: 250, useNativeDriver: true }),
    ]).start();
  };
  openDrawerRef.current = openDrawer;

  const closeDrawer = () => {
    Animated.parallel([
      Animated.timing(drawerAnim, { toValue: -300, duration: 200, useNativeDriver: true }),
      Animated.timing(drawerOverlayAnim, { toValue: 0, duration: 200, useNativeDriver: true }),
    ]).start(() => {
      drawerOpenRef.current = false;
      setDrawerOpen(false);
    });
  };

  const navigateToSection = (tabKey, sectionKey) => {
    closeDrawer();
    // Special case: Web App opens URL directly
    if (sectionKey === 'webApp') {
      Linking.openURL('https://app.stacktrackergold.com');
      return;
    }
    // Settings sub-pages: open directly
    if (tabKey === 'settings' && sectionKey === 'notifications') {
      setTab('settings');
      setSettingsSubPage('notifications');
      setTimeout(() => { scrollRef.current?.scrollTo({ y: 0, animated: false }); }, 100);
      return;
    }
    if (tab !== tabKey) {
      setTab(tabKey);
    }
    // Reset settings sub-page when navigating to main settings sections
    if (tabKey === 'settings') {
      setSettingsSubPage(null);
    }
    setTimeout(() => {
      const y = sectionOffsets.current[sectionKey];
      if (y !== undefined) {
        scrollRef.current?.scrollTo({ y: Math.max(0, y - 10), animated: true });
      }
    }, 100);
  };

  // ============================================
  // MAIN RENDER
  // ============================================

  return (
    <SafeAreaView {...drawerPanResponder.panHandlers} style={[styles.container, { backgroundColor: colors.background }]}>
      <StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} />

      {/* Header */}
      <View style={[styles.header, { backgroundColor: isDarkMode ? 'rgba(0,0,0,0.4)' : 'rgba(255,255,255,0.8)', borderBottomColor: colors.border }]}>
        <View style={styles.headerContent}>
          <View style={{ flexDirection: 'row', alignItems: 'center', gap: 4 }}>
          <TouchableOpacity onPress={openDrawer} activeOpacity={0.7} hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }} style={{ paddingRight: 6 }}>
            <Text style={{ color: '#D4A843', fontSize: 22, fontWeight: '300' }}>â˜°</Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={openDrawer} activeOpacity={0.7} style={styles.logo}>
            <Image source={require('./assets/icon.png')} style={{ width: 40, height: 40, borderRadius: 8 }} />
            <Text style={[styles.logoTitle, { color: colors.text }]}>Stack Tracker Gold</Text>
            {/* Sync Status Indicator */}
            {isSyncing && (
              <View style={{ marginLeft: 8, flexDirection: 'row', alignItems: 'center' }}>
                <ActivityIndicator size="small" color={colors.gold} />
              </View>
            )}
            {syncError && !isSyncing && (
              <TouchableOpacity
                style={{ marginLeft: 8 }}
                onPress={() => Alert.alert('Sync Error', syncError, [{ text: 'OK', onPress: () => setSyncError(null) }])}
              >
                <Text style={{ color: colors.error, fontSize: 16 }}>!</Text>
              </TouchableOpacity>
            )}
          </TouchableOpacity>
          </View>
          <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
            {supabaseUser ? (
              // Signed in - show profile icon that goes to account
              <TouchableOpacity
                style={{
                  width: 36,
                  height: 36,
                  borderRadius: 18,
                  backgroundColor: isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)',
                  alignItems: 'center',
                  justifyContent: 'center',
                  borderWidth: 1,
                  borderColor: isDarkMode ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.1)',
                }}
                onPress={() => setShowAccountScreen(true)}
              >
                <ProfileIcon size={20} color={colors.gold} />
              </TouchableOpacity>
            ) : (
              // Not signed in - show Sign In button
              <TouchableOpacity
                style={{
                  paddingHorizontal: 14,
                  paddingVertical: 8,
                  backgroundColor: colors.gold,
                  borderRadius: 20,
                }}
                onPress={() => disableGuestMode()}
              >
                <Text style={{ color: '#18181b', fontSize: 13, fontWeight: '600' }}>Sign In</Text>
              </TouchableOpacity>
            )}
          </View>
        </View>
      </View>

      {/* Main Content */}
      <ScrollView
        ref={scrollRef}
        style={styles.content}
        keyboardShouldPersistTaps="handled"
        keyboardDismissMode="on-drag"
        refreshControl={
          (tab === 'portfolio' || tab === 'analytics' || tab === 'today') ? (
            <RefreshControl
              refreshing={isRefreshing}
              onRefresh={
                tab === 'portfolio' ? onRefreshDashboard :
                tab === 'today' ? onRefreshToday :
                onRefreshAnalytics
              }
              tintColor={colors.gold}
              colors={[colors.gold]}
            />
          ) : undefined
        }
      >

        {/* TODAY TAB */}
        {tab === 'today' && (() => {
          const todayDate = new Date();
          const dateStr = todayDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

          // Screenshot mode overrides
          const effGoldSpot = demoData ? demoData.goldSpot : goldSpot;
          const effSilverSpot = demoData ? demoData.silverSpot : silverSpot;
          const effPlatinumSpot = demoData ? demoData.platinumSpot : platinumSpot;
          const effPalladiumSpot = demoData ? demoData.palladiumSpot : palladiumSpot;
          const effSpotChange = demoData ? demoData.spotChange : spotChange;
          const effSparklineData = demoData ? demoData.sparklineData : sparklineData;
          const effTotalMeltValue = demoData ? demoData.totalMeltValue : totalMeltValue;
          const effMarketsClosed = demoData ? false : marketsClosed;
          const effHasGoldAccess = demoData ? true : hasGoldAccess;

          // Metal movers data (fixed grid: Ag top-left, Au top-right, Pt bottom-left, Pd bottom-right)
          const metalMovers = [
            { symbol: 'Ag', label: 'Silver', spot: effSilverSpot, change: effSpotChange?.silver?.amount || 0, pct: effSpotChange?.silver?.percent || 0, color: '#9ca3af' },
            { symbol: 'Au', label: 'Gold', spot: effGoldSpot, change: effSpotChange?.gold?.amount || 0, pct: effSpotChange?.gold?.percent || 0, color: '#D4A843' },
            { symbol: 'Pt', label: 'Platinum', spot: effPlatinumSpot, change: effSpotChange?.platinum?.amount || 0, pct: effSpotChange?.platinum?.percent || 0, color: '#7BB3D4' },
            { symbol: 'Pd', label: 'Palladium', spot: effPalladiumSpot, change: effSpotChange?.palladium?.amount || 0, pct: effSpotChange?.palladium?.percent || 0, color: '#6BBF8A' },
          ];
          const biggestMoverSymbol = metalMovers.reduce((best, m) => Math.abs(m.pct) > Math.abs(best.pct) ? m : best, metalMovers[0]).symbol;

          // Portfolio impact per metal (only metals held)
          const holdingsImpact = demoData ? [
            { label: 'Gold', ozt: 68.2, spot: effGoldSpot, pct: effSpotChange?.gold?.percent || 0, color: '#D4A843' },
            { label: 'Silver', ozt: 1420, spot: effSilverSpot, pct: effSpotChange?.silver?.percent || 0, color: '#9ca3af' },
            { label: 'Platinum', ozt: 7.5, spot: effPlatinumSpot, pct: effSpotChange?.platinum?.percent || 0, color: '#7BB3D4' },
            { label: 'Palladium', ozt: 3.0, spot: effPalladiumSpot, pct: effSpotChange?.palladium?.percent || 0, color: '#6BBF8A' },
          ].map(m => {
            const currentValue = m.ozt * m.spot;
            const prevValue = m.pct !== 0 ? currentValue / (1 + m.pct / 100) : currentValue;
            const dollarChange = currentValue - prevValue;
            return { ...m, currentValue, dollarChange };
          }).sort((a, b) => Math.abs(b.dollarChange) - Math.abs(a.dollarChange)) : [
            { label: 'Gold', ozt: totalGoldOzt, spot: goldSpot, pct: spotChange?.gold?.percent || 0, color: '#D4A843' },
            { label: 'Silver', ozt: totalSilverOzt, spot: silverSpot, pct: spotChange?.silver?.percent || 0, color: '#9ca3af' },
            { label: 'Platinum', ozt: totalPlatinumOzt, spot: platinumSpot, pct: spotChange?.platinum?.percent || 0, color: '#7BB3D4' },
            { label: 'Palladium', ozt: totalPalladiumOzt, spot: palladiumSpot, pct: spotChange?.palladium?.percent || 0, color: '#6BBF8A' },
          ].filter(m => m.ozt > 0).map(m => {
            const currentValue = m.ozt * m.spot;
            const prevValue = m.pct !== 0 ? currentValue / (1 + m.pct / 100) : currentValue;
            const dollarChange = currentValue - prevValue;
            return { ...m, currentValue, dollarChange };
          }).sort((a, b) => Math.abs(b.dollarChange) - Math.abs(a.dollarChange));

          // AI summary generation (client-side)
          const biggestMover = metalMovers.reduce((best, m) => Math.abs(m.pct) > Math.abs(best.pct) ? m : best, metalMovers[0]);
          const effDailyChange = demoData ? demoData.dailyChange : dailyChange;
          const gainedLost = effDailyChange >= 0 ? 'gained' : 'lost';
          const rallyDecline = biggestMover?.pct >= 0 ? 'rally' : 'decline';
          const aiSummary = effMarketsClosed
            ? 'Markets are closed. Prices reflect Friday\u2019s close.'
            : effTotalMeltValue > 0 && effDailyChange !== 0
            ? `Your stack ${gainedLost} $${formatCurrency(Math.abs(effDailyChange), 0)} today, driven by ${biggestMover?.label}'s ${Math.abs(biggestMover?.pct || 0).toFixed(1)}% ${rallyDecline}.`
            : effTotalMeltValue > 0
            ? 'Markets are steady today. Your stack value is unchanged.'
            : 'Add holdings to see your daily portfolio changes.';

          // Display values (zeroed when markets closed, or demo values in screenshot mode)
          const displayDailyChange = demoData ? demoData.dailyChange : (marketsClosed ? 0 : dailyChange);
          const displayDailyChangePct = demoData ? demoData.dailyChangePct : (marketsClosed ? 0 : dailyChangePct);

          const categoryColors = {
            market_brief: '#D4A843',
            breaking_news: '#F87171',
            policy: '#60A5FA',
            supply_demand: '#6BBF8A',
            analysis: '#C084FC',
            gold: '#D4A843',
            silver: '#A8B5C8',
            platinum: '#7BB3D4',
            palladium: '#6BBF8A',
            general: '#A1A1AA',
          };

          const categoryLabels = {
            market_brief: 'Market Brief',
            breaking_news: 'Breaking',
            policy: 'Policy',
            supply_demand: 'Supply & Demand',
            analysis: 'Analysis',
            gold: 'Gold',
            silver: 'Silver',
            platinum: 'Platinum',
            palladium: 'Palladium',
            general: 'Market',
          };

          const todayCardBg = isDarkMode ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.03)';
          const todayCardBorder = isDarkMode ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)';

          return (
            <View style={{ backgroundColor: isDarkMode ? '#0d0d0d' : colors.bg, marginHorizontal: -20, paddingHorizontal: 16, paddingTop: 4, minHeight: Dimensions.get('window').height - 200 }}>

              {/* ===== TROY'S TAKE ===== */}
              <View onLayout={(e) => { sectionOffsets.current['morningBrief'] = e.nativeEvent.layout.y; }}>
              {effHasGoldAccess ? (
                <View style={{
                  backgroundColor: todayCardBg,
                  borderRadius: 16,
                  borderWidth: 1,
                  borderColor: todayCardBorder,
                  borderLeftWidth: 3,
                  borderLeftColor: '#D4A843',
                  padding: 16,
                  marginBottom: 16,
                }}>
                  <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 8 }}>
                    <TroyCoinIcon size={20} />
                    <Text style={{ color: colors.muted, fontSize: 12, fontWeight: '600' }}>
                      Troy's Take Â· {dailyBrief && dailyBrief.date && !dailyBrief.is_current
                        ? new Date(dailyBrief.date + 'T12:00:00').toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })
                        : new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}
                    </Text>
                  </View>
                  {demoData ? (
                    <>
                      <Text style={{ color: colors.text, fontSize: 14, lineHeight: 20 }} numberOfLines={briefExpanded ? undefined : 2}>Gold surged past $5,000 today, lifting your portfolio to a new all-time high of $502,847. Silver led the rally with a 2.4% gain, continuing its strong momentum this week. All four metals are trading in the green, with platinum and palladium both posting solid gains above 1%. Your stack gained $8,241 today â€” a great day for precious metals holders.</Text>
                      <TouchableOpacity onPress={() => setBriefExpanded(!briefExpanded)} style={{ marginTop: 4, paddingVertical: 12 }}>
                        <Text style={{ color: '#D4A843', fontSize: 15, fontWeight: '700' }}>{briefExpanded ? 'See less' : 'See more'}</Text>
                      </TouchableOpacity>
                    </>
                  ) : dailyBriefLoading ? (
                    <ActivityIndicator size="small" color="#D4A843" style={{ paddingVertical: 8 }} />
                  ) : dailyBrief && dailyBrief.brief_text ? (
                    <>
                      {!dailyBrief.is_current && (
                        <Text style={{ color: colors.gold, fontSize: 11, fontStyle: 'italic', marginBottom: 6 }}>
                          Today's take will be available after 6:30 AM EST. Showing Troy's most recent.
                        </Text>
                      )}
                      <Text style={{ color: colors.text, fontSize: 14, lineHeight: 20 }} numberOfLines={briefExpanded ? undefined : 2}>{dailyBrief.brief_text}</Text>
                      <TouchableOpacity onPress={() => setBriefExpanded(!briefExpanded)} style={{ marginTop: 4, paddingVertical: 12 }}>
                        <Text style={{ color: '#D4A843', fontSize: 15, fontWeight: '700' }}>{briefExpanded ? 'See less' : 'See more'}</Text>
                      </TouchableOpacity>
                      {briefExpanded && <Text style={{ color: '#666', fontSize: 11, fontStyle: 'italic' }}>AI-generated analysis. Not financial advice.</Text>}
                    </>
                  ) : (
                    <Text style={{ color: colors.muted, fontSize: 13, fontStyle: 'italic' }}>
                      Troy's first take will be available after 6:30 AM EST.
                    </Text>
                  )}
                </View>
              ) : dailyBrief && dailyBrief.brief_text ? (
                <View style={{
                  backgroundColor: todayCardBg,
                  borderRadius: 16,
                  borderWidth: 1,
                  borderColor: todayCardBorder,
                  borderLeftWidth: 3,
                  borderLeftColor: '#D4A843',
                  padding: 16,
                  marginBottom: 16,
                }}>
                  <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 8 }}>
                    <TroyCoinIcon size={20} />
                    <Text style={{ color: colors.muted, fontSize: 12, fontWeight: '600' }}>Troy's Take</Text>
                  </View>
                  <View style={{ maxHeight: 60, overflow: 'hidden' }}>
                    <Text style={{ color: colors.text, fontSize: 14, lineHeight: 20 }}>{dailyBrief.brief_text}</Text>
                  </View>
                  {/* Gradient fade overlay */}
                  <View style={{ height: 40, marginTop: -40 }}>
                    <View style={{ flex: 1, backgroundColor: todayCardBg, opacity: 0 }} />
                    <View style={{ flex: 1, backgroundColor: todayCardBg, opacity: 0.4 }} />
                    <View style={{ flex: 1, backgroundColor: todayCardBg, opacity: 0.7 }} />
                    <View style={{ flex: 1, backgroundColor: todayCardBg, opacity: 0.95 }} />
                  </View>
                  <TouchableOpacity onPress={() => setShowPaywallModal(true)} style={{ marginTop: 4 }}>
                    <Text style={{ color: '#D4A843', fontSize: 13, fontWeight: '600' }}>Unlock Troy's full daily briefing with Gold â†’</Text>
                  </TouchableOpacity>
                </View>
              ) : (
                <TouchableOpacity
                  style={{
                    backgroundColor: todayCardBg,
                    borderRadius: 16,
                    borderWidth: 1,
                    borderColor: todayCardBorder,
                    borderLeftWidth: 3,
                    borderLeftColor: '#D4A843',
                    padding: 16,
                    marginBottom: 16,
                  }}
                  onPress={() => setShowPaywallModal(true)}
                >
                  <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 4 }}>
                    <TroyCoinIcon size={20} />
                    <Text style={{ color: colors.muted, fontSize: 12, fontWeight: '600' }}>Troy's Take</Text>
                  </View>
                  <Text style={{ color: colors.muted, fontSize: 13 }}>
                    Get Troy's daily market analysis with Gold
                  </Text>
                  <View style={{ flexDirection: 'row', alignItems: 'center', marginTop: 6, backgroundColor: 'rgba(251,191,36,0.15)', alignSelf: 'flex-start', paddingHorizontal: 8, paddingVertical: 3, borderRadius: 4 }}>
                    <Text style={{ color: colors.gold, fontSize: 11, fontWeight: '600' }}>UPGRADE</Text>
                  </View>
                </TouchableOpacity>
              )}
              </View>

              {/* ===== SECTION 1: PORTFOLIO PULSE ===== */}
              <View onLayout={(e) => { sectionOffsets.current['portfolioPulse'] = e.nativeEvent.layout.y; }} style={{
                backgroundColor: todayCardBg,
                borderRadius: 16,
                borderWidth: 1,
                borderColor: todayCardBorder,
                padding: 20,
                marginBottom: 16,
              }}>
                {/* Gold accent line */}
                <View style={{ position: 'absolute', top: 0, left: 0, right: 0, height: 2, backgroundColor: '#D4A843', borderTopLeftRadius: 16, borderTopRightRadius: 16 }} />

                <Text style={{ color: colors.muted, fontSize: 13, fontWeight: '500', marginBottom: 4, marginTop: 4 }}>Today, {dateStr}</Text>

                <Text style={{ color: colors.text, fontSize: 36, fontWeight: '700', marginBottom: 2 }}>${formatCurrency(effTotalMeltValue, 0)}</Text>

                {effSparklineData && effSparklineData.gold.length >= 2 && effTotalMeltValue > 0 && (() => {
                  const goldPts = effSparklineData.gold;
                  const silverPts = effSparklineData.silver;
                  const effGoldOzt = demoData ? 68.2 : totalGoldOzt;
                  const effSilverOzt = demoData ? 1420 : totalSilverOzt;
                  const effPlatinumOzt = demoData ? 7.5 : totalPlatinumOzt;
                  const effPalladiumOzt = demoData ? 3.0 : totalPalladiumOzt;
                  const portfolioPoints = goldPts.map((g, i) => (effGoldOzt * g) + (effSilverOzt * (silverPts[i] || 0)) + (effPlatinumOzt * (effSparklineData.platinum[i] || 0)) + (effPalladiumOzt * (effSparklineData.palladium[i] || 0)));
                  const isUp = displayDailyChangePct >= 0;
                  const sparkColor = isUp ? '#4CAF50' : '#F44336';
                  return (
                    <ScrubSparkline
                      dataPoints={portfolioPoints}
                      timestamps={effSparklineData.timestamps}
                      svgW={300}
                      svgH={60}
                      strokeColor={sparkColor}
                      gradientId="portfolioGrad"
                      formatValue={(v) => `$${formatCurrency(v, 0)}`}
                      label="Portfolio"
                      style={{ marginBottom: 4 }}
                    />
                  );
                })()}

                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 12 }}>
                  <Text style={{ color: displayDailyChange >= 0 ? '#4CAF50' : '#F44336', fontSize: 15, fontWeight: '600' }}>
                    {displayDailyChange >= 0 ? 'â–²' : 'â–¼'} ${formatCurrency(Math.abs(displayDailyChange), 0)}
                  </Text>
                  <Text style={{ color: displayDailyChange >= 0 ? '#4CAF50' : '#F44336', fontSize: 13 }}>
                    ({displayDailyChangePct >= 0 ? '+' : ''}{displayDailyChangePct.toFixed(2)}%)
                  </Text>
                </View>

                <Text style={{ color: colors.muted, fontSize: 13, lineHeight: 18, fontStyle: 'italic' }}>{aiSummary}</Text>
              </View>

              {/* ===== SECTION 2: METAL MOVERS (2x2 Grid) ===== */}
              <View onLayout={(e) => { sectionOffsets.current['metalMovers'] = e.nativeEvent.layout.y; }} style={{ marginBottom: 16 }}>
                <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', letterSpacing: 1.2, textTransform: 'uppercase', marginBottom: 10, marginLeft: 4 }}>Metal Movers</Text>
                <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 10 }}>
                  {metalMovers.map((m, idx) => {
                    const metalKey = m.label.toLowerCase();
                    const points = effSparklineData?.[metalKey] || [];
                    const isUp = m.pct >= 0;
                    const sparkColor = isUp ? '#4CAF50' : '#F44336';
                    const isBiggestMover = m.symbol === biggestMoverSymbol && !effMarketsClosed && Math.abs(m.pct) > 0.1;
                    const glowColor = isBiggestMover ? (m.pct >= 0 ? '#4CAF50' : '#F44336') : 'transparent';
                    return (
                      <View key={m.symbol} style={{
                        backgroundColor: todayCardBg,
                        borderRadius: 12,
                        borderWidth: 1,
                        borderColor: isBiggestMover ? glowColor + '40' : todayCardBorder,
                        padding: 14,
                        width: (SCREEN_WIDTH - 32 - 10) / 2,
                        zIndex: 1,
                        ...(isBiggestMover ? {
                          shadowColor: glowColor,
                          shadowOffset: { width: 0, height: 0 },
                          shadowOpacity: 0.5,
                          shadowRadius: 8,
                          elevation: 6,
                        } : {}),
                      }}>
                        <View style={{ position: 'absolute', top: 0, left: 0, right: 0, height: 2, backgroundColor: m.color, borderTopLeftRadius: 12, borderTopRightRadius: 12 }} />

                        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 6 }}>
                          <View style={{ width: 8, height: 8, borderRadius: 4, backgroundColor: m.color }} />
                          <Text style={{ color: m.color, fontSize: 13, fontWeight: '700' }}>{m.label}</Text>
                        </View>

                        {points.length >= 2 && (
                          <ScrubSparkline
                            dataPoints={points}
                            timestamps={effSparklineData?.timestamps}
                            svgW={120}
                            svgH={32}
                            strokeColor={sparkColor}
                            gradientId={`metalGrad_${m.symbol}`}
                            formatValue={(v) => `$${m.symbol === 'Ag' ? v.toFixed(2) : formatCurrency(v, 0)}`}
                            label={m.label}
                            style={{ alignItems: 'center', marginBottom: 6 }}
                          />
                        )}

                        <Text style={{ color: colors.text, fontSize: 18, fontWeight: '700', marginBottom: 4 }}>
                          ${m.symbol === 'Ag' ? m.spot.toFixed(2) : formatCurrency(m.spot, 0)}
                        </Text>

                        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 4 }}>
                          {effMarketsClosed ? (
                            <Text style={{ color: '#71717a', fontSize: 12, fontWeight: '600' }}>+0.0%</Text>
                          ) : (
                            <>
                              <Text style={{ color: m.change >= 0 ? '#4CAF50' : '#F44336', fontSize: 12, fontWeight: '600' }}>
                                {m.change >= 0 ? '+' : ''}{m.symbol === 'Ag' ? m.change.toFixed(2) : m.change.toFixed(0)}
                              </Text>
                              <Text style={{ color: m.pct >= 0 ? '#4CAF50' : '#F44336', fontSize: 11 }}>
                                ({m.pct >= 0 ? '+' : ''}{m.pct.toFixed(1)}%)
                              </Text>
                            </>
                          )}
                        </View>
                      </View>
                    );
                  })}
                </View>
              </View>

              {/* ===== SECTION 3: WHAT CHANGED TODAY ===== */}
              <View onLayout={(e) => { sectionOffsets.current['whatChanged'] = e.nativeEvent.layout.y; }} style={{ marginBottom: 16 }}>
                  {holdingsImpact.length > 0 && (
                    <View>
                      <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', letterSpacing: 1.2, textTransform: 'uppercase', marginBottom: 10, marginLeft: 4 }}>What Changed Today</Text>
                      <View style={{
                        backgroundColor: todayCardBg,
                        borderRadius: 12,
                        borderWidth: 1,
                        borderColor: todayCardBorder,
                        overflow: 'hidden',
                      }}>
                        {holdingsImpact.map((m, i) => (
                          <View key={m.label} style={{
                            paddingVertical: 14,
                            paddingHorizontal: 16,
                            borderBottomWidth: i < holdingsImpact.length - 1 ? 1 : 0,
                            borderBottomColor: todayCardBorder,
                          }}>
                            {effHasGoldAccess || i === 0 ? (
                              <>
                                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
                                  <View style={{ width: 8, height: 8, borderRadius: 4, backgroundColor: m.color }} />
                                  <Text style={{ color: colors.text, fontSize: 14, flex: 1 }}>
                                    Your {m.label.toLowerCase()} ({formatOunces(m.ozt, m.label === 'Silver' ? 0 : 2)} oz)
                                  </Text>
                                </View>
                                {marketsClosed ? (
                                  <Text style={{ color: colors.muted, fontSize: 14, fontWeight: '600', marginLeft: 16, marginTop: 4 }}>
                                    No change (markets closed)
                                  </Text>
                                ) : (
                                  <Text style={{ color: m.dollarChange >= 0 ? '#4CAF50' : '#F44336', fontSize: 14, fontWeight: '600', marginLeft: 16, marginTop: 4 }}>
                                    {m.dollarChange >= 0 ? 'gained' : 'lost'} ${formatCurrency(Math.abs(m.dollarChange), 0)} ({m.pct >= 0 ? '+' : ''}{m.pct.toFixed(1)}%)
                                  </Text>
                                )}
                              </>
                            ) : (
                              <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
                                <View style={{ width: 8, height: 8, borderRadius: 4, backgroundColor: m.color }} />
                                <Text style={{ color: colors.text, fontSize: 14, flex: 1 }}>{m.label}</Text>
                                <Text style={{ color: colors.muted, fontSize: 14 }}>{'\u2022\u2022\u2022\u2022\u2022\u2022'}</Text>
                              </View>
                            )}
                          </View>
                        ))}
                      </View>
                    </View>
                  )}
                  {holdingsImpact.length === 0 && (
                    <View style={{
                      backgroundColor: todayCardBg,
                      borderRadius: 12,
                      borderWidth: 1,
                      borderColor: todayCardBorder,
                      padding: 20,
                      alignItems: 'center',
                    }}>
                      <Text style={{ color: colors.muted, fontSize: 14 }}>Add holdings to see daily impact</Text>
                    </View>
                  )}
                {!effHasGoldAccess && holdingsImpact.length > 1 && (
                  <>
                    <TouchableOpacity
                      onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setShowPaywallModal(true); }}
                      style={{ marginTop: 10, borderWidth: 1, borderColor: 'rgba(212, 168, 67, 0.3)', borderRadius: 10, paddingVertical: 10, paddingHorizontal: 16, alignItems: 'center' }}
                    >
                      <Text style={{ color: colors.gold, fontSize: 13, fontWeight: '600' }}>Try Gold free for 7 days</Text>
                      <Text style={{ color: colors.muted, fontSize: 10, marginTop: 2 }}>Then $9.99/mo Â· Cancel anytime</Text>
                    </TouchableOpacity>
                    <TouchableOpacity onPress={handleRestore} style={{ marginTop: 6, alignItems: 'center' }}>
                      <Text style={{ color: colors.muted, fontSize: 11, textDecorationLine: 'underline' }}>Restore Purchases</Text>
                    </TouchableOpacity>
                  </>
                )}
              </View>

              {/* ===== SECTION 3.5: VAULT WATCH (Gold-only) ===== */}
              <View onLayout={(e) => { sectionOffsets.current['vaultWatch'] = e.nativeEvent.layout.y; }}>
              {(() => {
                const vaultMetalsAll = [
                  { key: 'silver', label: 'Ag', color: '#C0C0C0' },
                  { key: 'gold', label: 'Au', color: '#D4A843' },
                  { key: 'platinum', label: 'Pt', color: '#A8D8EA' },
                  { key: 'palladium', label: 'Pd', color: '#4CAF50' },
                ];
                // Only show tabs for metals that have meaningful data (at least one row with registered_oz > 0)
                const vaultMetals = vaultMetalsAll.filter(m => {
                  const data = vaultData[m.key] || [];
                  return data.length > 0 && data.some(d => (d.registered_oz || 0) > 0);
                });

                // If current selected metal has no data, auto-switch to first available
                const activeMetal = vaultMetals.some(m => m.key === vaultMetal) ? vaultMetal : (vaultMetals[0]?.key || 'silver');
                if (activeMetal !== vaultMetal) {
                  // Schedule state update after render to avoid setState during render
                  setTimeout(() => setVaultMetal(activeMetal), 0);
                }

                const currentVaultData = vaultData[activeMetal] || [];
                const latestVault = currentVaultData.length > 0 ? currentVaultData[currentVaultData.length - 1] : null;
                const currentVaultColor = (vaultMetalsAll.find(m => m.key === activeMetal) || {}).color || '#D4A843';

                // Format large oz numbers compactly: 101394888 â†’ "101.4M"
                const formatOzCompact = (val) => {
                  if (!val && val !== 0) return 'â€”';
                  const abs = Math.abs(val);
                  if (abs >= 1e9) return `${(val / 1e9).toFixed(1)}B`;
                  if (abs >= 1e6) return `${(val / 1e6).toFixed(1)}M`;
                  if (abs >= 1e3) return `${(val / 1e3).toFixed(0)}K`;
                  return val.toLocaleString();
                };

                // Format change with comma separators
                const formatChangeOz = (val) => {
                  if (!val && val !== 0) return 'â€”';
                  const sign = val > 0 ? '+' : '';
                  return `${sign}${Math.round(val).toLocaleString()} oz`;
                };

                // Chart data for registered inventory trend
                const chartDataPoints = currentVaultData.map(d => d.registered_oz).filter(v => v > 0);
                const chartLabels = currentVaultData.map(d => {
                  const dt = new Date(d.date + 'T00:00:00');
                  return `${dt.getMonth() + 1}/${dt.getDate()}`;
                });
                // Show max 8 labels evenly spaced
                const labelInterval = Math.max(1, Math.floor(chartLabels.length / 7));
                const sparseLabels = chartLabels.map((l, i) => i % labelInterval === 0 || i === chartLabels.length - 1 ? l : '');

                const ratio = latestVault?.oversubscribed_ratio || 0;
                const ratioWarning = ratio > 3.0 ? { icon: '\uD83D\uDD25', label: 'Supply squeeze territory', color: '#F87171' }
                  : ratio > 2.0 ? { icon: '\u26A0\uFE0F', label: 'Elevated', color: '#FBBF24' }
                  : null;

                // Bullish color for inventory decreases (gold accent), gray for increases
                const bullishColor = '#D4A843';
                const bearishColor = colors.muted;

                const getChangeColor = (val) => val < 0 ? bullishColor : val > 0 ? bearishColor : colors.muted;
                const getChangeArrow = (val) => val < 0 ? '\u25BC' : val > 0 ? '\u25B2' : '';

                return (
                  <View style={{ marginBottom: 16 }}>
                      {/* Section header with gold divider */}
                      <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 12, gap: 10 }}>
                        <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', letterSpacing: 1.2, textTransform: 'uppercase', marginLeft: 4 }}>
                          {'\uD83C\uDFE6'} Vault Watch
                        </Text>
                        <View style={{ flex: 1, height: 1, backgroundColor: 'rgba(212,168,67,0.2)' }} />
                      </View>

                      <Text style={{ color: colors.muted, fontSize: 11, marginBottom: 10, marginLeft: 4 }}>COMEX Warehouse Inventory</Text>

                      {/* Metal selector pills */}
                      <View style={{ flexDirection: 'row', gap: 8, marginBottom: 14 }}>
                        {vaultMetals.map(m => (
                          <TouchableOpacity
                            key={m.key}
                            style={{
                              paddingVertical: 6,
                              paddingHorizontal: 14,
                              borderRadius: 16,
                              backgroundColor: activeMetal === m.key ? `${m.color}20` : 'transparent',
                              borderWidth: 1,
                              borderColor: activeMetal === m.key ? m.color : isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
                            }}
                            onPress={() => {
                              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                              setVaultMetal(m.key);
                            }}
                          >
                            <Text style={{ color: activeMetal === m.key ? m.color : colors.muted, fontSize: 13, fontWeight: '700' }}>{m.label}</Text>
                          </TouchableOpacity>
                        ))}
                      </View>

                      {vaultLoading && !latestVault ? (
                        /* Loading skeleton */
                        <View style={{
                          backgroundColor: todayCardBg,
                          borderRadius: 12,
                          borderWidth: 1,
                          borderColor: todayCardBorder,
                          padding: 20,
                        }}>
                          <View style={{ width: '60%', height: 14, backgroundColor: isDarkMode ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)', borderRadius: 4, marginBottom: 12 }} />
                          <View style={{ width: '40%', height: 24, backgroundColor: isDarkMode ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)', borderRadius: 4, marginBottom: 8 }} />
                          <View style={{ width: '80%', height: 10, backgroundColor: isDarkMode ? 'rgba(255,255,255,0.04)' : 'rgba(0,0,0,0.04)', borderRadius: 4 }} />
                        </View>
                      ) : latestVault ? (
                        <View style={{
                          backgroundColor: todayCardBg,
                          borderRadius: 12,
                          borderWidth: 1,
                          borderColor: todayCardBorder,
                          overflow: 'hidden',
                        }}>
                          {/* Key stats */}
                          <View style={{ padding: 16 }}>
                            {/* Registered */}
                            <View style={{ marginBottom: 14 }}>
                              <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', textTransform: 'uppercase', letterSpacing: 0.8, marginBottom: 4 }}>Registered</Text>
                              <View style={{ flexDirection: 'row', alignItems: 'baseline', gap: 10 }}>
                                <Text style={{ color: colors.text, fontSize: 26, fontWeight: '700' }}>{formatOzCompact(latestVault.registered_oz)} oz</Text>
                                {latestVault.registered_change_oz !== 0 && (
                                  <Text style={{ color: getChangeColor(latestVault.registered_change_oz), fontSize: 13, fontWeight: '600' }}>
                                    {getChangeArrow(latestVault.registered_change_oz)} {formatChangeOz(latestVault.registered_change_oz)}
                                  </Text>
                                )}
                              </View>
                            </View>

                            {effHasGoldAccess ? (
                              <>
                                {/* Eligible */}
                                <View style={{ marginBottom: 14 }}>
                                  <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', textTransform: 'uppercase', letterSpacing: 0.8, marginBottom: 4 }}>Eligible</Text>
                                  <View style={{ flexDirection: 'row', alignItems: 'baseline', gap: 10 }}>
                                    <Text style={{ color: latestVault.eligible_oz ? colors.text : colors.muted, fontSize: 20, fontWeight: '600' }}>{latestVault.eligible_oz ? `${formatOzCompact(latestVault.eligible_oz)} oz` : 'N/A'}</Text>
                                    {latestVault.eligible_oz > 0 && latestVault.eligible_change_oz !== 0 && (
                                      <Text style={{ color: getChangeColor(latestVault.eligible_change_oz), fontSize: 12, fontWeight: '600' }}>
                                        {getChangeArrow(latestVault.eligible_change_oz)} {formatChangeOz(latestVault.eligible_change_oz)}
                                      </Text>
                                    )}
                                  </View>
                                </View>

                                {/* Combined */}
                                <View style={{ marginBottom: 14 }}>
                                  <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', textTransform: 'uppercase', letterSpacing: 0.8, marginBottom: 4 }}>Combined</Text>
                                  <Text style={{ color: colors.text, fontSize: 18, fontWeight: '600' }}>{formatOzCompact(latestVault.combined_oz)} oz</Text>
                                </View>

                                {/* Oversubscribed Ratio */}
                                <View style={{ marginBottom: 4 }}>
                                  <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', textTransform: 'uppercase', letterSpacing: 0.8, marginBottom: 4 }}>Oversubscribed Ratio</Text>
                                  {ratio > 0 ? (
                                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
                                      <Text style={{ color: ratio > 2 ? '#FBBF24' : colors.text, fontSize: 24, fontWeight: '700' }}>{ratio.toFixed(1)}x</Text>
                                      {ratioWarning && (
                                        <View style={{
                                          flexDirection: 'row',
                                          alignItems: 'center',
                                          gap: 4,
                                          backgroundColor: `${ratioWarning.color}15`,
                                          borderRadius: 6,
                                          paddingHorizontal: 8,
                                          paddingVertical: 3,
                                        }}>
                                          <Text style={{ fontSize: 12 }}>{ratioWarning.icon}</Text>
                                          <Text style={{ color: ratioWarning.color, fontSize: 11, fontWeight: '600' }}>{ratioWarning.label}</Text>
                                        </View>
                                      )}
                                    </View>
                                  ) : (
                                    <Text style={{ color: colors.muted, fontSize: 24, fontWeight: '700' }}>N/A</Text>
                                  )}
                                </View>
                              </>
                            ) : (
                              <>
                                {/* Eligible - redacted */}
                                <View style={{ marginBottom: 14 }}>
                                  <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', textTransform: 'uppercase', letterSpacing: 0.8, marginBottom: 4 }}>Eligible</Text>
                                  <Text style={{ color: colors.muted, fontSize: 20, fontWeight: '600' }}>{'\u2022\u2022\u2022\u2022\u2022\u2022'} oz</Text>
                                </View>

                                {/* Combined - redacted */}
                                <View style={{ marginBottom: 14 }}>
                                  <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', textTransform: 'uppercase', letterSpacing: 0.8, marginBottom: 4 }}>Combined</Text>
                                  <Text style={{ color: colors.muted, fontSize: 18, fontWeight: '600' }}>{'\u2022\u2022\u2022\u2022\u2022\u2022'} oz</Text>
                                </View>

                                {/* Oversubscribed Ratio - redacted */}
                                <View style={{ marginBottom: 4 }}>
                                  <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', textTransform: 'uppercase', letterSpacing: 0.8, marginBottom: 4 }}>Oversubscribed Ratio</Text>
                                  <Text style={{ color: colors.muted, fontSize: 24, fontWeight: '700' }}>{'\u2022\u2022\u2022'}x</Text>
                                </View>
                              </>
                            )}
                          </View>

                          {/* Divider */}
                          <View style={{ height: 1, backgroundColor: 'rgba(212,168,67,0.15)', marginHorizontal: 16 }} />

                          {/* Mini trend chart */}
                          {chartDataPoints.length >= 2 ? (
                            effHasGoldAccess ? (
                              <View style={{ paddingVertical: 12, paddingHorizontal: 4 }}>
                                <Text style={{ color: colors.muted, fontSize: 10, fontWeight: '600', textTransform: 'uppercase', letterSpacing: 0.8, marginBottom: 8, marginLeft: 12 }}>Registered Inventory (30d)</Text>
                                <ScrubChart
                                  data={currentVaultData.filter(d => d.registered_oz > 0).map(d => ({ date: d.date, value: d.registered_oz }))}
                                  color={currentVaultColor}
                                  width={SCREEN_WIDTH - 56}
                                  height={160}
                                  range="1M"
                                  chartId="vaultWatch"
                                  yFormat={(v) => {
                                    if (v >= 1e9) return `${(v / 1e9).toFixed(1)}B`;
                                    if (v >= 1e6) return `${(v / 1e6).toFixed(1)}M`;
                                    if (v >= 1e3) return `${(v / 1e3).toFixed(0)}K`;
                                    return v.toLocaleString();
                                  }}
                                  tooltipFormat={(v) => `${Math.round(v).toLocaleString()} oz`}
                                />
                              </View>
                            ) : (
                              <TouchableOpacity
                                onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setShowPaywallModal(true); }}
                                style={{ margin: 12, height: 200, borderWidth: 1.5, borderColor: 'rgba(212, 168, 67, 0.3)', borderStyle: 'dashed', borderRadius: 12, justifyContent: 'center', alignItems: 'center', backgroundColor: isDarkMode ? 'rgba(212, 168, 67, 0.03)' : 'rgba(212, 168, 67, 0.05)' }}
                              >
                                <Text style={{ fontSize: 10, fontWeight: '600', textTransform: 'uppercase', letterSpacing: 0.8, color: colors.muted, marginBottom: 12 }}>30-day inventory trend</Text>
                                <Text style={{ fontSize: 28, marginBottom: 8 }}>{'\uD83D\uDD12'}</Text>
                                <Text style={{ color: colors.gold, fontSize: 13, fontWeight: '600' }}>Available with Gold</Text>
                              </TouchableOpacity>
                            )
                          ) : chartDataPoints.length > 0 ? (
                            <View style={{ paddingVertical: 16, paddingHorizontal: 16 }}>
                              <Text style={{ color: colors.muted, fontSize: 12, textAlign: 'center', fontStyle: 'italic' }}>Chart available after 2+ days of data collection</Text>
                            </View>
                          ) : null}

                          {/* Source footer */}
                          <View style={{ paddingHorizontal: 16, paddingBottom: 12, paddingTop: 4 }}>
                            <Text style={{ color: colors.muted, fontSize: 10, opacity: 0.6 }}>Source: CME Group {'\u00B7'} Updated daily</Text>
                          </View>
                        </View>
                      ) : (
                        <View style={{
                          backgroundColor: todayCardBg,
                          borderRadius: 12,
                          borderWidth: 1,
                          borderColor: todayCardBorder,
                          padding: 24,
                          alignItems: 'center',
                        }}>
                          <Text style={{ color: colors.muted, fontSize: 14, textAlign: 'center' }}>Vault data updating...</Text>
                          <Text style={{ color: colors.muted, fontSize: 12, marginTop: 4, textAlign: 'center' }}>Check back soon for COMEX inventory data</Text>
                        </View>
                      )}

                    {!effHasGoldAccess && (
                      <>
                        <TouchableOpacity
                          onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setShowPaywallModal(true); }}
                          style={{ marginTop: 10, borderWidth: 1, borderColor: 'rgba(212, 168, 67, 0.3)', borderRadius: 10, paddingVertical: 10, paddingHorizontal: 16, alignItems: 'center' }}
                        >
                          <Text style={{ color: colors.gold, fontSize: 13, fontWeight: '600' }}>Try Gold free for 7 days</Text>
                          <Text style={{ color: colors.muted, fontSize: 10, marginTop: 2 }}>Then $9.99/mo Â· Cancel anytime</Text>
                        </TouchableOpacity>
                        <TouchableOpacity onPress={handleRestore} style={{ marginTop: 6, alignItems: 'center' }}>
                          <Text style={{ color: colors.muted, fontSize: 11, textDecorationLine: 'underline' }}>Restore Purchases</Text>
                        </TouchableOpacity>
                      </>
                    )}
                  </View>
                );
              })()}
              </View>

              {/* ===== SECTION 4: INTELLIGENCE FEED ===== */}
              <View onLayout={(e) => { sectionOffsets.current['intelligenceFeed'] = e.nativeEvent.layout.y; }} style={{ marginBottom: 16 }}>
                  {/* Section header with gold divider */}
                  <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 12, gap: 10 }}>
                    <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', letterSpacing: 1.2, textTransform: 'uppercase', marginLeft: 4 }}>Market Intelligence</Text>
                    <View style={{ flex: 1, height: 1, backgroundColor: 'rgba(212,168,67,0.2)' }} />
                  </View>

                  {intelligenceLoading && intelligenceBriefs.length === 0 ? (
                    // Loading skeletons
                    <View style={{ gap: 10 }}>
                      {[1, 2, 3].map(i => (
                        <View key={i} style={{
                          backgroundColor: todayCardBg,
                          borderRadius: 12,
                          borderWidth: 1,
                          borderColor: todayCardBorder,
                          padding: 16,
                        }}>
                          <View style={{ width: 60, height: 12, backgroundColor: isDarkMode ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)', borderRadius: 4, marginBottom: 8 }} />
                          <View style={{ width: '80%', height: 14, backgroundColor: isDarkMode ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)', borderRadius: 4, marginBottom: 6 }} />
                          <View style={{ width: '100%', height: 10, backgroundColor: isDarkMode ? 'rgba(255,255,255,0.04)' : 'rgba(0,0,0,0.04)', borderRadius: 4, marginBottom: 4 }} />
                          <View style={{ width: '90%', height: 10, backgroundColor: isDarkMode ? 'rgba(255,255,255,0.04)' : 'rgba(0,0,0,0.04)', borderRadius: 4 }} />
                        </View>
                      ))}
                    </View>
                  ) : intelligenceBriefs.length > 0 ? (
                    <View style={{ gap: 10 }}>
                      {(() => {
                        const visibleBriefs = effHasGoldAccess
                          ? (intelligenceExpanded ? intelligenceBriefs : intelligenceBriefs.slice(0, 3))
                          : intelligenceBriefs.slice(0, 1);
                        return visibleBriefs.map((brief, i) => (
                        <TouchableOpacity
                          key={brief.id || i}
                          style={{
                            backgroundColor: todayCardBg,
                            borderRadius: 12,
                            borderWidth: 1,
                            borderColor: todayCardBorder,
                            padding: 16,
                          }}
                          onPress={() => {
                            if (brief.source_url) {
                              Linking.openURL(brief.source_url);
                            }
                          }}
                          activeOpacity={brief.source_url ? 0.7 : 1}
                        >
                          {/* Category tag */}
                          <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8, marginBottom: 8 }}>
                            <View style={{
                              backgroundColor: `${categoryColors[brief.category] || '#D4A843'}20`,
                              borderRadius: 4,
                              paddingHorizontal: 6,
                              paddingVertical: 2,
                            }}>
                              <Text style={{ color: categoryColors[brief.category] || '#D4A843', fontSize: 10, fontWeight: '700', textTransform: 'uppercase' }}>
                                {categoryLabels[brief.category] || brief.category}
                              </Text>
                            </View>
                            {brief.source && (
                              <Text style={{ color: colors.muted, fontSize: 10 }}>{brief.source}</Text>
                            )}
                          </View>

                          {/* Title */}
                          <Text style={{ color: colors.text, fontSize: 15, fontWeight: '600', marginBottom: 6, lineHeight: 20 }}>{brief.title}</Text>

                          {/* Summary */}
                          <Text style={{ color: colors.muted, fontSize: 13, lineHeight: 18 }} numberOfLines={3}>{brief.summary}</Text>
                        </TouchableOpacity>
                        ));
                      })()}

                      {/* "See all" link for Gold users with more than 3 briefs */}
                      {effHasGoldAccess && intelligenceBriefs.length > 3 && !intelligenceExpanded && (
                        <TouchableOpacity
                          onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setIntelligenceExpanded(true); }}
                          style={{ paddingVertical: 8, alignItems: 'center' }}
                        >
                          <Text style={{ color: '#D4A843', fontSize: 14, fontWeight: '600' }}>
                            See all {intelligenceBriefs.length} briefs {'\u2192'}
                          </Text>
                        </TouchableOpacity>
                      )}

                      {/* Gated count card for free users */}
                      {!effHasGoldAccess && intelligenceBriefs.length > 1 && (
                        <TouchableOpacity
                          onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setShowPaywallModal(true); }}
                          style={{
                            backgroundColor: todayCardBg,
                            borderRadius: 12,
                            borderWidth: 1,
                            borderColor: 'rgba(212, 168, 67, 0.3)',
                            padding: 20,
                            alignItems: 'center',
                          }}
                        >
                          <Text style={{ fontSize: 24, marginBottom: 8 }}>{'\uD83D\uDD12'}</Text>
                          <Text style={{ color: colors.text, fontSize: 15, fontWeight: '600', marginBottom: 6 }}>
                            {intelligenceBriefs.length - 1} more market brief{intelligenceBriefs.length - 1 > 1 ? 's' : ''} today
                          </Text>
                          <Text style={{ color: colors.gold, fontSize: 13, fontWeight: '600' }}>Try Gold free for 7 days</Text>
                          <Text style={{ color: colors.muted, fontSize: 10, marginTop: 2 }}>Then $9.99/mo {'\u00B7'} Cancel anytime</Text>
                        </TouchableOpacity>
                      )}
                    </View>
                  ) : (
                    <View style={{
                      backgroundColor: todayCardBg,
                      borderRadius: 12,
                      borderWidth: 1,
                      borderColor: todayCardBorder,
                      padding: 24,
                      alignItems: 'center',
                    }}>
                      <Text style={{ color: colors.muted, fontSize: 14, textAlign: 'center' }}>Intelligence feed updating...</Text>
                      <Text style={{ color: colors.muted, fontSize: 12, marginTop: 4, textAlign: 'center' }}>Check back soon for today's market briefs</Text>
                    </View>
                  )}
              </View>

              {/* Troy advisor section removed â€” now accessible via FAB */}

              {/* ===== SECTION 5: FOOTER ===== */}
              <View style={{ alignItems: 'center', paddingVertical: 24, marginBottom: 20 }}>
                <Text style={{ color: colors.muted, fontSize: 11, opacity: 0.6 }}>Powered by Stack Tracker Gold</Text>
                <Text style={{ color: colors.muted, fontSize: 10, opacity: 0.4, marginTop: 4 }}>Intelligence updates daily at 6:30 AM EST</Text>
              </View>

            </View>
          );
        })()}

        {/* PORTFOLIO TAB */}
        {tab === 'portfolio' && (
          <>
            {/* Portfolio Summary Card */}
            <View onLayout={(e) => { sectionOffsets.current['portfolioSummary'] = e.nativeEvent.layout.y; }} style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
              <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.large }]}>Portfolio Value</Text>
              <Text
                style={{ color: colors.text, fontSize: Math.round(32 * fontScale), fontWeight: '700', marginBottom: 4 }}
                numberOfLines={1}
                adjustsFontSizeToFit={true}
              >
                ${formatSmartCurrency(demoData ? demoData.totalMeltValue : totalMeltValue)}
              </Text>
              {demoData ? (
                <Text
                  style={{ color: colors.success, fontSize: scaledFonts.medium }}
                  numberOfLines={1}
                  adjustsFontSizeToFit={true}
                >
                  â–² +${formatSmartCurrency(demoData.dailyChange)} (+{demoData.dailyChangePct.toFixed(2)}%)
                </Text>
              ) : showDailyChange ? (
                <Text
                  style={{ color: isDailyChangePositive ? colors.success : colors.error, fontSize: scaledFonts.medium }}
                  numberOfLines={1}
                  adjustsFontSizeToFit={true}
                >
                  {isDailyChangePositive ? 'â–²' : 'â–¼'} {isDailyChangePositive ? '+' : ''}{dailyChange >= 0 ? '' : '-'}${formatSmartCurrency(Math.abs(dailyChange))} ({isDailyChangePositive ? '+' : ''}{dailyChangePct.toFixed(2)}%)
                </Text>
              ) : (
                <Text style={{ color: colors.muted, fontSize: scaledFonts.small }}>
                  {!spotPricesLive ? 'Waiting for live prices...' : 'Daily change available tomorrow'}
                </Text>
              )}
            </View>

            {/* Segmented Control Filter */}
            <View onLayout={(e) => { sectionOffsets.current['holdings'] = e.nativeEvent.layout.y; }} style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 12, gap: 10 }}>
              <View style={{
                flex: 1,
                flexDirection: 'row',
                backgroundColor: isDarkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)',
                borderRadius: 10,
                padding: 3,
              }}>
                {[
                  { key: 'silver', label: 'Silver', color: colors.silver, bgActive: isDarkMode ? 'rgba(156,163,175,0.25)' : '#fff' },
                  { key: 'gold', label: 'Gold', color: colors.gold, bgActive: isDarkMode ? 'rgba(251,191,36,0.2)' : '#fff' },
                  { key: 'platinum', label: 'Pt', color: colors.platinum, bgActive: isDarkMode ? 'rgba(123,179,212,0.2)' : '#fff' },
                  { key: 'palladium', label: 'Pd', color: colors.palladium, bgActive: isDarkMode ? 'rgba(107,191,138,0.2)' : '#fff' },
                  { key: 'both', label: 'All', color: colors.gold, bgActive: isDarkMode ? 'rgba(251,191,36,0.2)' : '#fff' },
                ].map(m => (
                  <TouchableOpacity
                    key={m.key}
                    style={{
                      flex: 1,
                      paddingVertical: 8,
                      borderRadius: 8,
                      alignItems: 'center',
                      backgroundColor: metalTab === m.key ? m.bgActive : 'transparent',
                    }}
                    onPress={() => {
                      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                      setMetalTab(m.key);
                    }}
                  >
                    <Text style={{ color: metalTab === m.key ? m.color : colors.muted, fontWeight: '600', fontSize: 13 }}>{m.label}</Text>
                  </TouchableOpacity>
                ))}
              </View>
              <TouchableOpacity
                style={{
                  width: 36,
                  height: 36,
                  borderRadius: 10,
                  backgroundColor: isDarkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
                onPress={() => {
                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                  setShowSortMenu(true);
                }}
              >
                <SortIcon size={20} color={colors.muted} />
              </TouchableOpacity>
            </View>

            <View style={{ flexDirection: 'row', gap: 8, marginBottom: 16 }}>
              <TouchableOpacity style={[styles.button, { flex: 1, backgroundColor: colors.gold }]} onPress={handleAddPurchase}>
                <Text style={{ color: '#000', fontWeight: '600', fontSize: scaledFonts.normal }}>+ Add Purchase</Text>
              </TouchableOpacity>
              <TouchableOpacity style={[styles.buttonOutline, { flex: 1, borderColor: colors.gold, borderWidth: 1.5 }]} onPress={importSpreadsheet}>
                <Text style={{ color: colors.gold, fontWeight: '600', fontSize: scaledFonts.normal }}>Import CSV</Text>
              </TouchableOpacity>
            </View>

            {/* Show filtered items or both with grouping */}
            {metalTab !== 'both' ? (
              <>
                {/* Section summary card for single metal view */}
                {items.length > 0 && (
                  <View style={{ backgroundColor: isDarkMode ? 'rgba(255,255,255,0.04)' : 'rgba(0,0,0,0.03)', borderRadius: 12, padding: 14, marginBottom: 14, marginTop: 8, borderWidth: 1, borderColor: isDarkMode ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)' }}>
                    <Text style={{ color: currentColor, fontWeight: '700', fontSize: scaledFonts.normal, marginBottom: 4 }}>
                      {{ silver: 'Silver', gold: 'Gold', platinum: 'Platinum', palladium: 'Palladium' }[metalTab] || metalTab} Summary
                    </Text>
                    <Text style={{ color: colors.muted, fontSize: scaledFonts.small, marginBottom: 2 }}>
                      {items.length} {items.length === 1 ? 'purchase' : 'purchases'} â€¢ {formatOunces(items.reduce((sum, i) => sum + i.ozt * i.quantity, 0), metalTab === 'silver' ? 2 : 3)} oz
                    </Text>
                    <Text style={{ color: colors.text, fontSize: scaledFonts.normal, fontWeight: '600' }}>
                      Value: ${formatSmartCurrency(items.reduce((sum, i) => sum + i.ozt * i.quantity * spot, 0))}
                    </Text>
                  </View>
                )}
                {sortItems(items, metalTab).map((item, index) => {
                  const itemPremiumPct = calculatePremiumPercent(item.premium, item.unitPrice);
                  const meltValue = item.ozt * item.quantity * spot;
                  const costBasis = getItemCostBasis(item);
                  const gainLoss = meltValue - costBasis;
                  const gainLossPct = costBasis > 0 ? (gainLoss / costBasis) * 100 : 0;
                  const isGain = gainLoss >= 0;
                  return (
                    <TouchableOpacity
                      key={item.supabase_id || `${item.id}-${index}`}
                      style={[styles.itemCard, { backgroundColor: isDarkMode ? 'rgba(0,0,0,0.2)' : `${colors.gold}15`, borderColor: isDarkMode ? 'rgba(255,255,255,0.05)' : `${colors.gold}30` }]}
                      onPress={() => viewItemDetail(item, metalTab)}
                      activeOpacity={0.7}
                    >
                      <View style={{ flex: 1 }}>
                        <Text style={[styles.itemTitle, { color: colors.text, fontSize: scaledFonts.normal }]} numberOfLines={1}>{item.productName}</Text>
                        {item.datePurchased && (
                          <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.tiny, marginBottom: 2 }]}>{formatDateDisplay(item.datePurchased)}</Text>
                        )}
                        <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.small }]}>{item.quantity} qty @ ${formatCurrency(item.unitPrice)} â€¢ {formatOunces(item.ozt * item.quantity)} oz</Text>
                        <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.small }]}>
                          Cost: ${formatCurrency(costBasis)}
                        </Text>
                      </View>
                      <View style={{ alignItems: 'flex-end' }}>
                        <Text style={{ fontSize: scaledFonts.tiny, color: colors.muted, marginBottom: 1 }}>Value</Text>
                        <Text style={[styles.itemValue, { color: currentColor, fontSize: scaledFonts.medium }]}>${formatSmartCurrency(meltValue)}</Text>
                        <Text style={{ color: isGain ? colors.success : colors.error, fontSize: scaledFonts.small, fontWeight: '600' }}>
                          {isGain ? '+' : ''}{formatCurrency(gainLoss)} ({isGain ? '+' : ''}{gainLossPct.toFixed(1)}%)
                        </Text>
                      </View>
                    </TouchableOpacity>
                  );
                })}

                {items.length === 0 && (
                  <View style={styles.emptyState}>
                    <Text style={{ fontSize: 32, marginBottom: 16, color: colors.muted }}>â€”</Text>
                    <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>No {metalTab} holdings yet</Text>
                  </View>
                )}
              </>
            ) : (
              <>
                {/* Summary Cards */}
                {(silverItems.length > 0 || goldItems.length > 0 || platinumItems.length > 0 || palladiumItems.length > 0) && (
                  <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12, marginTop: 8, marginBottom: 14 }}>
                    {[
                      { items: silverItems, label: 'Silver', ozt: totalSilverOzt, value: silverMeltValue, color: colors.silver, decimals: 2 },
                      { items: goldItems, label: 'Gold', ozt: totalGoldOzt, value: goldMeltValue, color: colors.gold, decimals: 3 },
                      { items: platinumItems, label: 'Platinum', ozt: totalPlatinumOzt, value: platinumMeltValue, color: colors.platinum, decimals: 3 },
                      { items: palladiumItems, label: 'Palladium', ozt: totalPalladiumOzt, value: palladiumMeltValue, color: colors.palladium, decimals: 3 },
                    ].filter(m => m.items.length > 0).map(m => (
                      <View key={m.label} style={{ width: '47%', backgroundColor: isDarkMode ? 'rgba(255,255,255,0.04)' : 'rgba(0,0,0,0.03)', borderRadius: 12, padding: 14, borderWidth: 1, borderColor: isDarkMode ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)' }}>
                        <Text style={{ color: m.color, fontWeight: '700', fontSize: scaledFonts.normal, marginBottom: 4 }}>{m.label}</Text>
                        <Text style={{ color: colors.muted, fontSize: scaledFonts.small, marginBottom: 2 }}>
                          {m.items.length} {m.items.length === 1 ? 'purchase' : 'purchases'} â€¢ {formatOunces(m.ozt, m.decimals)} oz
                        </Text>
                        <Text style={{ color: colors.text, fontSize: scaledFonts.normal, fontWeight: '600' }}>
                          ${formatSmartCurrency(m.value)}
                        </Text>
                      </View>
                    ))}
                  </View>
                )}

                {/* Silver Items Group */}
                {silverItems.length > 0 && (
                  <>
                    <Text style={{ color: colors.silver, fontWeight: '700', fontSize: scaledFonts.small, marginBottom: 8, marginTop: 4, textTransform: 'uppercase', letterSpacing: 1 }}>
                      Silver ({silverItems.length})
                    </Text>
                    {sortItems(silverItems, 'silver').map((item, index) => {
                      const meltValue = item.ozt * item.quantity * silverSpot;
                      const costBasis = getItemCostBasis(item);
                      const gainLoss = meltValue - costBasis;
                      const gainLossPct = costBasis > 0 ? (gainLoss / costBasis) * 100 : 0;
                      const isGain = gainLoss >= 0;
                      return (
                        <TouchableOpacity
                          key={item.supabase_id || `silver-${item.id}-${index}`}
                          style={[styles.itemCard, { backgroundColor: isDarkMode ? 'rgba(0,0,0,0.2)' : `${colors.gold}15`, borderColor: isDarkMode ? 'rgba(255,255,255,0.05)' : `${colors.gold}30` }]}
                          onPress={() => viewItemDetail(item, 'silver')}
                          activeOpacity={0.7}
                        >
                          <View style={{ flex: 1 }}>
                            <Text style={[styles.itemTitle, { color: colors.text, fontSize: scaledFonts.normal }]} numberOfLines={1}>{item.productName}</Text>
                            {item.datePurchased && (
                              <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.tiny, marginBottom: 2 }]}>{formatDateDisplay(item.datePurchased)}</Text>
                            )}
                            <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.small }]}>{item.quantity} qty @ ${formatCurrency(item.unitPrice)} â€¢ {formatOunces(item.ozt * item.quantity)} oz</Text>
                            <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.small }]}>
                              Cost: ${formatCurrency(costBasis)}
                            </Text>
                          </View>
                          <View style={{ alignItems: 'flex-end' }}>
                            <Text style={{ fontSize: scaledFonts.tiny, color: colors.muted, marginBottom: 1 }}>Value</Text>
                            <Text style={[styles.itemValue, { color: colors.silver, fontSize: scaledFonts.medium }]}>${formatSmartCurrency(meltValue)}</Text>
                            <Text style={{ color: isGain ? colors.success : colors.error, fontSize: scaledFonts.small, fontWeight: '600' }}>
                              {isGain ? '+' : ''}{formatCurrency(gainLoss)} ({isGain ? '+' : ''}{gainLossPct.toFixed(1)}%)
                            </Text>
                          </View>
                        </TouchableOpacity>
                      );
                    })}
                  </>
                )}

                {/* Gold Items Group */}
                {goldItems.length > 0 && (
                  <>
                    <Text style={{ color: colors.gold, fontWeight: '700', fontSize: scaledFonts.small, marginBottom: 8, marginTop: silverItems.length > 0 ? 24 : 4, textTransform: 'uppercase', letterSpacing: 1 }}>
                      Gold ({goldItems.length})
                    </Text>
                    {sortItems(goldItems, 'gold').map((item, index) => {
                      const meltValue = item.ozt * item.quantity * goldSpot;
                      const costBasis = getItemCostBasis(item);
                      const gainLoss = meltValue - costBasis;
                      const gainLossPct = costBasis > 0 ? (gainLoss / costBasis) * 100 : 0;
                      const isGain = gainLoss >= 0;
                      return (
                        <TouchableOpacity
                          key={item.supabase_id || `gold-${item.id}-${index}`}
                          style={[styles.itemCard, { backgroundColor: isDarkMode ? 'rgba(0,0,0,0.2)' : `${colors.gold}15`, borderColor: isDarkMode ? 'rgba(255,255,255,0.05)' : `${colors.gold}30` }]}
                          onPress={() => viewItemDetail(item, 'gold')}
                          activeOpacity={0.7}
                        >
                          <View style={{ flex: 1 }}>
                            <Text style={[styles.itemTitle, { color: colors.text, fontSize: scaledFonts.normal }]} numberOfLines={1}>{item.productName}</Text>
                            {item.datePurchased && (
                              <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.tiny, marginBottom: 2 }]}>{formatDateDisplay(item.datePurchased)}</Text>
                            )}
                            <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.small }]}>{item.quantity} qty @ ${formatCurrency(item.unitPrice)} â€¢ {formatOunces(item.ozt * item.quantity)} oz</Text>
                            <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.small }]}>
                              Cost: ${formatCurrency(costBasis)}
                            </Text>
                          </View>
                          <View style={{ alignItems: 'flex-end' }}>
                            <Text style={{ fontSize: scaledFonts.tiny, color: colors.muted, marginBottom: 1 }}>Value</Text>
                            <Text style={[styles.itemValue, { color: colors.gold, fontSize: scaledFonts.medium }]}>${formatSmartCurrency(meltValue)}</Text>
                            <Text style={{ color: isGain ? colors.success : colors.error, fontSize: scaledFonts.small, fontWeight: '600' }}>
                              {isGain ? '+' : ''}{formatCurrency(gainLoss)} ({isGain ? '+' : ''}{gainLossPct.toFixed(1)}%)
                            </Text>
                          </View>
                        </TouchableOpacity>
                      );
                    })}
                  </>
                )}

                {/* Platinum Items Group */}
                {platinumItems.length > 0 && (
                  <>
                    <Text style={{ color: colors.platinum, fontWeight: '700', fontSize: scaledFonts.small, marginBottom: 8, marginTop: (silverItems.length > 0 || goldItems.length > 0) ? 24 : 4, textTransform: 'uppercase', letterSpacing: 1 }}>
                      Platinum ({platinumItems.length})
                    </Text>
                    {sortItems(platinumItems, 'platinum').map((item, index) => {
                      const meltValue = item.ozt * item.quantity * platinumSpot;
                      const costBasis = getItemCostBasis(item);
                      const gainLoss = meltValue - costBasis;
                      const gainLossPct = costBasis > 0 ? (gainLoss / costBasis) * 100 : 0;
                      const isGain = gainLoss >= 0;
                      return (
                        <TouchableOpacity
                          key={item.supabase_id || `platinum-${item.id}-${index}`}
                          style={[styles.itemCard, { backgroundColor: isDarkMode ? 'rgba(0,0,0,0.2)' : `${colors.platinum}15`, borderColor: isDarkMode ? 'rgba(255,255,255,0.05)' : `${colors.platinum}30` }]}
                          onPress={() => viewItemDetail(item, 'platinum')}
                          activeOpacity={0.7}
                        >
                          <View style={{ flex: 1 }}>
                            <Text style={[styles.itemTitle, { color: colors.text, fontSize: scaledFonts.normal }]} numberOfLines={1}>{item.productName}</Text>
                            {item.datePurchased && (
                              <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.tiny, marginBottom: 2 }]}>{formatDateDisplay(item.datePurchased)}</Text>
                            )}
                            <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.small }]}>{item.quantity} qty @ ${formatCurrency(item.unitPrice)} â€¢ {formatOunces(item.ozt * item.quantity)} oz</Text>
                            <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.small }]}>
                              Cost: ${formatCurrency(costBasis)}
                            </Text>
                          </View>
                          <View style={{ alignItems: 'flex-end' }}>
                            <Text style={{ fontSize: scaledFonts.tiny, color: colors.muted, marginBottom: 1 }}>Value</Text>
                            <Text style={[styles.itemValue, { color: colors.platinum, fontSize: scaledFonts.medium }]}>${formatSmartCurrency(meltValue)}</Text>
                            <Text style={{ color: isGain ? colors.success : colors.error, fontSize: scaledFonts.small, fontWeight: '600' }}>
                              {isGain ? '+' : ''}{formatCurrency(gainLoss)} ({isGain ? '+' : ''}{gainLossPct.toFixed(1)}%)
                            </Text>
                          </View>
                        </TouchableOpacity>
                      );
                    })}
                  </>
                )}

                {/* Palladium Items Group */}
                {palladiumItems.length > 0 && (
                  <>
                    <Text style={{ color: colors.palladium, fontWeight: '700', fontSize: scaledFonts.small, marginBottom: 8, marginTop: (silverItems.length > 0 || goldItems.length > 0 || platinumItems.length > 0) ? 24 : 4, textTransform: 'uppercase', letterSpacing: 1 }}>
                      Palladium ({palladiumItems.length})
                    </Text>
                    {sortItems(palladiumItems, 'palladium').map((item, index) => {
                      const meltValue = item.ozt * item.quantity * palladiumSpot;
                      const costBasis = getItemCostBasis(item);
                      const gainLoss = meltValue - costBasis;
                      const gainLossPct = costBasis > 0 ? (gainLoss / costBasis) * 100 : 0;
                      const isGain = gainLoss >= 0;
                      return (
                        <TouchableOpacity
                          key={item.supabase_id || `palladium-${item.id}-${index}`}
                          style={[styles.itemCard, { backgroundColor: isDarkMode ? 'rgba(0,0,0,0.2)' : `${colors.palladium}15`, borderColor: isDarkMode ? 'rgba(255,255,255,0.05)' : `${colors.palladium}30` }]}
                          onPress={() => viewItemDetail(item, 'palladium')}
                          activeOpacity={0.7}
                        >
                          <View style={{ flex: 1 }}>
                            <Text style={[styles.itemTitle, { color: colors.text, fontSize: scaledFonts.normal }]} numberOfLines={1}>{item.productName}</Text>
                            {item.datePurchased && (
                              <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.tiny, marginBottom: 2 }]}>{formatDateDisplay(item.datePurchased)}</Text>
                            )}
                            <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.small }]}>{item.quantity} qty @ ${formatCurrency(item.unitPrice)} â€¢ {formatOunces(item.ozt * item.quantity)} oz</Text>
                            <Text style={[styles.itemSubtitle, { fontSize: scaledFonts.small }]}>
                              Cost: ${formatCurrency(costBasis)}
                            </Text>
                          </View>
                          <View style={{ alignItems: 'flex-end' }}>
                            <Text style={{ fontSize: scaledFonts.tiny, color: colors.muted, marginBottom: 1 }}>Value</Text>
                            <Text style={[styles.itemValue, { color: colors.palladium, fontSize: scaledFonts.medium }]}>${formatSmartCurrency(meltValue)}</Text>
                            <Text style={{ color: isGain ? colors.success : colors.error, fontSize: scaledFonts.small, fontWeight: '600' }}>
                              {isGain ? '+' : ''}{formatCurrency(gainLoss)} ({isGain ? '+' : ''}{gainLossPct.toFixed(1)}%)
                            </Text>
                          </View>
                        </TouchableOpacity>
                      );
                    })}
                  </>
                )}

                {/* Empty state */}
                {silverItems.length === 0 && goldItems.length === 0 && platinumItems.length === 0 && palladiumItems.length === 0 && (
                  <View style={styles.emptyState}>
                    <Text style={{ fontSize: 32, marginBottom: 16, color: colors.muted }}>â€”</Text>
                    <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>No holdings yet</Text>
                  </View>
                )}
              </>
            )}
          </>
        )}

        {/* TOOLS TAB */}
        {tab === 'tools' && (
          <>
                {/* Price Alerts */}
                <View onLayout={(e) => { sectionOffsets.current['priceAlerts'] = e.nativeEvent.layout.y; }}>
                <TouchableOpacity
                  style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}
                  onPress={() => {
                    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                    setShowAddAlertModal(true);
                  }}
                >
                  <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6 }}><View style={{ width: 18, height: 18, justifyContent: 'center', alignItems: 'center' }}><BellIcon size={18} color={colors.gold} /></View><Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium, marginBottom: 0 }]}>Price Alerts</Text></View>
                    {priceAlerts.length > 0 && (
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny }}>{priceAlerts.length} active</Text>
                    )}
                  </View>
                  <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Set alerts for gold and silver price targets</Text>
                </TouchableOpacity>
                </View>

                <View onLayout={(e) => { sectionOffsets.current['speculationTool'] = e.nativeEvent.layout.y; }}>
                <TouchableOpacity style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]} onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setShowSpeculationModal(true); }}>
                  <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6 }}><View style={{ width: 18, height: 18, justifyContent: 'center', alignItems: 'center' }}><TrendingUpIcon size={18} color={colors.gold} /></View><Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium, marginBottom: 0 }]}>Speculation Tool</Text></View>
                  <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>What if silver hits $100? What if gold hits $10,000?</Text>
                </TouchableOpacity>
                </View>

                <View onLayout={(e) => { sectionOffsets.current['junkSilver'] = e.nativeEvent.layout.y; }}>
                <TouchableOpacity style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]} onPress={() => setShowJunkCalcModal(true)}>
                  <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6 }}><View style={{ width: 18, height: 18, justifyContent: 'center', alignItems: 'center' }}><CalculatorIcon size={18} color={colors.gold} /></View><Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium, marginBottom: 0 }]}>Junk Silver Calculator</Text></View>
                  <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Calculate melt value of constitutional silver</Text>
                </TouchableOpacity>
                </View>

                {/* Stack Milestones - Tappable to Edit */}
                <View onLayout={(e) => { sectionOffsets.current['stackMilestones'] = e.nativeEvent.layout.y; }}>
                <TouchableOpacity
                  activeOpacity={0.7}
                  onPress={() => {
                    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                    setTempSilverMilestone(customSilverMilestone?.toString() || '');
                    setTempGoldMilestone(customGoldMilestone?.toString() || '');
                    setShowMilestoneModal(true);
                  }}
                >
                  <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                      <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6 }}><View style={{ width: 18, height: 18, justifyContent: 'center', alignItems: 'center' }}><TrophyIcon size={18} color={colors.gold} /></View><Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium, marginBottom: 0 }]}>Stack Milestones</Text></View>
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny }}>Tap to edit</Text>
                    </View>
                    <ProgressBar value={totalSilverOzt} max={nextSilverMilestone} color={colors.silver} label={`Silver: ${formatOunces(totalSilverOzt, 0)} / ${nextSilverMilestone} oz${customSilverMilestone ? ' (custom)' : ''}`} />
                    <ProgressBar value={totalGoldOzt} max={nextGoldMilestone} color={colors.gold} label={`Gold: ${formatOunces(totalGoldOzt, 2)} / ${nextGoldMilestone} oz${customGoldMilestone ? ' (custom)' : ''}`} />
                  </View>
                </TouchableOpacity>
                </View>

                {/* Share My Stack - Inline Card */}
                <View onLayout={(e) => { sectionOffsets.current['shareMyStack'] = e.nativeEvent.layout.y; }}>
                {(silverItems.length > 0 || goldItems.length > 0 || platinumItems.length > 0 || palladiumItems.length > 0) && (() => {
                  const shareMetals = [
                    { label: 'Gold', symbol: 'Au', ozt: totalGoldOzt, spot: goldSpot, color: '#D4A843', decimals: 3, value: totalGoldOzt * goldSpot },
                    { label: 'Silver', symbol: 'Ag', ozt: totalSilverOzt, spot: silverSpot, color: '#9ca3af', decimals: 2, value: totalSilverOzt * silverSpot },
                    { label: 'Platinum', symbol: 'Pt', ozt: totalPlatinumOzt, spot: platinumSpot, color: '#7BB3D4', decimals: 3, value: totalPlatinumOzt * platinumSpot },
                    { label: 'Palladium', symbol: 'Pd', ozt: totalPalladiumOzt, spot: palladiumSpot, color: '#6BBF8A', decimals: 3, value: totalPalladiumOzt * palladiumSpot },
                  ].filter(m => m.ozt > 0);
                  return (
                    <View style={{ position: 'relative' }}>
                      <ViewShot
                        ref={shareViewRef}
                        options={{ format: 'png', quality: 1.0, result: 'tmpfile' }}
                      >
                        <View style={{
                          backgroundColor: '#111111',
                          borderRadius: 16,
                          overflow: 'hidden',
                        }}>
                          {/* Gold accent line */}
                          <View style={{ height: 2, backgroundColor: '#D4A843' }} />

                          <View style={{ padding: 20, paddingTop: 16 }}>
                            {/* App icon + title */}
                            <View style={{ alignItems: 'center', marginBottom: 12 }}>
                              <Image source={require('./assets/icon.png')} style={{ width: 44, height: 44, borderRadius: 10, marginBottom: 8 }} />
                              <Text style={{ color: '#ffffff', fontSize: 13, fontWeight: '700', letterSpacing: 3, textTransform: 'uppercase' }}>My Stack</Text>
                            </View>

                            {/* Portfolio value */}
                            <Text style={{ color: '#ffffff', fontSize: 36, fontWeight: '700', textAlign: 'center', marginBottom: 8 }}>${formatCurrency(totalMeltValue, 0)}</Text>

                            {/* Colored dots for held metals */}
                            <View style={{ flexDirection: 'row', justifyContent: 'center', gap: 8, marginBottom: 16 }}>
                              {shareMetals.map(m => (
                                <View key={m.label} style={{ width: 10, height: 10, borderRadius: 5, backgroundColor: m.color }} />
                              ))}
                            </View>

                            {/* Gold divider */}
                            <View style={{ height: 1, backgroundColor: 'rgba(212,168,67,0.4)', marginBottom: 16 }} />

                            {/* Metal rows */}
                            {shareMetals.map(m => {
                              const pct = totalMeltValue > 0 ? ((m.value / totalMeltValue) * 100).toFixed(0) : '0';
                              return (
                                <View key={m.label} style={{ marginBottom: 12 }}>
                                  <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
                                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
                                      <View style={{ width: 10, height: 10, borderRadius: 5, backgroundColor: m.color }} />
                                      <Text style={{ color: '#ffffff', fontSize: 15, fontWeight: '600' }}>{m.label}</Text>
                                    </View>
                                    <Text style={{ color: '#ffffff', fontSize: 15, fontWeight: '700' }}>${formatCurrency(m.value, 0)}</Text>
                                  </View>
                                  <Text style={{ color: '#71717a', fontSize: 12, marginLeft: 18, marginTop: 2 }}>{formatOunces(m.ozt, m.decimals)} oz Â· {pct}%</Text>
                                </View>
                              );
                            })}

                            {/* Gold divider */}
                            <View style={{ height: 1, backgroundColor: 'rgba(212,168,67,0.4)', marginTop: 4, marginBottom: 12 }} />

                            {/* Spot prices row */}
                            <View style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'center', gap: 12, marginBottom: 16 }}>
                              {shareMetals.map(m => (
                                <Text key={m.symbol} style={{ color: '#71717a', fontSize: 12, fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace' }}>{m.symbol} ${m.symbol === 'Ag' ? m.spot.toFixed(2) : m.spot.toFixed(0)}</Text>
                              ))}
                            </View>

                            {/* Branding */}
                            <View style={{ alignItems: 'center' }}>
                              <Text style={{ color: '#D4A843', fontSize: 14, fontWeight: '700', marginBottom: 2 }}>stacktrackergold.com</Text>
                              <Text style={{ color: '#52525b', fontSize: 11 }}>Tracked with Stack Tracker Gold</Text>
                            </View>
                          </View>
                        </View>
                      </ViewShot>

                      {/* Share button - outside ViewShot so not captured */}
                      <TouchableOpacity
                        style={{
                          position: 'absolute',
                          top: 14,
                          right: 12,
                          zIndex: 10,
                          width: 36,
                          height: 36,
                          borderRadius: 18,
                          backgroundColor: 'rgba(255,255,255,0.1)',
                          alignItems: 'center',
                          justifyContent: 'center',
                        }}
                        onPress={() => {
                          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                          shareMyStack();
                        }}
                      >
                        <Svg width={18} height={18} viewBox="0 0 24 24" fill="none">
                          <Path d="M12 2L12 16M12 2L8 6M12 2L16 6" stroke="#D4A843" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" />
                          <Path d="M4 14V18C4 19.1 4.9 20 6 20H18C19.1 20 20 19.1 20 18V14" stroke="#D4A843" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" />
                        </Svg>
                      </TouchableOpacity>
                    </View>
                  );
                })()}
                </View>
          </>
        )}

        {/* ANALYTICS TAB */}
        {tab === 'analytics' && (() => {
          const effPortfolioIntel = demoData ? demoData.portfolioIntel : portfolioIntel;
          const effAnalyticsSnapshots = demoData ? demoData.analyticsSnapshots : analyticsSnapshots;
          const effHasGoldAccess = demoData ? true : hasGoldAccess;
          const effAnalyticsLoading = demoData ? false : analyticsLoading;
          const effPortfolioIntelLoading = demoData ? false : portfolioIntelLoading;
          const effGoldSpotA = demoData ? demoData.goldSpot : goldSpot;
          const effSilverSpotA = demoData ? demoData.silverSpot : silverSpot;
          const effPlatinumSpotA = demoData ? demoData.platinumSpot : platinumSpot;
          const effPalladiumSpotA = demoData ? demoData.palladiumSpot : palladiumSpot;
          const effTotalMeltValueA = demoData ? demoData.totalMeltValue : totalMeltValue;
          return (
          <>
            {/* Inline upgrade bar for non-Gold */}
            {!effHasGoldAccess && (
              <>
                <TouchableOpacity
                  onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setShowPaywallModal(true); }}
                  style={{ marginHorizontal: 2, marginBottom: 8, borderWidth: 1, borderColor: 'rgba(212, 168, 67, 0.3)', borderRadius: 10, paddingVertical: 10, paddingHorizontal: 16, alignItems: 'center', backgroundColor: 'rgba(212, 168, 67, 0.05)' }}
                >
                  <Text style={{ color: colors.gold, fontSize: 13, fontWeight: '600' }}>Try Gold free for 7 days</Text>
                  <Text style={{ color: colors.muted, fontSize: 10, marginTop: 2 }}>Then $9.99/mo Â· Cancel anytime</Text>
                </TouchableOpacity>
                <TouchableOpacity onPress={handleRestore} style={{ marginTop: 6, alignItems: 'center', marginBottom: 4 }}>
                  <Text style={{ color: colors.muted, fontSize: 11, textDecorationLine: 'underline' }}>Restore Purchases</Text>
                </TouchableOpacity>
              </>
            )}

            {/* Portfolio Intelligence */}
            {effHasGoldAccess ? (
              <View style={{
                backgroundColor: colors.cardBg,
                borderRadius: 16,
                borderWidth: 1,
                borderColor: colors.border,
                borderLeftWidth: 3,
                borderLeftColor: '#D4A843',
                padding: 16,
                marginHorizontal: 16,
                marginBottom: 12,
              }}>
                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 8 }}>
                  <TroyCoinIcon size={20} />
                  <Text style={{ color: colors.muted, fontSize: 12, fontWeight: '600' }}>Troy's Analysis</Text>
                </View>
                {effPortfolioIntelLoading ? (
                  <ActivityIndicator size="small" color="#D4A843" style={{ paddingVertical: 8 }} />
                ) : effPortfolioIntel && effPortfolioIntel.text ? (
                  <>
                    <Text style={{ color: colors.text, fontSize: 14, lineHeight: 20 }} numberOfLines={portfolioIntelExpanded ? undefined : 2}>{effPortfolioIntel.text}</Text>
                    <TouchableOpacity onPress={() => setPortfolioIntelExpanded(!portfolioIntelExpanded)} style={{ marginTop: 4, paddingVertical: 12 }}>
                      <Text style={{ color: '#D4A843', fontSize: 15, fontWeight: '700' }}>{portfolioIntelExpanded ? 'See less' : 'See more'}</Text>
                    </TouchableOpacity>
                    {portfolioIntelExpanded && <Text style={{ color: '#666', fontSize: 11, fontStyle: 'italic' }}>Troy is AI-powered. Not financial advice.</Text>}
                  </>
                ) : (
                  <Text style={{ color: colors.muted, fontSize: 13, fontStyle: 'italic' }}>
                    Troy's analysis will be available after 6:30 AM EST.
                  </Text>
                )}
              </View>
            ) : effPortfolioIntel && effPortfolioIntel.text ? (
              <View style={{
                backgroundColor: colors.cardBg,
                borderRadius: 16,
                borderWidth: 1,
                borderColor: colors.border,
                borderLeftWidth: 3,
                borderLeftColor: '#D4A843',
                padding: 16,
                marginHorizontal: 16,
                marginBottom: 12,
              }}>
                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 8 }}>
                  <TroyCoinIcon size={20} />
                  <Text style={{ color: colors.muted, fontSize: 12, fontWeight: '600' }}>Troy's Analysis</Text>
                </View>
                <View style={{ maxHeight: 60, overflow: 'hidden' }}>
                  <Text style={{ color: colors.text, fontSize: 14, lineHeight: 20 }}>{effPortfolioIntel.text}</Text>
                </View>
                {/* Gradient fade overlay */}
                <View style={{ height: 40, marginTop: -40 }}>
                  <View style={{ flex: 1, backgroundColor: colors.cardBg, opacity: 0 }} />
                  <View style={{ flex: 1, backgroundColor: colors.cardBg, opacity: 0.4 }} />
                  <View style={{ flex: 1, backgroundColor: colors.cardBg, opacity: 0.7 }} />
                  <View style={{ flex: 1, backgroundColor: colors.cardBg, opacity: 0.95 }} />
                </View>
                <TouchableOpacity onPress={() => setShowPaywallModal(true)} style={{ marginTop: 4 }}>
                  <Text style={{ color: '#D4A843', fontSize: 13, fontWeight: '600' }}>Unlock Troy's full portfolio analysis with Gold â†’</Text>
                </TouchableOpacity>
              </View>
            ) : (
              <TouchableOpacity
                style={{
                  backgroundColor: colors.cardBg,
                  borderRadius: 16,
                  borderWidth: 1,
                  borderColor: colors.border,
                  borderLeftWidth: 3,
                  borderLeftColor: '#D4A843',
                  padding: 16,
                  marginHorizontal: 16,
                  marginBottom: 12,
                }}
                onPress={() => setShowPaywallModal(true)}
              >
                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 4 }}>
                  <TroyCoinIcon size={20} />
                  <Text style={{ color: colors.muted, fontSize: 12, fontWeight: '600' }}>Troy's Analysis</Text>
                </View>
                <Text style={{ color: colors.muted, fontSize: 13 }}>
                  Get Troy's portfolio analysis with Gold
                </Text>
                <View style={{ flexDirection: 'row', alignItems: 'center', marginTop: 6, backgroundColor: 'rgba(251,191,36,0.15)', alignSelf: 'flex-start', paddingHorizontal: 8, paddingVertical: 3, borderRadius: 4 }}>
                  <Text style={{ color: colors.gold, fontSize: 11, fontWeight: '600' }}>UPGRADE</Text>
                </View>
              </TouchableOpacity>
            )}

            {/* Analytics Content */}
            <View>
              <>
                {/* Portfolio Value Chart */}
                <View onLayout={(e) => { sectionOffsets.current['portfolioValueChart'] = e.nativeEvent.layout.y; }} style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
                  <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 }}>
                    <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Portfolio Value</Text>
                    {effAnalyticsSnapshots.length > 1 && (() => {
                      const first = effAnalyticsSnapshots[0].total_value || 0;
                      const last = effAnalyticsSnapshots[effAnalyticsSnapshots.length - 1].total_value || 0;
                      const pct = first > 0 ? ((last - first) / first * 100) : 0;
                      return (
                        <Text style={{ color: pct >= 0 ? '#4CAF50' : '#F44336', fontSize: scaledFonts.small, fontWeight: '600' }}>
                          {pct >= 0 ? '+' : ''}{pct.toFixed(1)}%
                        </Text>
                      );
                    })()}
                  </View>

                  {/* Time Range Pills */}
                  <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8, marginBottom: 12 }}>
                    {['1M', '3M', '6M', '1Y', '5Y', 'ALL'].map((range) => (
                      <TouchableOpacity
                        key={range}
                        style={{
                          paddingHorizontal: 14,
                          paddingVertical: 6,
                          borderRadius: 8,
                          backgroundColor: analyticsRange === range ? colors.gold : (isDarkMode ? '#27272a' : '#f4f4f5'),
                        }}
                        onPress={() => {
                          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                          setAnalyticsRange(range);
                        }}
                      >
                        <Text style={{
                          color: analyticsRange === range ? '#000' : colors.text,
                          fontWeight: analyticsRange === range ? '600' : '400',
                          fontSize: scaledFonts.small,
                        }}>
                          {range === 'ALL' ? 'All' : range}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>

                  {effAnalyticsLoading ? (
                    <View style={{ alignItems: 'center', paddingVertical: 30 }}>
                      <ActivityIndicator size="small" color={colors.gold} />
                    </View>
                  ) : effAnalyticsSnapshots.length > 1 ? (
                    <View style={{ marginTop: 4 }}>
                      <ScrubChart
                        data={effAnalyticsSnapshots.map(s => ({ date: s.date, value: s.total_value || 0 }))}
                        color="#D4A843"
                        fillColor="rgba(212, 168, 67, 0.15)"
                        width={SCREEN_WIDTH - 80}
                        height={190}
                        range={analyticsRange}
                        decimalPlaces={0}
                        chartId="portfolio"
                      />
                    </View>
                  ) : (
                    <View style={{ alignItems: 'center', paddingVertical: 40 }}>
                      <Text style={{ color: colors.muted, textAlign: 'center', fontSize: scaledFonts.normal }}>
                        {silverItems.length === 0 && goldItems.length === 0
                          ? 'Add some holdings to see your portfolio analytics!'
                          : 'Pull down to refresh'}
                      </Text>
                    </View>
                  )}
                </View>

                {/* Spot Price History â€” 4 Individual Metal Charts */}
                <View onLayout={(e) => { sectionOffsets.current['spotPriceHistory'] = e.nativeEvent.layout.y; }} style={{ marginBottom: 10, marginLeft: 4 }}>
                  <Text style={{ color: colors.muted, fontSize: 11, fontWeight: '600', letterSpacing: 1.2, textTransform: 'uppercase' }}>Historical Spot Prices</Text>
                </View>
                {[
                  { key: 'gold', label: 'Gold', spot: effGoldSpotA, color: '#D4A843', fillColor: 'rgba(212, 168, 67, 0.15)' },
                  { key: 'silver', label: 'Silver', spot: effSilverSpotA, color: '#C0C0C0', fillColor: 'rgba(192, 192, 192, 0.15)' },
                  { key: 'platinum', label: 'Platinum', spot: effPlatinumSpotA, color: '#4A90D9', fillColor: 'rgba(74, 144, 217, 0.15)' },
                  { key: 'palladium', label: 'Palladium', spot: effPalladiumSpotA, color: '#6BBF8A', fillColor: 'rgba(107, 191, 138, 0.15)' },
                ].map(metal => {
                  const mState = spotHistoryMetal[metal.key];
                  const mData = mState.data;
                  const mRange = mState.range;
                  const pctChange = mData && mData.length > 1 ? ((mData[mData.length - 1].value - mData[0].value) / mData[0].value * 100) : 0;

                  return (
                    <View key={metal.key} style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
                      {/* Header: metal name + price + % change */}
                      <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 10 }}>
                        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
                          <View style={{ width: 10, height: 10, borderRadius: 5, backgroundColor: metal.color }} />
                          <Text style={{ color: colors.text, fontSize: scaledFonts.medium, fontWeight: '700' }}>{metal.label}</Text>
                          <Text style={{ color: colors.text, fontSize: scaledFonts.normal, fontWeight: '600' }}>${formatCurrency(metal.spot)}</Text>
                        </View>
                        {mData && mData.length > 1 && (
                          <Text style={{ color: pctChange >= 0 ? '#4CAF50' : '#F44336', fontSize: scaledFonts.small, fontWeight: '600' }}>
                            {pctChange >= 0 ? '+' : ''}{pctChange.toFixed(1)}%
                          </Text>
                        )}
                      </View>

                      {/* Time Range Pills */}
                      <View style={{ flexDirection: 'row', gap: 6, marginBottom: 12 }}>
                        {['1M', '3M', '6M', '1Y', '5Y', 'ALL'].map(r => (
                          <TouchableOpacity
                            key={r}
                            style={{
                              paddingHorizontal: 10, paddingVertical: 5, borderRadius: 6,
                              backgroundColor: mRange === r ? metal.color : (isDarkMode ? '#27272a' : '#f4f4f5'),
                            }}
                            onPress={() => {
                              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                              setMetalRange(metal.key, r);
                            }}
                          >
                            <Text style={{ color: mRange === r ? '#000' : colors.text, fontWeight: mRange === r ? '600' : '400', fontSize: 12 }}>
                              {r === 'ALL' ? 'All' : r}
                            </Text>
                          </TouchableOpacity>
                        ))}
                      </View>

                      {/* Chart Area */}
                      {mState.loading ? (
                        <View style={{ alignItems: 'center', paddingVertical: 30 }}>
                          <ActivityIndicator size="small" color={metal.color} />
                        </View>
                      ) : mState.error ? (
                        <View style={{ alignItems: 'center', paddingVertical: 30 }}>
                          <Text style={{ color: colors.muted, fontSize: scaledFonts.normal, textAlign: 'center' }}>{mState.error === 'no_data' ? 'No data available for this range' : mState.error}</Text>
                        </View>
                      ) : mData && mData.length > 1 ? (
                        <View style={{ marginTop: 8 }}>
                          <ScrubChart
                            data={mData}
                            color={metal.color}
                            fillColor={metal.fillColor}
                            width={SCREEN_WIDTH - 80}
                            height={175}
                            range={mRange}
                            decimalPlaces={metal.key === 'silver' ? 1 : 0}
                            chartId={metal.key}
                          />
                        </View>
                      ) : (
                        <View style={{ alignItems: 'center', paddingVertical: 30 }}>
                          <Text style={{ color: colors.muted, fontSize: scaledFonts.normal, textAlign: 'center' }}>No data available</Text>
                        </View>
                      )}
                    </View>
                  );
                })}

                {/* Holdings Breakdown */}
                <View onLayout={(e) => { sectionOffsets.current['holdingsBreakdown'] = e.nativeEvent.layout.y; }} style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
                  <Text style={[styles.cardTitle, { color: colors.text, marginBottom: 12, fontSize: scaledFonts.medium }]}>Holdings Breakdown</Text>
                  {effTotalMeltValueA > 0 ? (
                    effHasGoldAccess ? (
                      <PieChart
                        data={(demoData ? [
                          { label: 'Gold', value: 68.2 * demoData.goldSpot, color: colors.gold },
                          { label: 'Silver', value: 1420 * demoData.silverSpot, color: colors.silver },
                          { label: 'Platinum', value: 7.5 * demoData.platinumSpot, color: colors.platinum },
                          { label: 'Palladium', value: 3.0 * demoData.palladiumSpot, color: colors.palladium },
                        ] : [
                          { label: 'Gold', value: goldMeltValue, color: colors.gold },
                          { label: 'Silver', value: silverMeltValue, color: colors.silver },
                          { label: 'Platinum', value: platinumMeltValue, color: colors.platinum },
                          { label: 'Palladium', value: palladiumMeltValue, color: colors.palladium },
                        ]).filter(d => d.value > 0)}
                        size={160}
                        cardBgColor={colors.cardBg}
                        textColor={colors.text}
                        mutedColor={colors.muted}
                      />
                    ) : (
                      <TouchableOpacity
                        onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setShowPaywallModal(true); }}
                        style={{ height: 180, borderWidth: 1.5, borderColor: 'rgba(212, 168, 67, 0.3)', borderStyle: 'dashed', borderRadius: 12, justifyContent: 'center', alignItems: 'center', backgroundColor: isDarkMode ? 'rgba(212, 168, 67, 0.03)' : 'rgba(212, 168, 67, 0.05)' }}
                      >
                        <Text style={{ fontSize: 28, marginBottom: 8 }}>{'\uD83D\uDD12'}</Text>
                        <Text style={{ color: colors.text, fontSize: 14, fontWeight: '600', marginBottom: 4 }}>Portfolio Breakdown</Text>
                        <Text style={{ color: colors.gold, fontSize: 13, fontWeight: '600' }}>Available with Gold</Text>
                      </TouchableOpacity>
                    )
                  ) : (
                    <View style={{ alignItems: 'center', paddingVertical: 20 }}>
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Add holdings to see breakdown</Text>
                    </View>
                  )}
                </View>

                {/* Cost Basis Intelligence */}
                {effHasGoldAccess && effPortfolioIntel && effPortfolioIntel.costBasis ? (
                  <View style={{ backgroundColor: colors.cardBg, borderRadius: 12, borderWidth: 1, borderColor: colors.border, borderLeftWidth: 3, borderLeftColor: '#D4A843', padding: 14, marginHorizontal: 16, marginBottom: 12 }}>
                    <Text style={{ color: colors.text, fontSize: 13, lineHeight: 19 }} numberOfLines={costBasisIntelExpanded ? undefined : 2}>{effPortfolioIntel.costBasis}</Text>
                    <TouchableOpacity onPress={() => setCostBasisIntelExpanded(!costBasisIntelExpanded)} style={{ marginTop: 4, paddingVertical: 8 }}>
                      <Text style={{ color: '#D4A843', fontSize: 13, fontWeight: '700' }}>{costBasisIntelExpanded ? 'See less' : 'See more'}</Text>
                    </TouchableOpacity>
                    {costBasisIntelExpanded && <Text style={{ color: '#666', fontSize: 11, fontStyle: 'italic' }}>AI-generated analysis. Not financial advice.</Text>}
                  </View>
                ) : null}

                {/* Cost Basis Analysis */}
                <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
                  <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 12 }}>
                    <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Cost Basis Analysis</Text>
                    {!effHasGoldAccess && (
                      <View style={{ flexDirection: 'row', alignItems: 'center', backgroundColor: 'rgba(251, 191, 36, 0.2)', paddingHorizontal: 8, paddingVertical: 3, borderRadius: 4 }}>
                        <Text style={{ color: colors.gold, fontSize: scaledFonts.tiny, fontWeight: '600' }}>GOLD</Text>
                      </View>
                    )}
                  </View>

                  {/* Gold Analysis */}
                  {goldItems.length > 0 && (
                    <View style={{ marginBottom: 16 }}>
                      <Text style={{ color: colors.gold, fontWeight: '600', marginBottom: 8, fontSize: scaledFonts.normal }}>Gold</Text>
                      {(() => {
                        const totalGoldCost = goldItems.reduce((sum, item) => sum + ((item.unitPrice || 0) * (item.quantity || 1)), 0);
                        const goldMeltValue = totalGoldOzt * goldSpot;
                        const goldPL = goldMeltValue - totalGoldCost;
                        const goldPLPercent = totalGoldCost > 0 ? (goldPL / totalGoldCost) * 100 : 0;
                        const avgGoldCostPerOz = totalGoldOzt > 0 ? totalGoldCost / totalGoldOzt : 0;
                        const goldWithPremium = goldItems.filter(i => (i.premium || 0) > 0);
                        const avgGoldPremium = goldWithPremium.length > 0 ? goldWithPremium.reduce((sum, i) => sum + i.premium * i.quantity, 0) / goldWithPremium.reduce((sum, i) => sum + i.quantity, 0) : null;
                        // Redact values for free users
                        const redact = !effHasGoldAccess;
                        return (
                          <>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Total Cost</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(totalGoldCost)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Current Value</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(goldMeltValue)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Avg Cost/oz</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(avgGoldCostPerOz)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Unrealized P/L</Text>
                              <Text style={{ color: redact ? colors.muted : (goldPL >= 0 ? colors.success : colors.error), fontSize: scaledFonts.normal }}>
                                {redact ? '$â€¢â€¢â€¢â€¢â€¢ (â€¢â€¢â€¢%)' : `${goldPL >= 0 ? '+' : ''}$${formatCurrency(goldPL)} (${goldPLPercent >= 0 ? '+' : ''}${goldPLPercent.toFixed(1)}%)`}
                              </Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Avg Premium Over Spot</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{avgGoldPremium === null ? 'N/A' : (redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(avgGoldPremium)}/unit`)}</Text>
                            </View>
                          </>
                        );
                      })()}
                    </View>
                  )}

                  {/* Silver Analysis */}
                  {silverItems.length > 0 && (
                    <View>
                      <Text style={{ color: colors.silver, fontWeight: '600', marginBottom: 8, fontSize: scaledFonts.normal }}>Silver</Text>
                      {(() => {
                        const totalSilverCost = silverItems.reduce((sum, item) => sum + ((item.unitPrice || 0) * (item.quantity || 1)), 0);
                        const silverMeltValue = totalSilverOzt * silverSpot;
                        const silverPL = silverMeltValue - totalSilverCost;
                        const silverPLPercent = totalSilverCost > 0 ? (silverPL / totalSilverCost) * 100 : 0;
                        const avgSilverCostPerOz = totalSilverOzt > 0 ? totalSilverCost / totalSilverOzt : 0;
                        const silverWithPremium = silverItems.filter(i => (i.premium || 0) > 0);
                        const avgSilverPremium = silverWithPremium.length > 0 ? silverWithPremium.reduce((sum, i) => sum + i.premium * i.quantity, 0) / silverWithPremium.reduce((sum, i) => sum + i.quantity, 0) : null;
                        // Redact values for free users
                        const redact = !effHasGoldAccess;
                        return (
                          <>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Total Cost</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(totalSilverCost)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Current Value</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(silverMeltValue)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Avg Cost/oz</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(avgSilverCostPerOz)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Unrealized P/L</Text>
                              <Text style={{ color: redact ? colors.muted : (silverPL >= 0 ? colors.success : colors.error), fontSize: scaledFonts.normal }}>
                                {redact ? '$â€¢â€¢â€¢â€¢â€¢ (â€¢â€¢â€¢%)' : `${silverPL >= 0 ? '+' : ''}$${formatCurrency(silverPL)} (${silverPLPercent >= 0 ? '+' : ''}${silverPLPercent.toFixed(1)}%)`}
                              </Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Avg Premium Over Spot</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{avgSilverPremium === null ? 'N/A' : (redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(avgSilverPremium)}/unit`)}</Text>
                            </View>
                          </>
                        );
                      })()}
                    </View>
                  )}

                  {/* Platinum Analysis */}
                  {platinumItems.length > 0 && (
                    <View style={{ marginTop: 16 }}>
                      <Text style={{ color: colors.platinum, fontWeight: '600', marginBottom: 8, fontSize: scaledFonts.normal }}>Platinum</Text>
                      {(() => {
                        const totalPtCost = platinumItems.reduce((sum, item) => sum + ((item.unitPrice || 0) * (item.quantity || 1)), 0);
                        const ptMeltValue = totalPlatinumOzt * platinumSpot;
                        const ptPL = ptMeltValue - totalPtCost;
                        const ptPLPercent = totalPtCost > 0 ? (ptPL / totalPtCost) * 100 : 0;
                        const avgPtCostPerOz = totalPlatinumOzt > 0 ? totalPtCost / totalPlatinumOzt : 0;
                        const ptWithPremium = platinumItems.filter(i => (i.premium || 0) > 0);
                        const avgPtPremium = ptWithPremium.length > 0 ? ptWithPremium.reduce((sum, i) => sum + i.premium * i.quantity, 0) / ptWithPremium.reduce((sum, i) => sum + i.quantity, 0) : null;
                        const redact = !effHasGoldAccess;
                        return (
                          <>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Total Cost</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(totalPtCost)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Current Value</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(ptMeltValue)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Avg Cost/oz</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(avgPtCostPerOz)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Unrealized P/L</Text>
                              <Text style={{ color: redact ? colors.muted : (ptPL >= 0 ? colors.success : colors.error), fontSize: scaledFonts.normal }}>
                                {redact ? '$â€¢â€¢â€¢â€¢â€¢ (â€¢â€¢â€¢%)' : `${ptPL >= 0 ? '+' : ''}$${formatCurrency(ptPL)} (${ptPLPercent >= 0 ? '+' : ''}${ptPLPercent.toFixed(1)}%)`}
                              </Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Avg Premium Over Spot</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{avgPtPremium === null ? 'N/A' : (redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(avgPtPremium)}/unit`)}</Text>
                            </View>
                          </>
                        );
                      })()}
                    </View>
                  )}

                  {/* Palladium Analysis */}
                  {palladiumItems.length > 0 && (
                    <View style={{ marginTop: 16 }}>
                      <Text style={{ color: colors.palladium, fontWeight: '600', marginBottom: 8, fontSize: scaledFonts.normal }}>Palladium</Text>
                      {(() => {
                        const totalPdCost = palladiumItems.reduce((sum, item) => sum + ((item.unitPrice || 0) * (item.quantity || 1)), 0);
                        const pdMeltValue = totalPalladiumOzt * palladiumSpot;
                        const pdPL = pdMeltValue - totalPdCost;
                        const pdPLPercent = totalPdCost > 0 ? (pdPL / totalPdCost) * 100 : 0;
                        const avgPdCostPerOz = totalPalladiumOzt > 0 ? totalPdCost / totalPalladiumOzt : 0;
                        const pdWithPremium = palladiumItems.filter(i => (i.premium || 0) > 0);
                        const avgPdPremium = pdWithPremium.length > 0 ? pdWithPremium.reduce((sum, i) => sum + i.premium * i.quantity, 0) / pdWithPremium.reduce((sum, i) => sum + i.quantity, 0) : null;
                        const redact = !effHasGoldAccess;
                        return (
                          <>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Total Cost</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(totalPdCost)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Current Value</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(pdMeltValue)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Avg Cost/oz</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(avgPdCostPerOz)}`}</Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Unrealized P/L</Text>
                              <Text style={{ color: redact ? colors.muted : (pdPL >= 0 ? colors.success : colors.error), fontSize: scaledFonts.normal }}>
                                {redact ? '$â€¢â€¢â€¢â€¢â€¢ (â€¢â€¢â€¢%)' : `${pdPL >= 0 ? '+' : ''}$${formatCurrency(pdPL)} (${pdPLPercent >= 0 ? '+' : ''}${pdPLPercent.toFixed(1)}%)`}
                              </Text>
                            </View>
                            <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Avg Premium Over Spot</Text>
                              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{avgPdPremium === null ? 'N/A' : (redact ? '$â€¢â€¢â€¢â€¢â€¢' : `$${formatCurrency(avgPdPremium)}/unit`)}</Text>
                            </View>
                          </>
                        );
                      })()}
                    </View>
                  )}

                  {goldItems.length === 0 && silverItems.length === 0 && platinumItems.length === 0 && palladiumItems.length === 0 && (
                    <Text style={{ color: colors.muted, textAlign: 'center', paddingVertical: 20, fontSize: scaledFonts.normal }}>
                      Add holdings to see cost analysis
                    </Text>
                  )}
                </View>

                {/* Purchase Stats Intelligence */}
                {effHasGoldAccess && effPortfolioIntel && effPortfolioIntel.purchaseStats ? (
                  <View style={{ backgroundColor: colors.cardBg, borderRadius: 12, borderWidth: 1, borderColor: colors.border, borderLeftWidth: 3, borderLeftColor: '#D4A843', padding: 14, marginHorizontal: 16, marginBottom: 12 }}>
                    <Text style={{ color: colors.text, fontSize: 13, lineHeight: 19 }} numberOfLines={purchaseStatsIntelExpanded ? undefined : 2}>{effPortfolioIntel.purchaseStats}</Text>
                    <TouchableOpacity onPress={() => setPurchaseStatsIntelExpanded(!purchaseStatsIntelExpanded)} style={{ marginTop: 4, paddingVertical: 8 }}>
                      <Text style={{ color: '#D4A843', fontSize: 13, fontWeight: '700' }}>{purchaseStatsIntelExpanded ? 'See less' : 'See more'}</Text>
                    </TouchableOpacity>
                    {purchaseStatsIntelExpanded && <Text style={{ color: '#666', fontSize: 11, fontStyle: 'italic' }}>AI-generated analysis. Not financial advice.</Text>}
                  </View>
                ) : null}

                {/* Purchase Stats */}
                <View onLayout={(e) => { sectionOffsets.current['purchaseStatistics'] = e.nativeEvent.layout.y; }} style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
                  <Text style={[styles.cardTitle, { color: colors.text, marginBottom: 12, fontSize: scaledFonts.medium }]}>Purchase Statistics</Text>

                  {(() => {
                    const allItems = [...goldItems, ...silverItems, ...platinumItems, ...palladiumItems];
                    const itemsWithDates = allItems.filter(i => i.datePurchased);
                    const dealers = [...new Set(allItems.map(i => i.source).filter(Boolean))];

                    // Find earliest and latest purchase
                    const sortedByDate = itemsWithDates.sort((a, b) =>
                      new Date(a.datePurchased) - new Date(b.datePurchased)
                    );
                    const firstPurchase = sortedByDate[0]?.datePurchased;
                    const lastPurchase = sortedByDate[sortedByDate.length - 1]?.datePurchased;

                    return (
                      <>
                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 8 }}>
                          <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Total Items</Text>
                          <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{allItems.length}</Text>
                        </View>
                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 8 }}>
                          <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Unique Dealers</Text>
                          <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{dealers.length}</Text>
                        </View>
                        {firstPurchase && (
                          <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 8 }}>
                            <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>First Purchase</Text>
                            <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{firstPurchase}</Text>
                          </View>
                        )}
                        {lastPurchase && lastPurchase !== firstPurchase && (
                          <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 8 }}>
                            <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Latest Purchase</Text>
                            <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{lastPurchase}</Text>
                          </View>
                        )}
                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 8 }}>
                          <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Total Gold</Text>
                          <Text style={{ color: colors.gold, fontSize: scaledFonts.normal }}>{totalGoldOzt.toFixed(4)} oz</Text>
                        </View>
                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: totalPlatinumOzt > 0 || totalPalladiumOzt > 0 ? 8 : 0 }}>
                          <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Total Silver</Text>
                          <Text style={{ color: colors.silver, fontSize: scaledFonts.normal }}>{totalSilverOzt.toFixed(4)} oz</Text>
                        </View>
                        {totalPlatinumOzt > 0 && (
                          <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: totalPalladiumOzt > 0 ? 8 : 0 }}>
                            <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Total Platinum</Text>
                            <Text style={{ color: colors.platinum, fontSize: scaledFonts.normal }}>{totalPlatinumOzt.toFixed(4)} oz</Text>
                          </View>
                        )}
                        {totalPalladiumOzt > 0 && (
                          <View style={{ flexDirection: 'row', justifyContent: 'space-between' }}>
                            <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Total Palladium</Text>
                            <Text style={{ color: colors.palladium, fontSize: scaledFonts.normal }}>{totalPalladiumOzt.toFixed(4)} oz</Text>
                          </View>
                        )}
                      </>
                    );
                  })()}
                </View>

                {/* Break-Even Analysis */}
                <View onLayout={(e) => { sectionOffsets.current['breakEvenAnalysis'] = e.nativeEvent.layout.y; }} style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
                  <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Break-Even Analysis</Text>
                  {totalSilverOzt > 0 && (
                    <View style={{ backgroundColor: `${colors.silver}22`, padding: 12, borderRadius: 8, marginBottom: 8 }}>
                      <Text style={{ color: colors.silver, fontSize: scaledFonts.normal }}>Silver: {effHasGoldAccess ? `$${formatCurrency(silverBreakeven)}` : '$â€¢â€¢â€¢â€¢â€¢'}/oz needed</Text>
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny }}>{silverSpot >= silverBreakeven ? 'Profitable!' : (effHasGoldAccess ? `Need +$${formatCurrency(silverBreakeven - silverSpot)}` : 'Not yet')}</Text>
                    </View>
                  )}
                  {totalGoldOzt > 0 && (
                    <View style={{ backgroundColor: `${colors.gold}22`, padding: 12, borderRadius: 8, marginBottom: 8 }}>
                      <Text style={{ color: colors.gold, fontSize: scaledFonts.normal }}>Gold: {effHasGoldAccess ? `$${formatCurrency(goldBreakeven)}` : '$â€¢â€¢â€¢â€¢â€¢'}/oz needed</Text>
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny }}>{goldSpot >= goldBreakeven ? 'Profitable!' : (effHasGoldAccess ? `Need +$${formatCurrency(goldBreakeven - goldSpot)}` : 'Not yet')}</Text>
                    </View>
                  )}
                  {totalPlatinumOzt > 0 && (
                    <View style={{ backgroundColor: `${colors.platinum}22`, padding: 12, borderRadius: 8, marginBottom: 8 }}>
                      <Text style={{ color: colors.platinum, fontSize: scaledFonts.normal }}>Platinum: {effHasGoldAccess ? `$${formatCurrency(platinumBreakeven)}` : '$â€¢â€¢â€¢â€¢â€¢'}/oz needed</Text>
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny }}>{platinumSpot >= platinumBreakeven ? 'Profitable!' : (effHasGoldAccess ? `Need +$${formatCurrency(platinumBreakeven - platinumSpot)}` : 'Not yet')}</Text>
                    </View>
                  )}
                  {totalPalladiumOzt > 0 && (
                    <View style={{ backgroundColor: `${colors.palladium}22`, padding: 12, borderRadius: 8 }}>
                      <Text style={{ color: colors.palladium, fontSize: scaledFonts.normal }}>Palladium: {effHasGoldAccess ? `$${formatCurrency(palladiumBreakeven)}` : '$â€¢â€¢â€¢â€¢â€¢'}/oz needed</Text>
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny }}>{palladiumSpot >= palladiumBreakeven ? 'Profitable!' : (effHasGoldAccess ? `Need +$${formatCurrency(palladiumBreakeven - palladiumSpot)}` : 'Not yet')}</Text>
                    </View>
                  )}
                </View>

              </>

            </View>
          </>
          );
        })()}

        {/* SETTINGS TAB */}
        {tab === 'settings' && (() => {
          // iOS Settings style colors
          const settingsBg = isDarkMode ? '#000000' : '#f2f2f7';
          const groupBg = isDarkMode ? '#1c1c1e' : '#ffffff';
          const separatorColor = isDarkMode ? '#38383a' : '#c6c6c8';
          const chevronColor = isDarkMode ? '#48484a' : '#c7c7cc';

          // Reusable iOS Settings Row Component
          const SettingsRow = ({ label, value, onPress, isFirst, isLast, showChevron = true, rightElement, subtitle, labelColor }) => (
            <TouchableOpacity
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                justifyContent: 'space-between',
                backgroundColor: groupBg,
                paddingVertical: 12,
                paddingHorizontal: 16,
                minHeight: 44,
                borderTopLeftRadius: isFirst ? 10 : 0,
                borderTopRightRadius: isFirst ? 10 : 0,
                borderBottomLeftRadius: isLast ? 10 : 0,
                borderBottomRightRadius: isLast ? 10 : 0,
              }}
              onPress={onPress}
              disabled={!onPress}
              activeOpacity={onPress ? 0.6 : 1}
            >
              <View style={{ flex: 1 }}>
                <Text style={{ color: labelColor || colors.text, fontSize: scaledFonts.normal }}>{label}</Text>
                {subtitle && <Text style={{ color: colors.muted, fontSize: scaledFonts.small, marginTop: 2 }}>{subtitle}</Text>}
              </View>
              <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
                {value && <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>{value}</Text>}
                {rightElement}
                {showChevron && onPress && <Text style={{ color: chevronColor, fontSize: 18, fontWeight: '600' }}>â€º</Text>}
              </View>
            </TouchableOpacity>
          );

          // Separator between rows
          const RowSeparator = () => (
            <View style={{ backgroundColor: groupBg }}>
              <View style={{ height: 0.5, backgroundColor: separatorColor, marginLeft: 16 }} />
            </View>
          );

          // Section Header
          const SectionHeader = ({ title }) => (
            <Text style={{
              color: isDarkMode ? '#8e8e93' : '#6d6d72',
              fontSize: scaledFonts.small,
              fontWeight: '400',
              textTransform: 'uppercase',
              marginBottom: 8,
              marginTop: 24,
              marginLeft: 16,
              letterSpacing: 0.5,
            }}>{title}</Text>
          );

          // Section Footer
          const SectionFooter = ({ text }) => (
            <Text style={{
              color: isDarkMode ? '#8e8e93' : '#6d6d72',
              fontSize: scaledFonts.small,
              marginTop: 8,
              marginLeft: 16,
              marginRight: 16,
              lineHeight: 18,
            }}>{text}</Text>
          );

          // Sub-page header with back button
          const SubPageHeader = ({ title }) => (
            <View style={{ flexDirection: 'row', alignItems: 'center', paddingTop: 12, paddingBottom: 4 }}>
              <TouchableOpacity
                onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setSettingsSubPage(null); }}
                style={{ flexDirection: 'row', alignItems: 'center', paddingVertical: 8 }}
                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
              >
                <Text style={{ color: '#007AFF', fontSize: 18, marginRight: 4 }}>â€¹</Text>
                <Text style={{ color: '#007AFF', fontSize: scaledFonts.normal }}>Settings</Text>
              </TouchableOpacity>
            </View>
          );

          const pageStyle = { flex: 1, backgroundColor: settingsBg, marginHorizontal: -20, marginTop: -20, paddingHorizontal: 16, paddingTop: 8 };

          // ===== NOTIFICATIONS SUB-PAGE =====
          if (settingsSubPage === 'notifications') {
            const notifSwitchTrack = { false: isDarkMode ? '#39393d' : '#e9e9eb', true: '#34c759' };
            const notifSwitchBg = isDarkMode ? '#39393d' : '#e9e9eb';
            const NotifRow = ({ item, isFirst, isLast, indented, disabled }) => (
              <View style={{
                flexDirection: 'row',
                alignItems: 'center',
                justifyContent: 'space-between',
                backgroundColor: groupBg,
                paddingVertical: 12,
                paddingHorizontal: 16,
                paddingLeft: indented ? 40 : 16,
                minHeight: 44,
                opacity: disabled ? 0.4 : 1,
                ...(isFirst ? { borderTopLeftRadius: 10, borderTopRightRadius: 10 } : {}),
                ...(isLast ? { borderBottomLeftRadius: 10, borderBottomRightRadius: 10 } : {}),
              }}>
                <View style={{ flex: 1 }}>
                  <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{item.label}</Text>
                  <Text style={{ color: colors.muted, fontSize: scaledFonts.small, marginTop: 2 }}>{item.description}</Text>
                </View>
                <Switch
                  value={notifPrefs[item.key]}
                  onValueChange={(value) => {
                    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                    saveNotifPref(item.key, value);
                  }}
                  trackColor={notifSwitchTrack}
                  thumbColor="#fff"
                  ios_backgroundColor={notifSwitchBg}
                  disabled={disabled}
                />
              </View>
            );
            return (
              <View style={pageStyle}>
                <SubPageHeader title="Notifications" />
                <Text style={{ color: colors.text, fontSize: 28, fontWeight: '700', marginLeft: 16, marginBottom: 8 }}>Notifications</Text>

                {/* Push Notifications Section */}
                <Text style={{ color: colors.muted, fontSize: 13, fontWeight: '600', textTransform: 'uppercase', marginLeft: 16, marginTop: 16, marginBottom: 6 }}>Push Notifications</Text>
                <View style={{ borderRadius: 10, overflow: 'hidden' }}>
                  <NotifRow item={{ key: 'daily_brief', label: "Troy's Take", description: 'Daily market summary each morning' }} isFirst isLast={false} />
                  <RowSeparator />
                  <NotifRow item={{ key: 'breaking_news', label: 'Market Intelligence', description: 'Breaking news and major market events' }} isLast={false} />
                  <RowSeparator />
                  <NotifRow item={{ key: 'price_alerts', label: 'Price Alerts', description: 'Triggered when your price targets are hit' }} isLast />
                </View>

                {/* COMEX Vault Alerts Section */}
                <Text style={{ color: colors.muted, fontSize: 13, fontWeight: '600', textTransform: 'uppercase', marginLeft: 16, marginTop: 24, marginBottom: 6 }}>COMEX Vault Alerts</Text>
                <View style={{ borderRadius: 10, overflow: 'hidden' }}>
                  <NotifRow item={{ key: 'comex_alerts', label: 'All Vault Changes', description: 'Master toggle for COMEX vault notifications' }} isFirst isLast={false} />
                  <RowSeparator />
                  <NotifRow item={{ key: 'comex_gold', label: 'Gold (Au)', description: 'Gold vault inventory changes' }} indented disabled={!notifPrefs.comex_alerts} isLast={false} />
                  <RowSeparator />
                  <NotifRow item={{ key: 'comex_silver', label: 'Silver (Ag)', description: 'Silver vault inventory changes' }} indented disabled={!notifPrefs.comex_alerts} isLast={false} />
                  <RowSeparator />
                  <NotifRow item={{ key: 'comex_platinum', label: 'Platinum (Pt)', description: 'Platinum vault inventory changes' }} indented disabled={!notifPrefs.comex_alerts} isLast={false} />
                  <RowSeparator />
                  <NotifRow item={{ key: 'comex_palladium', label: 'Palladium (Pd)', description: 'Palladium vault inventory changes' }} indented disabled={!notifPrefs.comex_alerts} isLast />
                </View>
                <SectionFooter text="Get notified when COMEX vault registered or eligible inventory changes significantly." />

                <View style={{ height: 50 }} />
              </View>
            );
          }

          // ===== APPEARANCE SUB-PAGE =====
          if (settingsSubPage === 'appearance') {
            return (
              <View style={pageStyle}>
                <SubPageHeader title="Appearance" />
                <Text style={{ color: colors.text, fontSize: 28, fontWeight: '700', marginLeft: 16, marginBottom: 8 }}>Appearance</Text>
                <View style={{ borderRadius: 10, overflow: 'hidden', marginTop: 8 }}>
                  <View style={{
                    backgroundColor: groupBg,
                    paddingVertical: 12,
                    paddingHorizontal: 16,
                    borderRadius: 10,
                  }}>
                    <View style={{ flexDirection: 'row', gap: 8 }}>
                      {[
                        { key: 'light', label: 'Light', icon: 'â˜€ï¸' },
                        { key: 'dark', label: 'Dark', icon: 'ðŸŒ™' },
                        { key: 'system', label: 'Auto', icon: 'âš™ï¸' },
                      ].map((option) => (
                        <TouchableOpacity
                          key={option.key}
                          style={{
                            flex: 1,
                            paddingVertical: 10,
                            paddingHorizontal: 8,
                            borderRadius: 8,
                            backgroundColor: themePreference === option.key
                              ? (isDarkMode ? '#48484a' : '#e5e5ea')
                              : 'transparent',
                            alignItems: 'center',
                          }}
                          onPress={() => {
                            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                            changeTheme(option.key);
                          }}
                        >
                          <Text style={{ fontSize: 20, marginBottom: 4 }}>{option.icon}</Text>
                          <Text style={{
                            color: themePreference === option.key ? colors.text : colors.muted,
                            fontWeight: themePreference === option.key ? '600' : '400',
                            fontSize: scaledFonts.small,
                          }}>
                            {option.label}
                          </Text>
                        </TouchableOpacity>
                      ))}
                    </View>
                  </View>
                </View>
                <SectionFooter text={themePreference === 'system' ? 'Following system appearance settings' : `${themePreference === 'dark' ? 'Dark' : 'Light'} mode enabled`} />
                <View style={{ height: 50 }} />
              </View>
            );
          }

          // ===== DISPLAY SUB-PAGE =====
          if (settingsSubPage === 'display') {
            return (
              <View style={pageStyle}>
                <SubPageHeader title="Display" />
                <Text style={{ color: colors.text, fontSize: 28, fontWeight: '700', marginLeft: 16, marginBottom: 8 }}>Display</Text>
                <View style={{ borderRadius: 10, overflow: 'hidden', marginTop: 8 }}>
                  {/* Large Text */}
                  <View style={{
                    flexDirection: 'row',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    backgroundColor: groupBg,
                    paddingVertical: 12,
                    paddingHorizontal: 16,
                    minHeight: 44,
                    borderTopLeftRadius: 10,
                    borderTopRightRadius: 10,
                  }}>
                    <View style={{ flex: 1 }}>
                      <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>Large Text</Text>
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.small, marginTop: 2 }}>Increase font sizes throughout the app</Text>
                    </View>
                    <Switch
                      value={largeText}
                      onValueChange={(value) => {
                        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                        toggleLargeText(value);
                      }}
                      trackColor={{ false: isDarkMode ? '#39393d' : '#e9e9eb', true: '#34c759' }}
                      thumbColor="#fff"
                      ios_backgroundColor={isDarkMode ? '#39393d' : '#e9e9eb'}
                    />
                  </View>
                  <RowSeparator />
                  {/* Widget Hide Values */}
                  <View style={{
                    flexDirection: 'row',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    backgroundColor: groupBg,
                    paddingVertical: 12,
                    paddingHorizontal: 16,
                    minHeight: 44,
                    borderBottomLeftRadius: 10,
                    borderBottomRightRadius: 10,
                  }}>
                    <View style={{ flex: 1 }}>
                      <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>Hide Values on Widget</Text>
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.small, marginTop: 2 }}>Show dots instead of dollar amounts</Text>
                    </View>
                    <Switch
                      value={hideWidgetValues}
                      onValueChange={(value) => {
                        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                        setHideWidgetValues(value);
                        AsyncStorage.setItem('stack_hide_widget_values', value ? 'true' : 'false');
                      }}
                      trackColor={{ false: isDarkMode ? '#39393d' : '#e9e9eb', true: '#34c759' }}
                      thumbColor="#fff"
                      ios_backgroundColor={isDarkMode ? '#39393d' : '#e9e9eb'}
                    />
                  </View>
                </View>
                <View style={{ height: 50 }} />
              </View>
            );
          }

          // ===== EXPORT & BACKUP SUB-PAGE =====
          if (settingsSubPage === 'exportBackup') {
            return (
              <View style={pageStyle}>
                <SubPageHeader title="Export & Backup" />
                <Text style={{ color: colors.text, fontSize: 28, fontWeight: '700', marginLeft: 16, marginBottom: 8 }}>Export & Backup</Text>
                <View style={{ borderRadius: 10, overflow: 'hidden', marginTop: 8 }}>
                  <SettingsRow
                    label="Export to Backup"
                    onPress={createBackup}
                    isFirst={true}
                    isLast={false}
                  />
                  <RowSeparator />
                  <SettingsRow
                    label="Restore from Backup"
                    onPress={restoreBackup}
                    isFirst={false}
                    isLast={false}
                  />
                  <RowSeparator />
                  <SettingsRow
                    label="Export as CSV"
                    onPress={exportCSV}
                    isFirst={false}
                    isLast={true}
                  />
                </View>
                <SectionFooter text="Backups include all holdings and settings. Export to Files, iCloud Drive, or any storage." />

                {/* Clear All Data */}
                <View style={{ marginTop: 40 }}>
                  <View style={{ borderRadius: 10, overflow: 'hidden' }}>
                    <TouchableOpacity
                      style={{
                        backgroundColor: groupBg,
                        paddingVertical: 12,
                        paddingHorizontal: 16,
                        minHeight: 44,
                        borderRadius: 10,
                        alignItems: 'center',
                      }}
                      onPress={() => {
                        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
                        Alert.alert(
                          'Clear All Data',
                          'Are you sure? This will permanently delete all your holdings and settings.',
                          [
                            { text: 'Cancel', style: 'cancel' },
                            {
                              text: 'Continue',
                              style: 'destructive',
                              onPress: () => {
                                Alert.prompt(
                                  'This cannot be undone',
                                  'Type DELETE to confirm.',
                                  [
                                    { text: 'Cancel', style: 'cancel' },
                                    {
                                      text: 'Clear Everything',
                                      style: 'destructive',
                                      onPress: (text) => {
                                        if (text === 'DELETE') {
                                          clearAllData();
                                        } else {
                                          Alert.alert('Not deleted', 'You must type DELETE exactly to confirm.');
                                        }
                                      },
                                    },
                                  ],
                                  'plain-text',
                                  '',
                                  'default'
                                );
                              },
                            },
                          ]
                        );
                      }}
                    >
                      <Text style={{ color: '#FF3B30', fontSize: scaledFonts.normal }}>Clear All Data</Text>
                    </TouchableOpacity>
                  </View>
                  <SectionFooter text="This will permanently delete all holdings, settings, and preferences. This action cannot be undone." />
                </View>

                <View style={{ height: 50 }} />
              </View>
            );
          }

          if (settingsSubPage === 'advanced') {
            return (
              <View style={pageStyle}>
                <SubPageHeader title="Advanced" />
                <Text style={{ color: colors.text, fontSize: 28, fontWeight: '700', marginLeft: 16, marginBottom: 8 }}>Advanced</Text>

                {supabaseUser && (
                  <>
                    <SectionHeader title="Support" />
                    <View style={{ borderRadius: 10, overflow: 'hidden' }}>
                      <TouchableOpacity
                        style={{
                          flexDirection: 'row',
                          alignItems: 'center',
                          justifyContent: 'space-between',
                          backgroundColor: groupBg,
                          paddingVertical: 12,
                          paddingHorizontal: 16,
                          minHeight: 44,
                          borderRadius: 10,
                        }}
                        onPress={() => {
                          Clipboard.setString(supabaseUser.id);
                          Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
                          Alert.alert('Copied', 'Support ID copied to clipboard');
                        }}
                      >
                        <View style={{ flex: 1, marginRight: 12 }}>
                          <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>Support ID</Text>
                          <Text style={{ color: colors.muted, fontSize: 11, fontFamily: Platform.OS === 'ios' ? 'Courier' : 'monospace', marginTop: 4 }} numberOfLines={1}>{supabaseUser.id}</Text>
                        </View>
                        <Text style={{ color: '#007AFF', fontSize: scaledFonts.small }}>Copy</Text>
                      </TouchableOpacity>
                    </View>
                    <SectionFooter text="Share this ID with support when requesting help." />
                  </>
                )}

                <View style={{ height: 50 }} />
              </View>
            );
          }

          // ===== MAIN SETTINGS PAGE =====
          return (
            <View style={pageStyle}>
              {/* ACCOUNT (no section header, card at top) */}
              <View onLayout={(e) => { sectionOffsets.current['account'] = e.nativeEvent.layout.y; }} style={{ marginTop: 16 }}>
                <View style={{ borderRadius: 10, overflow: 'hidden' }}>
                  {/* Profile row */}
                  {supabaseUser ? (
                    <TouchableOpacity
                      style={{
                        flexDirection: 'row',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        backgroundColor: groupBg,
                        paddingVertical: 14,
                        paddingHorizontal: 16,
                        minHeight: 56,
                        borderTopLeftRadius: 10,
                        borderTopRightRadius: 10,
                      }}
                      onPress={() => setShowAccountScreen(true)}
                    >
                      <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12 }}>
                        <View style={{ width: 40, height: 40, borderRadius: 20, backgroundColor: colors.gold, alignItems: 'center', justifyContent: 'center' }}>
                          <ProfileIcon size={22} color="#18181b" />
                        </View>
                        <View style={{ flex: 1 }}>
                          <Text style={{ color: colors.text, fontSize: scaledFonts.normal, fontWeight: '500' }}>{supabaseUser.email}</Text>
                          <Text style={{ color: colors.muted, fontSize: scaledFonts.small, marginTop: 1 }}>Manage Account</Text>
                        </View>
                      </View>
                      <Text style={{ color: chevronColor, fontSize: 18, fontWeight: '600' }}>â€º</Text>
                    </TouchableOpacity>
                  ) : (
                    <TouchableOpacity
                      style={{
                        flexDirection: 'row',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        backgroundColor: groupBg,
                        paddingVertical: 14,
                        paddingHorizontal: 16,
                        minHeight: 56,
                        borderTopLeftRadius: 10,
                        borderTopRightRadius: 10,
                      }}
                      onPress={() => disableGuestMode()}
                    >
                      <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12 }}>
                        <View style={{ width: 40, height: 40, borderRadius: 20, backgroundColor: '#007AFF', alignItems: 'center', justifyContent: 'center' }}>
                          <ProfileIcon size={22} color="#fff" />
                        </View>
                        <View>
                          <Text style={{ color: colors.text, fontSize: scaledFonts.normal, fontWeight: '500' }}>Sign In or Create Account</Text>
                          <Text style={{ color: colors.muted, fontSize: scaledFonts.small, marginTop: 1 }}>Sync your data across devices</Text>
                        </View>
                      </View>
                      <Text style={{ color: chevronColor, fontSize: 18, fontWeight: '600' }}>â€º</Text>
                    </TouchableOpacity>
                  )}
                  <RowSeparator />
                  {/* Membership row */}
                  <TouchableOpacity
                    style={{
                      flexDirection: 'row',
                      alignItems: 'center',
                      justifyContent: 'space-between',
                      backgroundColor: groupBg,
                      paddingVertical: 12,
                      paddingHorizontal: 16,
                      minHeight: 44,
                      borderBottomLeftRadius: 10,
                      borderBottomRightRadius: 10,
                    }}
                    onPress={() => {
                      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                      hasGoldAccess ? setShowBenefitsScreen(true) : setShowPaywallModal(true);
                    }}
                  >
                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12 }}>
                      <View style={{ width: 30, height: 30, borderRadius: 6, backgroundColor: hasGoldAccess ? 'rgba(251, 191, 36, 0.2)' : 'rgba(113, 113, 122, 0.2)', alignItems: 'center', justifyContent: 'center' }}>
                        <Text style={{ fontSize: 16 }}>{hasLifetimeAccess ? 'ðŸ’Ž' : hasGold ? 'ðŸ‘‘' : 'ðŸ¥ˆ'}</Text>
                      </View>
                      <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>
                        {hasLifetimeAccess ? 'Lifetime Member' : hasGold ? 'Gold Member' : 'Free'}
                      </Text>
                    </View>
                    <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
                      {!hasGoldAccess && <Text style={{ color: '#007AFF', fontSize: scaledFonts.small }}>Upgrade</Text>}
                      {hasLifetimeAccess && <Text style={{ color: colors.success, fontSize: scaledFonts.small }}>Thank you!</Text>}
                      <Text style={{ color: chevronColor, fontSize: 18, fontWeight: '600' }}>â€º</Text>
                    </View>
                  </TouchableOpacity>
                </View>
              </View>

              {/* PREFERENCES */}
              <SectionHeader title="Preferences" />
              <View onLayout={(e) => { sectionOffsets.current['notifications'] = e.nativeEvent.layout.y; }} style={{ borderRadius: 10, overflow: 'hidden' }}>
                <SettingsRow
                  label="Notifications"
                  onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setSettingsSubPage('notifications'); scrollRef.current?.scrollTo({ y: 0, animated: false }); }}
                  isFirst={true}
                  isLast={false}
                />
                <RowSeparator />
                <SettingsRow
                  label="Appearance"
                  onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setSettingsSubPage('appearance'); scrollRef.current?.scrollTo({ y: 0, animated: false }); }}
                  isFirst={false}
                  isLast={false}
                />
                <RowSeparator />
                <SettingsRow
                  label="Display"
                  onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setSettingsSubPage('display'); scrollRef.current?.scrollTo({ y: 0, animated: false }); }}
                  isFirst={false}
                  isLast={true}
                />
              </View>

              {/* DATA */}
              <SectionHeader title="Data" />
              <View style={{ borderRadius: 10, overflow: 'hidden' }}>
                <SettingsRow
                  label="Export & Backup"
                  onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setSettingsSubPage('exportBackup'); scrollRef.current?.scrollTo({ y: 0, animated: false }); }}
                  isFirst={true}
                  isLast={false}
                />
                <RowSeparator />
                <SettingsRow
                  label="Advanced"
                  onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); setSettingsSubPage('advanced'); scrollRef.current?.scrollTo({ y: 0, animated: false }); }}
                  isFirst={false}
                  isLast={true}
                />
              </View>

              {/* ABOUT */}
              <View onLayout={(e) => { sectionOffsets.current['about'] = e.nativeEvent.layout.y; }}>
              <SectionHeader title="About" />
              <View onLayout={(e) => { sectionOffsets.current['whatsNew'] = e.nativeEvent.layout.y; }} style={{ borderRadius: 10, overflow: 'hidden' }}>
                <SettingsRow
                  label="Help Guide"
                  onPress={() => {
                    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                    setShowHelpModal(true);
                  }}
                  isFirst={true}
                  isLast={false}
                />
                <RowSeparator />
                <SettingsRow
                  label="What's New in v2.0"
                  onPress={() => {
                    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                    AsyncStorage.removeItem('has_seen_v2_0_tutorial');
                    setShowV20Tutorial(true);
                  }}
                  isFirst={false}
                  isLast={false}
                />
                <RowSeparator />
                {/* Version - triple-tap in __DEV__ to toggle screenshot mode */}
                <TouchableOpacity
                  onPress={__DEV__ ? handleVersionTap : undefined}
                  activeOpacity={__DEV__ ? 0.7 : 1}
                  style={{
                    flexDirection: 'row',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    backgroundColor: groupBg,
                    paddingVertical: 12,
                    paddingHorizontal: 16,
                    minHeight: 44,
                  }}>
                  <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>Version</Text>
                  <Text style={{ color: screenshotMode ? '#D4A843' : colors.muted, fontSize: scaledFonts.normal }}>
                    2.0.0{screenshotMode ? ' ðŸ“¸' : ''}
                  </Text>
                </TouchableOpacity>
                <RowSeparator />
                {/* Privacy Policy Â· Terms of Use - single row */}
                <View style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  justifyContent: 'center',
                  backgroundColor: groupBg,
                  paddingVertical: 12,
                  paddingHorizontal: 16,
                  minHeight: 44,
                  borderBottomLeftRadius: 10,
                  borderBottomRightRadius: 10,
                }}>
                  <TouchableOpacity onPress={() => setShowPrivacyModal(true)}>
                    <Text style={{ color: '#007AFF', fontSize: scaledFonts.normal }}>Privacy Policy</Text>
                  </TouchableOpacity>
                  <Text style={{ color: colors.muted, fontSize: scaledFonts.normal, marginHorizontal: 8 }}>{'\u00B7'}</Text>
                  <TouchableOpacity onPress={() => Linking.openURL('https://api.stacktrackergold.com/terms')}>
                    <Text style={{ color: '#007AFF', fontSize: scaledFonts.normal }}>Terms of Use</Text>
                  </TouchableOpacity>
                </View>
              </View>
              </View>

              {/* Scan Usage - only show for free users */}
              {!hasGold && !hasLifetimeAccess && (
                <>
                  <SectionHeader title="Usage" />
                  <View style={{ borderRadius: 10, overflow: 'hidden' }}>
                    <View style={{
                      backgroundColor: groupBg,
                      paddingVertical: 12,
                      paddingHorizontal: 16,
                      borderRadius: 10,
                    }}>
                      <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                        <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>Receipt Scans</Text>
                        <Text style={{ color: scanUsage.scansUsed >= scanUsage.scansLimit ? colors.error : colors.muted, fontSize: scaledFonts.normal, fontWeight: '600' }}>
                          {scanUsage.scansUsed} / {scanUsage.scansLimit}
                        </Text>
                      </View>
                      {/* Progress bar */}
                      <View style={{ height: 4, backgroundColor: isDarkMode ? '#39393d' : '#e5e5ea', borderRadius: 2, marginTop: 8 }}>
                        <View style={{
                          height: 4,
                          backgroundColor: scanUsage.scansUsed >= scanUsage.scansLimit ? colors.error : '#34c759',
                          borderRadius: 2,
                          width: `${Math.min((scanUsage.scansUsed / scanUsage.scansLimit) * 100, 100)}%`
                        }} />
                      </View>
                    </View>
                  </View>
                  {scanUsage.resetsAt && (
                    <SectionFooter text={`Resets ${new Date(scanUsage.resetsAt).toLocaleDateString()}`} />
                  )}
                </>
              )}

              {/* Sign Out - only when signed in */}
              {supabaseUser && (
                <>
                  <View style={{ marginTop: 32 }}>
                    <View style={{ borderRadius: 10, overflow: 'hidden' }}>
                      <TouchableOpacity
                        style={{
                          backgroundColor: groupBg,
                          paddingVertical: 12,
                          paddingHorizontal: 16,
                          minHeight: 44,
                          borderRadius: 10,
                          alignItems: 'center',
                        }}
                        onPress={() => {
                          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
                          Alert.alert(
                            'Sign Out',
                            'Are you sure you want to sign out?',
                            [
                              { text: 'Cancel', style: 'cancel' },
                              {
                                text: 'Sign Out',
                                style: 'destructive',
                                onPress: async () => {
                                  try { await logoutRevenueCat(); } catch (e) { if (__DEV__) console.error('RevenueCat logout failed:', e); }
                                  await supabaseSignOut();
                                  setGuestMode(true);
                                },
                              },
                            ]
                          );
                        }}
                      >
                        <Text style={{ color: '#007AFF', fontSize: scaledFonts.normal }}>Sign Out</Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </>
              )}

              {/* Extra padding at bottom */}
              <View style={{ height: 50 }} />
            </View>
          );
        })()}

        <View style={{ height: (tab === 'settings' || tab === 'analytics') ? 300 : 100 }} />

      </ScrollView>

      {/* Troy FAB â€” realistic gold coin, every tab */}
      <Animated.View style={{
        position: 'absolute',
        right: 20,
        bottom: 80 + Math.max(insets.bottom, 10),
        zIndex: 100,
        transform: [{ scale: fabScale }],
      }}>
        <TouchableOpacity
          onPressIn={() => {
            Animated.spring(fabScale, { toValue: 0.95, useNativeDriver: true, speed: 50, bounciness: 4 }).start();
          }}
          onPressOut={() => {
            Animated.spring(fabScale, { toValue: 1, useNativeDriver: true, speed: 50, bounciness: 4 }).start();
          }}
          onPress={() => {
            fabTapped.current = true;
            fabGlow.stopAnimation();
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
            setShowTroyChat(true);
          }}
          activeOpacity={1}
        >
          <Animated.View style={{
            shadowColor: '#D4A843',
            shadowOffset: { width: 0, height: 0 },
            shadowOpacity: fabGlow,
            shadowRadius: 8,
            elevation: 8,
            borderRadius: 28,
          }}>
            <TroyCoinIcon size={56} />
          </Animated.View>
        </TouchableOpacity>
      </Animated.View>

      {/* Troy Chat Modal */}
      <Modal visible={showTroyChat} animationType="slide" presentationStyle="pageSheet">
        <SafeAreaView style={{ flex: 1, backgroundColor: isDarkMode ? '#000000' : '#f2f2f7' }}>
          {/* Header */}
          <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', paddingHorizontal: 16, paddingVertical: 12, borderBottomWidth: 0.5, borderBottomColor: isDarkMode ? '#38383a' : '#c6c6c8' }}>
            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
              <TroyCoinIcon size={32} />
              <View>
                <Text style={{ color: colors.text, fontSize: 17, fontWeight: '600' }}>Troy</Text>
                <Text style={{ color: colors.muted, fontSize: 12 }}>Your Stack Analyst</Text>
              </View>
            </View>
            <TouchableOpacity onPress={() => setShowTroyChat(false)} hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}>
              <Text style={{ color: colors.gold, fontSize: 17, fontWeight: '600' }}>Done</Text>
            </TouchableOpacity>
          </View>

          <KeyboardAvoidingView style={{ flex: 1 }} behavior={Platform.OS === 'ios' ? 'padding' : undefined} keyboardVerticalOffset={Platform.OS === 'ios' ? 60 : 0}>
            {/* Chat messages */}
            <ScrollView
              ref={advisorScrollRef}
              style={{ flex: 1, padding: 16 }}
              onContentSizeChange={() => advisorScrollRef.current?.scrollToEnd({ animated: true })}
              keyboardShouldPersistTaps="handled"
              keyboardDismissMode="interactive"
            >
              {advisorMessages.length === 0 ? (
                <View style={{ gap: 12, paddingVertical: 20 }}>
                  <View style={{ alignItems: 'center', marginBottom: 12 }}>
                    <View style={{ marginBottom: 12 }}>
                      <TroyCoinIcon size={56} />
                    </View>
                    <Text style={{ color: colors.text, fontSize: 17, fontWeight: '600' }}>Ask Troy anything</Text>
                    <Text style={{ color: colors.muted, fontSize: 13, marginTop: 4, textAlign: 'center' }}>Your personal stack analyst. I know your portfolio{'\n'}and can help you make smarter decisions.</Text>
                  </View>
                  {[
                    'How is my portfolio performing?',
                    'Should I buy more silver or gold?',
                    'Analyze my gold-to-silver ratio',
                    'What if silver hits $100?',
                    "What's my best and worst purchase?",
                  ].map((q, i) => (
                    <TouchableOpacity
                      key={i}
                      style={{
                        backgroundColor: isDarkMode ? 'rgba(212,168,67,0.08)' : 'rgba(212,168,67,0.1)',
                        borderRadius: 16,
                        paddingVertical: 10,
                        paddingHorizontal: 14,
                        borderWidth: 1,
                        borderColor: 'rgba(212,168,67,0.2)',
                        alignSelf: 'flex-start',
                      }}
                      onPress={() => {
                        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                        sendAdvisorMessage(q);
                      }}
                    >
                      <Text style={{ color: '#D4A843', fontSize: 13 }}>{q}</Text>
                    </TouchableOpacity>
                  ))}
                </View>
              ) : (
                <View style={{ gap: 10 }}>
                  {advisorMessages.map((msg, i) => (
                    <View
                      key={i}
                      style={{
                        alignSelf: msg.role === 'user' ? 'flex-end' : 'flex-start',
                        backgroundColor: msg.role === 'user' ? '#D4A843' : (isDarkMode ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)'),
                        borderRadius: 14,
                        paddingVertical: 10,
                        paddingHorizontal: 14,
                        maxWidth: '85%',
                      }}
                    >
                      <Text style={{
                        color: msg.role === 'user' ? '#000' : colors.text,
                        fontSize: 14,
                        lineHeight: 20,
                      }}>{msg.text}</Text>
                      {msg.isUpgradeCTA && (
                        <TouchableOpacity
                          onPress={() => { setShowTroyChat(false); setShowPaywallModal(true); }}
                          style={{ backgroundColor: '#D4A843', borderRadius: 8, paddingVertical: 10, paddingHorizontal: 16, marginTop: 10, alignSelf: 'flex-start' }}
                        >
                          <Text style={{ color: '#000', fontSize: 14, fontWeight: '700' }}>Upgrade to Gold</Text>
                        </TouchableOpacity>
                      )}
                    </View>
                  ))}
                  {advisorLoading && (
                    <View style={{
                      alignSelf: 'flex-start',
                      backgroundColor: isDarkMode ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)',
                      borderRadius: 14,
                      paddingVertical: 10,
                      paddingHorizontal: 14,
                    }}>
                      <Text style={{ color: colors.muted, fontSize: 13, fontStyle: 'italic' }}>Thinking...</Text>
                    </View>
                  )}
                </View>
              )}
            </ScrollView>

            {/* Input bar */}
            <View style={{
              flexDirection: 'row',
              alignItems: 'center',
              borderTopWidth: 0.5,
              borderTopColor: isDarkMode ? '#38383a' : '#c6c6c8',
              paddingHorizontal: 12,
              paddingVertical: 8,
              gap: 8,
              backgroundColor: isDarkMode ? '#000000' : '#f2f2f7',
            }}>
              <TextInput
                style={{
                  flex: 1,
                  backgroundColor: isDarkMode ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.04)',
                  borderRadius: 20,
                  paddingVertical: 10,
                  paddingHorizontal: 14,
                  color: colors.text,
                  fontSize: 15,
                }}
                placeholder="Ask Troy..."
                placeholderTextColor={colors.muted}
                value={advisorInput}
                onChangeText={setAdvisorInput}
                onSubmitEditing={() => sendAdvisorMessage()}
                returnKeyType="send"
                editable={!advisorLoading}
                autoFocus={false}
              />
              <TouchableOpacity
                onPress={() => sendAdvisorMessage()}
                disabled={!advisorInput.trim() || advisorLoading}
                style={{
                  width: 36,
                  height: 36,
                  borderRadius: 18,
                  backgroundColor: advisorInput.trim() ? '#D4A843' : (isDarkMode ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.06)'),
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <Text style={{ color: advisorInput.trim() ? '#000' : colors.muted, fontSize: 16, fontWeight: '700' }}>{'\u2191'}</Text>
              </TouchableOpacity>
            </View>
            {hasGoldAccess && advisorQuestionsToday >= 25 && advisorQuestionsToday < TROY_GOLD_LIMIT ? (
              <View style={{ paddingHorizontal: 12, paddingBottom: Math.max(insets.bottom, 8), backgroundColor: isDarkMode ? '#000000' : '#f2f2f7' }}>
                <Text style={{ color: colors.muted, fontSize: 10, textAlign: 'center' }}>
                  {`${TROY_GOLD_LIMIT - advisorQuestionsToday} left for today â€” resets at midnight`}
                </Text>
              </View>
            ) : (
              <View style={{ paddingBottom: Math.max(insets.bottom, 8), backgroundColor: isDarkMode ? '#000000' : '#f2f2f7' }} />
            )}
          </KeyboardAvoidingView>
        </SafeAreaView>
      </Modal>

      {/* Bottom Tabs */}
      <View style={[styles.bottomTabs, { backgroundColor: isDarkMode ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.95)', borderTopColor: colors.border, paddingBottom: Math.max(insets.bottom, 10) }]}>
        {[
          { key: 'today', label: 'Today', Icon: TodayIcon },
          { key: 'portfolio', label: 'Stack', Icon: HoldingsIcon },
          { key: 'analytics', label: 'Analytics', Icon: DashboardIcon },
          { key: 'tools', label: 'Tools', Icon: ToolsIcon },
          { key: 'settings', label: 'Settings', Icon: SettingsIcon },
        ].map(t => (
          <TouchableOpacity key={t.key} style={styles.bottomTab} onPress={() => {
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
            if (tab === t.key) {
              scrollRef.current?.scrollTo({ y: 0, animated: true });
            } else {
              setTab(t.key);
              setTimeout(() => scrollRef.current?.scrollTo({ y: 0, animated: false }), 0);
            }
          }}>
            <t.Icon size={22} color={tab === t.key ? colors.gold : colors.muted} />
            <Text style={{ color: tab === t.key ? colors.gold : colors.muted, fontSize: 10, fontWeight: tab === t.key ? '600' : '400', marginTop: 4 }}>{t.label}</Text>
            {tab === t.key && <View style={{ position: 'absolute', bottom: -4, left: 8, right: 8, height: 2, backgroundColor: colors.gold, borderRadius: 1 }} />}
          </TouchableOpacity>
        ))}
      </View>

      {/* ACCOUNT SCREEN MODAL */}
      <Modal visible={showAccountScreen} animationType="slide" presentationStyle="pageSheet">
        <AccountScreen
          onClose={() => setShowAccountScreen(false)}
          onSignOut={() => {
            setShowAccountScreen(false);
            setGuestMode(true);
          }}
          hasGold={hasGold}
          hasLifetime={hasLifetimeAccess}
          colors={colors}
        />
      </Modal>

      {/* Benefits Screen */}
      <Modal visible={showBenefitsScreen} animationType="slide" presentationStyle="pageSheet">
        <SafeAreaView style={{ flex: 1, backgroundColor: isDarkMode ? '#000000' : '#f2f2f7' }}>
          <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', paddingHorizontal: 16, paddingVertical: 12, borderBottomWidth: 0.5, borderBottomColor: isDarkMode ? '#38383a' : '#c6c6c8' }}>
            <TouchableOpacity onPress={() => setShowBenefitsScreen(false)}>
              <Text style={{ color: '#007AFF', fontSize: scaledFonts.normal }}>Done</Text>
            </TouchableOpacity>
            <Text style={{ color: colors.text, fontSize: scaledFonts.medium, fontWeight: '700' }}>
              {hasLifetimeAccess ? 'Lifetime Benefits' : hasGold ? 'Gold Benefits' : 'Membership'}
            </Text>
            <View style={{ width: 40 }} />
          </View>
          <ScrollView style={{ flex: 1, padding: 16 }}>
            {/* Current plan header */}
            <View style={{ alignItems: 'center', paddingVertical: 24 }}>
              <Text style={{ fontSize: 48, marginBottom: 12 }}>{hasLifetimeAccess ? 'ðŸ’Ž' : hasGold ? 'ðŸ‘‘' : 'ðŸ¥ˆ'}</Text>
              <Text style={{ color: colors.text, fontSize: 22, fontWeight: '700', marginBottom: 4 }}>
                {hasLifetimeAccess ? 'Lifetime Member' : hasGold ? 'Gold Member' : 'Free Plan'}
              </Text>
              {hasLifetimeAccess && <Text style={{ color: colors.success, fontSize: scaledFonts.normal }}>Thank you for your support!</Text>}
            </View>

            {/* Free features - always shown */}
            <Text style={{ color: isDarkMode ? '#8e8e93' : '#6d6d72', fontSize: scaledFonts.small, fontWeight: '400', textTransform: 'uppercase', marginBottom: 8, marginLeft: 4, letterSpacing: 0.5 }}>
              {hasGoldAccess ? 'Everything Included' : 'Free Features'}
            </Text>
            <View style={{ backgroundColor: isDarkMode ? '#1c1c1e' : '#ffffff', borderRadius: 10, overflow: 'hidden', marginBottom: 20 }}>
              {[
                { icon: 'ðŸ“Š', label: 'Live gold & silver spot prices' },
                { icon: 'ðŸ“', label: 'Manual holdings entry' },
                { icon: 'ðŸ“¸', label: 'AI receipt scanning (5/month)' },
                { icon: 'ðŸ“¤', label: 'Export CSV & manual backup' },
                { icon: 'ðŸŒ™', label: 'Dark mode & accessibility' },
                { icon: 'ðŸ””', label: 'Price alerts & push notifications' },
                { icon: 'ðŸ”®', label: 'What If scenarios & speculation tool' },
                { icon: 'ðŸ§®', label: 'Junk silver calculator' },
                { icon: 'ðŸ†', label: 'Stack milestones & Share My Stack' },
              ].map((item, i, arr) => (
                <View key={i}>
                  <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12, paddingVertical: 12, paddingHorizontal: 16 }}>
                    <Text style={{ fontSize: 18 }}>{item.icon}</Text>
                    <Text style={{ color: colors.text, fontSize: scaledFonts.normal, flex: 1 }}>{item.label}</Text>
                    <Text style={{ color: colors.success, fontSize: 16 }}>âœ“</Text>
                  </View>
                  {i < arr.length - 1 && <View style={{ height: 0.5, backgroundColor: isDarkMode ? '#38383a' : '#c6c6c8', marginLeft: 50 }} />}
                </View>
              ))}
            </View>

            {/* Gold features */}
            <Text style={{ color: isDarkMode ? '#8e8e93' : '#6d6d72', fontSize: scaledFonts.small, fontWeight: '400', textTransform: 'uppercase', marginBottom: 8, marginLeft: 4, letterSpacing: 0.5 }}>
              {hasGoldAccess ? 'Gold Features' : 'Upgrade to Gold'}
            </Text>
            <View style={{ backgroundColor: isDarkMode ? '#1c1c1e' : '#ffffff', borderRadius: 10, overflow: 'hidden', marginBottom: 20 }}>
              {[
                { icon: 'ðŸ§ ', label: 'Market Intelligence' },
                { icon: 'ðŸ¦', label: 'COMEX Vault Watch' },
                { icon: 'troy', label: "Troy's Take â€” Daily Brief" },
                { icon: 'troy', label: 'Troy â€” AI Stack Analyst' },
                { icon: 'ðŸ“ˆ', label: 'Spot Price History charts' },
                { icon: 'ðŸ“Š', label: 'Advanced Analytics' },
                { icon: 'ðŸ“¸', label: 'Unlimited receipt scans' },
                { icon: 'â˜ï¸', label: 'Cloud sync across devices' },
                ...(Platform.OS === 'ios' ? [{ icon: 'ðŸ“±', label: 'Home screen widgets' }] : []),
              ].map((item, i, arr) => (
                <View key={i}>
                  <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12, paddingVertical: 12, paddingHorizontal: 16 }}>
                    {item.icon === 'troy' ? <TroyCoinIcon size={20} /> : <Text style={{ fontSize: 18 }}>{item.icon}</Text>}
                    <Text style={{ color: colors.text, fontSize: scaledFonts.normal, flex: 1 }}>{item.label}</Text>
                    {hasGoldAccess ? (
                      <Text style={{ color: colors.success, fontSize: 16 }}>âœ“</Text>
                    ) : (
                      <Text style={{ color: colors.gold, fontSize: 14 }}>ðŸ”’</Text>
                    )}
                  </View>
                  {i < arr.length - 1 && <View style={{ height: 0.5, backgroundColor: isDarkMode ? '#38383a' : '#c6c6c8', marginLeft: 50 }} />}
                </View>
              ))}
            </View>

            {/* Upgrade button for free users */}
            {!hasGoldAccess && (
              <TouchableOpacity
                style={{
                  backgroundColor: colors.gold,
                  paddingVertical: 16,
                  borderRadius: 12,
                  alignItems: 'center',
                  marginBottom: 20,
                }}
                onPress={() => {
                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
                  setShowBenefitsScreen(false);
                  setTimeout(() => setShowPaywallModal(true), 300);
                }}
              >
                <Text style={{ color: '#000', fontWeight: '700', fontSize: scaledFonts.medium }}>Upgrade to Gold</Text>
              </TouchableOpacity>
            )}

            <View style={{ height: 40 }} />
          </ScrollView>
        </SafeAreaView>
      </Modal>

      {/* ADD/EDIT MODAL - Custom with sticky save button */}
      <Modal visible={showAddModal} animationType="slide" transparent>
        <View style={styles.modalOverlay}>
          <KeyboardAvoidingView
            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
            style={[styles.modalKeyboardView, { backgroundColor: isDarkMode ? '#1a1a2e' : '#ffffff' }]}
          >
            <View style={[styles.modalContent, { backgroundColor: isDarkMode ? '#1a1a2e' : '#ffffff' }]}>
              {/* Header */}
              <View style={[styles.modalHeader, { borderBottomColor: colors.border }]}>
                <Text style={[styles.modalTitle, { color: colors.text, fontSize: scaledFonts.xlarge }]}>{editingItem ? 'Edit' : 'Add'} Purchase</Text>
                <TouchableOpacity
                  onPress={() => {
                    // If editing a scanned item, return to scan results without losing data
                    if (editingItem?.scannedIndex !== undefined) {
                      resetForm();
                      setShowAddModal(false);
                      setShowScannedItemsPreview(true);
                    } else if (editingItem?.importIndex !== undefined) {
                      // If editing an imported item, return to import preview
                      resetForm();
                      setShowAddModal(false);
                      setShowImportPreview(true);
                    } else {
                      resetForm();
                      setShowAddModal(false);
                    }
                  }}
                  style={[styles.closeButton, { backgroundColor: isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)' }]}
                  hitSlop={{ top: 20, bottom: 20, left: 20, right: 20 }}
                >
                  <Text style={[styles.closeButtonText, { color: colors.text, fontSize: scaledFonts.large }]}>âœ•</Text>
                </TouchableOpacity>
              </View>

              {/* Scrollable Content */}
              <ScrollView
                keyboardShouldPersistTaps="handled"
                keyboardDismissMode="on-drag"
                showsVerticalScrollIndicator={false}
                contentContainerStyle={{ paddingBottom: 20 }}
              >
                  {scanStatus && (
                    <View style={[styles.scanStatus, { backgroundColor: scanStatus === 'success' ? `${colors.success}22` : scanStatus === 'error' ? `${colors.error}22` : `${colors.gold}22` }]}>
                      <Text style={{ color: scanStatus === 'success' ? colors.success : scanStatus === 'error' ? colors.error : colors.gold, fontSize: scaledFonts.normal }}>{scanMessage}</Text>
                    </View>
                  )}

                  <View style={[styles.card, { backgroundColor: isDarkMode ? 'rgba(148,163,184,0.1)' : `${colors.gold}15` }]}>
                    <Text style={{ color: colors.text, fontWeight: '600', marginBottom: 12, fontSize: scaledFonts.normal }}>AI Receipt Scanner</Text>
                    <View style={{ flexDirection: 'row', gap: 8 }}>
                      <TouchableOpacity style={[styles.button, { backgroundColor: colors.gold, flex: 1 }]} onPress={() => showScanningTips('camera')}>
                        <Text style={{ color: '#000', fontSize: scaledFonts.normal }} numberOfLines={1} adjustsFontSizeToFit={true}>Camera</Text>
                      </TouchableOpacity>
                      <TouchableOpacity style={[styles.button, { backgroundColor: colors.gold, flex: 1 }]} onPress={() => showScanningTips('gallery')}>
                        <Text style={{ color: '#000', fontSize: scaledFonts.normal }} numberOfLines={1} adjustsFontSizeToFit={true}>Upload</Text>
                      </TouchableOpacity>
                    </View>
                    {!hasGold && !hasLifetimeAccess && (
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny, marginTop: 8, textAlign: 'center' }}>
                        {scanUsage.scansUsed >= scanUsage.scansLimit ? (
                          <Text style={{ color: colors.error }}>All {scanUsage.scansLimit} free scans used.{scanUsage.resetsAt ? ` Resets ${new Date(scanUsage.resetsAt).toLocaleDateString()}.` : ''}</Text>
                        ) : (
                          <Text>Scans: {scanUsage.scansUsed}/{scanUsage.scansLimit}{scanUsage.resetsAt ? ` (resets ${new Date(scanUsage.resetsAt).toLocaleDateString()})` : ''}</Text>
                        )}
                      </Text>
                    )}
                    {hasGold && (
                      <Text style={{ color: colors.gold, fontSize: scaledFonts.tiny, marginTop: 8, textAlign: 'center' }}>
                        âœ“ Unlimited scans with Gold
                      </Text>
                    )}
                    {hasLifetimeAccess && !hasGold && (
                      <Text style={{ color: colors.success, fontSize: scaledFonts.tiny, marginTop: 8, textAlign: 'center' }}>
                        âœ“ Unlimited scans (Lifetime Access)
                      </Text>
                    )}
                  </View>

                  <View style={[styles.metalTabs, { flexWrap: 'wrap' }]}>
                    {[
                      { key: 'silver', label: 'Silver', color: colors.silver },
                      { key: 'gold', label: 'Gold', color: colors.gold },
                      { key: 'platinum', label: 'Platinum', color: colors.platinum },
                      { key: 'palladium', label: 'Palladium', color: colors.palladium },
                    ].map(m => (
                      <TouchableOpacity key={m.key} style={[styles.metalTab, { borderColor: metalTab === m.key ? m.color : colors.border, backgroundColor: metalTab === m.key ? `${m.color}22` : 'transparent' }]} onPress={() => handleMetalTabChange(m.key)}>
                        <Text style={{ color: metalTab === m.key ? m.color : colors.muted, fontSize: scaledFonts.normal }}>{m.label}</Text>
                      </TouchableOpacity>
                    ))}
                  </View>

                  <FloatingInput label="Product Name" value={form.productName} onChangeText={v => { setForm(p => ({ ...p, productName: v })); if (v) setFormErrors(e => ({ ...e, productName: false })); }} placeholder={{ gold: 'e.g. American Gold Eagle', silver: 'e.g. American Silver Eagle', platinum: 'e.g. American Platinum Eagle', palladium: 'e.g. Canadian Palladium Maple Leaf' }[metalTab] || 'e.g. American Silver Eagle'} colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} required error={formErrors.productName} />
                  <FloatingInput label="Dealer" value={form.source} onChangeText={v => setForm(p => ({ ...p, source: v }))} placeholder="APMEX" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} />
                  <View style={{ flexDirection: 'row', gap: 8 }}>
                    <View style={{ flex: 1 }}>
                      <TouchableOpacity style={{ backgroundColor: isDarkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)', borderRadius: 10, padding: 14, borderWidth: 1, borderColor: colors.border }} onPress={() => { Keyboard.dismiss(); setShowDatePicker(true); }}>
                        <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny, marginBottom: 2 }}>Date</Text>
                        <Text style={{ color: form.datePurchased ? colors.text : colors.muted, fontSize: scaledFonts.normal }}>{form.datePurchased ? (() => { const [y,m,d] = form.datePurchased.split('-'); return `${m}-${d}-${y}`; })() : 'Tap to select'}</Text>
                      </TouchableOpacity>
                    </View>
                    <View style={{ flex: 1 }}>
                      <TouchableOpacity style={{ backgroundColor: isDarkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)', borderRadius: 10, padding: 14, borderWidth: 1, borderColor: colors.border }} onPress={() => { Keyboard.dismiss(); setShowTimePicker(true); }}>
                        <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny, marginBottom: 2 }}>Time</Text>
                        <Text style={{ color: form.timePurchased ? colors.text : colors.muted, fontSize: scaledFonts.normal }}>{form.timePurchased ? (() => { const [h,m] = form.timePurchased.split(':').map(Number); const p = h >= 12 ? 'PM' : 'AM'; const h12 = h === 0 ? 12 : h > 12 ? h - 12 : h; return `${h12}:${String(m).padStart(2,'0')} ${p}`; })() : 'Optional'}</Text>
                      </TouchableOpacity>
                    </View>
                  </View>

                  <View style={{ flexDirection: 'row', gap: 8 }}>
                    <View style={{ flex: 1 }}><FloatingInput label="OZT per unit" value={form.ozt} onChangeText={v => { setForm(p => ({ ...p, ozt: v })); if (v && parseFloat(v) > 0) setFormErrors(e => ({ ...e, ozt: false })); }} placeholder="1, 10, 100..." keyboardType="decimal-pad" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} required error={formErrors.ozt} /></View>
                    <View style={{ flex: 1 }}><FloatingInput label="Quantity" value={form.quantity} onChangeText={v => { setForm(p => ({ ...p, quantity: v })); if (v && parseInt(v) > 0) setFormErrors(e => ({ ...e, quantity: false })); }} placeholder="Quantity" keyboardType="number-pad" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} required error={formErrors.quantity} /></View>
                  </View>

                  <View style={{ flexDirection: 'row', gap: 8 }}>
                    <View style={{ flex: 1 }}><FloatingInput label="Unit Price" value={form.unitPrice} onChangeText={v => { setForm(p => ({ ...p, unitPrice: v })); if (v && parseFloat(v) > 0) setFormErrors(e => ({ ...e, unitPrice: false })); }} placeholder="0.00" keyboardType="decimal-pad" prefix="$" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} required error={formErrors.unitPrice} /></View>
                    <View style={{ flex: 1 }}><FloatingInput label="Spot at Purchase" value={form.spotPrice} onChangeText={v => { setForm(p => ({ ...p, spotPrice: v })); setSpotPriceSource(null); }} placeholder="Auto" keyboardType="decimal-pad" prefix="$" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} /></View>
                  </View>

                  {/* Accuracy indicators for historical spot prices */}
                  {spotPriceSource === 'price_log' && (
                    <Text style={{ color: '#22C55E', fontSize: scaledFonts.small, marginTop: -4, marginBottom: 4 }}>
                      Exact price from our records
                    </Text>
                  )}
                  {spotPriceSource === 'etf_derived' && (
                    <Text style={{ color: '#3B82F6', fontSize: scaledFonts.small, marginTop: -4, marginBottom: 4 }}>
                      Daily ETF-derived price. You can adjust if needed.
                    </Text>
                  )}
                  {(spotPriceSource === 'macrotrends' || spotPriceSource === 'static-json' || spotPriceSource === 'static-json-nearest') && (
                    <Text style={{ color: '#E69500', fontSize: scaledFonts.small, marginTop: -4, marginBottom: 4 }}>
                      Monthly average (daily price unavailable). You can edit this manually.
                    </Text>
                  )}
                  {(spotPriceSource === 'current-spot' || spotPriceSource === 'current-fallback' || spotPriceSource === 'client-fallback' || spotPriceSource === 'current_fallback') && (
                    <Text style={{ color: '#E69500', fontSize: scaledFonts.small, marginTop: -4, marginBottom: 4 }}>
                      Historical price unavailable - using today's spot. You can edit this manually.
                    </Text>
                  )}

                  {/* Warning when user's spot price differs significantly from historical */}
                  {historicalSpotSuggestion && (() => {
                    const userSpot = parseFloat(form.spotPrice) || 0;
                    const histSpot = historicalSpotSuggestion.price;
                    const diff = Math.abs(userSpot - histSpot);
                    const pctDiff = histSpot > 0 ? (diff / histSpot) * 100 : 0;
                    // Only show warning if difference > 10% and user has entered a value
                    if (pctDiff <= 10 || userSpot === 0) return null;
                    return (
                      <View style={{ backgroundColor: 'rgba(251, 191, 36, 0.15)', padding: 10, borderRadius: 8, marginTop: -4, marginBottom: 8, borderWidth: 1, borderColor: 'rgba(251, 191, 36, 0.3)' }}>
                        <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' }}>
                          <View style={{ flex: 1 }}>
                            <Text style={{ color: '#E69500', fontSize: scaledFonts.small, fontWeight: '600' }}>
                              Your price differs by {pctDiff.toFixed(0)}%
                            </Text>
                            <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny, marginTop: 2 }}>
                              Historical spot was ${formatCurrency(histSpot)} on {historicalSpotSuggestion.date}
                            </Text>
                          </View>
                          <TouchableOpacity
                            onPress={() => {
                              setForm(prev => ({ ...prev, spotPrice: histSpot.toString() }));
                              setSpotPriceSource(historicalSpotSuggestion.source);
                            }}
                            style={{ paddingHorizontal: 10, paddingVertical: 6, backgroundColor: 'rgba(251, 191, 36, 0.3)', borderRadius: 6, marginLeft: 8 }}
                          >
                            <Text style={{ color: '#E69500', fontSize: scaledFonts.tiny, fontWeight: '600' }}>Use ${formatCurrency(histSpot)}</Text>
                          </TouchableOpacity>
                        </View>
                      </View>
                    );
                  })()}

                  <View style={{ flexDirection: 'row', gap: 8 }}>
                    <View style={{ flex: 1 }}><FloatingInput label="Taxes" value={form.taxes} onChangeText={v => setForm(p => ({ ...p, taxes: v }))} placeholder="0.00" keyboardType="decimal-pad" prefix="$" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} /></View>
                    <View style={{ flex: 1 }}><FloatingInput label="Shipping" value={form.shipping} onChangeText={v => setForm(p => ({ ...p, shipping: v }))} placeholder="0.00" keyboardType="decimal-pad" prefix="$" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} /></View>
                  </View>

                  {/* Total Cost Basis - editable for adjustments */}
                  <View style={[styles.card, { backgroundColor: `${colors.success}15`, marginTop: 8 }]}>
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 8 }}>
                      <Text style={{ color: colors.success, fontWeight: '600', fontSize: scaledFonts.normal }}>Total Cost Basis</Text>
                      <TouchableOpacity
                        onPress={() => {
                          // Recalculate from components
                          const calculated = ((parseFloat(form.unitPrice) || 0) * (parseInt(form.quantity) || 1)) + (parseFloat(form.taxes) || 0) + (parseFloat(form.shipping) || 0);
                          setForm(p => ({ ...p, costBasis: calculated.toFixed(2) }));
                        }}
                        style={{ paddingHorizontal: 8, paddingVertical: 4, backgroundColor: `${colors.success}30`, borderRadius: 6 }}
                      >
                        <Text style={{ color: colors.success, fontSize: scaledFonts.tiny }}>Recalculate</Text>
                      </TouchableOpacity>
                    </View>
                    <FloatingInput
                      label="Total Cost (adjust if needed)"
                      value={form.costBasis || (((parseFloat(form.unitPrice) || 0) * (parseInt(form.quantity) || 1)) + (parseFloat(form.taxes) || 0) + (parseFloat(form.shipping) || 0)).toFixed(2)}
                      onChangeText={v => setForm(p => ({ ...p, costBasis: v }))}
                      placeholder="0"
                      keyboardType="decimal-pad"
                      prefix="$"
                      colors={colors}
                      isDarkMode={isDarkMode}
                      scaledFonts={scaledFonts}
                    />
                    <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny, marginTop: 4 }}>
                      Edit to adjust for forgotten costs or corrections
                    </Text>
                  </View>

                  <View style={[styles.card, { backgroundColor: `${colors.gold}15` }]}>
                    <Text style={{ color: colors.gold, fontWeight: '600', marginBottom: 8, fontSize: scaledFonts.normal }}>Premium (Auto-calculated)</Text>
                    <View style={{ flexDirection: 'row', gap: 8 }}>
                      <View style={{ flex: 1 }}><FloatingInput label="Per Unit" value={form.premium} onChangeText={v => setForm(p => ({ ...p, premium: v }))} keyboardType="decimal-pad" prefix="$" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} /></View>
                      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
                        {(() => {
                          const totalPremium = parseFloat(form.premium || 0) * parseInt(form.quantity || 1);
                          const unitPrice = parseFloat(form.unitPrice || 0);
                          const premiumPct = calculatePremiumPercent(parseFloat(form.premium || 0), unitPrice);
                          return (
                            <>
                              <Text style={{ color: colors.muted, fontSize: scaledFonts.small }}>Total: ${formatCurrency(totalPremium)}</Text>
                              {premiumPct > 0 && (
                                <Text style={{ color: colors.gold, fontSize: scaledFonts.tiny, marginTop: 2 }}>+{premiumPct.toFixed(1)}%</Text>
                              )}
                            </>
                          );
                        })()}
                      </View>
                    </View>
                  </View>
                </ScrollView>

                {/* Sticky Save Button */}
                <View style={[styles.stickyButtonContainer, { backgroundColor: isDarkMode ? '#1a1a2e' : '#ffffff', borderTopColor: colors.border }]}>
                  <TouchableOpacity style={[styles.button, { backgroundColor: colors.gold }]} onPress={() => { Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium); savePurchase(); }}>
                    <Text style={{ color: '#000', fontWeight: '600', fontSize: scaledFonts.normal }}>{editingItem ? 'Update' : 'Add'} Purchase</Text>
                  </TouchableOpacity>
                </View>
              </View>
            </KeyboardAvoidingView>

            {/* DATE/TIME PICKER OVERLAYS â€” must be inside this Modal */}
            <DatePickerModal
              visible={showDatePicker}
              onClose={() => setShowDatePicker(false)}
              initialDate={form.datePurchased}
              onConfirm={(date) => {
                setShowDatePicker(false);
                handleDateChange(date);
              }}
            />
            <TimePickerModal
              visible={showTimePicker}
              onClose={() => setShowTimePicker(false)}
              initialTime={form.timePurchased}
              onConfirm={(time) => {
                setShowTimePicker(false);
                handleTimeChange(time);
              }}
            />
          </View>
      </Modal>

      {/* SPECULATION MODAL */}
      <ModalWrapper
        visible={showSpeculationModal}
        onClose={() => setShowSpeculationModal(false)}
        title="What If..."
        colors={colors}
        isDarkMode={isDarkMode}
      >
        {/* Inputs at TOP */}
        <View style={{ flexDirection: 'row', gap: 8, marginBottom: 8 }}>
          <View style={{ flex: 1 }}><FloatingInput label="Silver" value={specSilverPrice} onChangeText={setSpecSilverPrice} keyboardType="decimal-pad" prefix="$" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} /></View>
          <View style={{ flex: 1 }}><FloatingInput label="Gold" value={specGoldPrice} onChangeText={setSpecGoldPrice} keyboardType="decimal-pad" prefix="$" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} /></View>
        </View>
        <View style={{ flexDirection: 'row', gap: 8, marginBottom: 8 }}>
          <View style={{ flex: 1 }}><FloatingInput label="Platinum" value={specPlatinumPrice} onChangeText={setSpecPlatinumPrice} keyboardType="decimal-pad" prefix="$" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} /></View>
          <View style={{ flex: 1 }}><FloatingInput label="Palladium" value={specPalladiumPrice} onChangeText={setSpecPalladiumPrice} keyboardType="decimal-pad" prefix="$" colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} /></View>
        </View>

        {/* Quick presets */}
        <ScrollView horizontal showsHorizontalScrollIndicator={false} style={{ marginBottom: 16 }}>
          {[
            { s: 200, g: 7500, pt: 3000, pd: 2500, label: 'Bull' },
            { s: 350, g: 10000, pt: 5000, pd: 4000, label: 'Moon' },
            { s: 1000, g: 25000, pt: 10000, pd: 8000, label: 'Hyper' },
          ].map((preset, i) => (
            <TouchableOpacity key={i} style={{ backgroundColor: colors.border, padding: 12, borderRadius: 12, marginRight: 8 }} onPress={() => { setSpecSilverPrice(preset.s.toString()); setSpecGoldPrice(preset.g.toString()); setSpecPlatinumPrice(preset.pt.toString()); setSpecPalladiumPrice(preset.pd.toString()); Keyboard.dismiss(); }}>
              <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>{preset.label}</Text>
              <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny }}>Ag ${preset.s} / Au ${preset.g}</Text>
            </TouchableOpacity>
          ))}
        </ScrollView>

        {/* Results */}
        <View style={[styles.card, { backgroundColor: `${colors.success}22` }]}>
          <Text style={{ color: colors.success, fontWeight: '600', fontSize: scaledFonts.normal }}>Projected Value</Text>
          <Text style={{ color: colors.text, fontSize: scaledFonts.huge, fontWeight: '700' }}>${specTotalValue.toLocaleString(undefined, { minimumFractionDigits: 2 })}</Text>
          <Text style={{ color: specGainLoss >= 0 ? colors.success : colors.error, fontSize: scaledFonts.normal }}>{specGainLoss >= 0 ? '+' : ''}{specGainLossPct.toFixed(1)}% from cost basis</Text>
        </View>

        <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8 }}>
          {[
            { label: 'Silver', color: colors.silver, value: totalSilverOzt * specSilverNum },
            { label: 'Gold', color: colors.gold, value: totalGoldOzt * specGoldNum },
            { label: 'Platinum', color: colors.platinum, value: totalPlatinumOzt * specPlatinumNum },
            { label: 'Palladium', color: colors.palladium, value: totalPalladiumOzt * specPalladiumNum },
          ].filter(m => m.value > 0).map(m => (
            <View key={m.label} style={[styles.card, { width: '47%', backgroundColor: `${m.color}22` }]}>
              <Text style={{ color: m.color, fontSize: scaledFonts.small }}>{m.label}</Text>
              <Text style={{ color: colors.text, fontSize: scaledFonts.large, fontWeight: '600' }}>${m.value.toLocaleString()}</Text>
            </View>
          ))}
        </View>
      </ModalWrapper>

      {/* JUNK SILVER MODAL */}
      <ModalWrapper
        visible={showJunkCalcModal}
        onClose={() => setShowJunkCalcModal(false)}
        title="ðŸ§® Junk Silver Calculator"
        colors={colors}
        isDarkMode={isDarkMode}
      >
        {/* Type selector at TOP */}
        <View style={{ flexDirection: 'row', gap: 8, marginBottom: 16 }}>
          {[{ k: '90', l: '90%' }, { k: '40', l: '40%' }, { k: '35', l: 'War Nickels' }].map(t => (
            <TouchableOpacity key={t.k} style={[styles.metalTab, { flex: 1, borderColor: junkType === t.k ? colors.silver : colors.border, backgroundColor: junkType === t.k ? `${colors.silver}22` : 'transparent' }]} onPress={() => { setJunkType(t.k); Keyboard.dismiss(); }}>
              <Text style={{ color: junkType === t.k ? colors.silver : colors.muted, fontSize: scaledFonts.small }}>{t.l}</Text>
            </TouchableOpacity>
          ))}
        </View>

        {/* Input */}
        <FloatingInput label={junkType === '35' ? '# of Nickels' : 'Face Value ($)'} value={junkFaceValue} onChangeText={setJunkFaceValue} keyboardType="decimal-pad" prefix={junkType === '35' ? '' : '$'} colors={colors} isDarkMode={isDarkMode} scaledFonts={scaledFonts} />

        {/* Results */}
        <View style={[styles.card, { backgroundColor: `${colors.silver}22` }]}>
          <Text style={{ color: colors.silver, fontSize: scaledFonts.normal }}>Silver Content</Text>
          <Text style={{ color: colors.text, fontSize: scaledFonts.xlarge, fontWeight: '700' }}>{junkOzt.toFixed(3)} oz</Text>
        </View>

        <View style={[styles.card, { backgroundColor: `${colors.success}22` }]}>
          <Text style={{ color: colors.success, fontSize: scaledFonts.normal }}>Melt Value @ ${formatCurrency(silverSpot)}/oz</Text>
          <Text style={{ color: colors.text, fontSize: scaledFonts.huge, fontWeight: '700' }}>${formatCurrency(junkMeltValue)}</Text>
        </View>

        <View style={{ backgroundColor: isDarkMode ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)', padding: 12, borderRadius: 8 }}>
          <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny }}>
            {junkType === '90' && '90% silver: Pre-1965 dimes, quarters, halves. Multiply face value Ã— 0.715 for oz.'}
            {junkType === '40' && '40% silver: 1965-1970 Kennedy halves. Multiply face value Ã— 0.295 for oz.'}
            {junkType === '35' && '35% silver: War Nickels (1942-1945). Each contains 0.0563 oz silver.'}
          </Text>
        </View>
      </ModalWrapper>

      {/* PREMIUM ANALYSIS MODAL */}
      <ModalWrapper
        visible={showPremiumAnalysisModal}
        onClose={() => setShowPremiumAnalysisModal(false)}
        title="Premium Analysis"
        colors={colors}
        isDarkMode={isDarkMode}
      >
        {(() => {
          // Simply read saved item.premium values â€” already calculated when added/edited
          const metalPremiums = [
            { key: 'silver', label: 'Silver', items: silverItems, color: colors.silver },
            { key: 'gold', label: 'Gold', items: goldItems, color: colors.gold },
            { key: 'platinum', label: 'Platinum', items: platinumItems, color: colors.platinum },
            { key: 'palladium', label: 'Palladium', items: palladiumItems, color: colors.palladium },
          ];

          let grandTotal = 0;
          let totalAll = 0;
          let totalWith = 0;
          metalPremiums.forEach(m => {
            totalAll += m.items.length;
            const withPremium = m.items.filter(i => (i.premium || 0) > 0);
            totalWith += withPremium.length;
            grandTotal += withPremium.reduce((sum, i) => sum + i.premium * i.quantity, 0);
          });

          return (
            <>
              {metalPremiums.filter(m => m.items.length > 0).map(m => {
                const withPremium = m.items.filter(i => (i.premium || 0) > 0);
                const metalTotal = withPremium.reduce((sum, i) => sum + i.premium * i.quantity, 0);
                return (
                  <View key={m.key} style={[styles.card, { backgroundColor: `${m.color}15`, borderColor: `${m.color}30` }]}>
                    <Text style={{ color: m.color, fontWeight: '700', fontSize: scaledFonts.normal, marginBottom: 8 }}>{m.label} Premiums</Text>
                    {withPremium.length > 0 ? (
                      <>
                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                          <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Total Paid</Text>
                          <Text style={{ color: colors.text, fontSize: scaledFonts.normal, fontWeight: '600' }}>${formatCurrency(metalTotal)}</Text>
                        </View>
                        <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 }}>
                          <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>Avg per Unit</Text>
                          <Text style={{ color: colors.text, fontSize: scaledFonts.normal }}>${formatCurrency(metalTotal / withPremium.reduce((s, i) => s + i.quantity, 0))}</Text>
                        </View>
                      </>
                    ) : (
                      <Text style={{ color: colors.muted, fontSize: scaledFonts.small, marginBottom: 4 }}>No premium data available</Text>
                    )}
                    <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny, marginTop: 4 }}>
                      {withPremium.length} of {m.items.length} holding{m.items.length !== 1 ? 's' : ''} with data
                    </Text>
                  </View>
                );
              })}

              {/* Total */}
              <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
                <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                  <Text style={{ color: colors.text, fontWeight: '700', fontSize: scaledFonts.medium }}>Total Premiums Paid</Text>
                  <Text style={{ color: colors.gold, fontSize: scaledFonts.large, fontWeight: '700' }}>${formatCurrency(grandTotal)}</Text>
                </View>
                <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny, marginTop: 8 }}>
                  {totalWith} of {totalAll} holding{totalAll !== 1 ? 's' : ''} with premium data
                </Text>
              </View>

              {totalWith === 0 && (
                <View style={[styles.card, { backgroundColor: isDarkMode ? 'rgba(251,191,36,0.1)' : 'rgba(251,191,36,0.15)', borderColor: `${colors.gold}30` }]}>
                  <Text style={{ color: colors.gold, fontWeight: '600', fontSize: scaledFonts.normal, marginBottom: 4 }}>How to add premium data</Text>
                  <Text style={{ color: colors.muted, fontSize: scaledFonts.small }}>
                    Edit a holding and enter the "Spot at Purchase" price. The premium will be calculated automatically as the difference between your unit price and the spot price.
                  </Text>
                </View>
              )}
            </>
          );
        })()}
      </ModalWrapper>

      {/* PRIVACY MODAL */}
      <ModalWrapper
        visible={showPrivacyModal}
        onClose={() => setShowPrivacyModal(false)}
        title="Privacy & Security"
        colors={colors}
        isDarkMode={isDarkMode}
      >
        <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
          <Text style={[styles.cardTitle, { color: colors.success }]}>How We Protect Your Data</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Your portfolio data is stored securely on our servers for sync and backup</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ All data is encrypted in transit and at rest</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Guest mode keeps data only on your device</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Receipt images are processed in memory and deleted immediately after scanning</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Analytics snapshots are stored to power your portfolio charts</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Push notification tokens are stored only to deliver alerts you've opted into</Text>
        </View>
        <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
          <Text style={[styles.cardTitle, { color: '#007AFF' }]}>AI-Powered Features</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Troy's Take and Troy's Analysis use Google Gemini AI</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Portfolio data is sent to the AI provider for analysis only</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ AI-generated content is for informational purposes, not financial advice</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Your data is not shared beyond the AI provider</Text>
        </View>
        <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
          <Text style={[styles.cardTitle, { color: colors.error }]}>What We Never Do</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Sell or share your data with third parties</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Share your information with advertisers</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Track your browsing or behavior outside the app</Text>
          <Text style={[styles.privacyItem, { color: colors.text }]}>â€¢ Use push tokens for advertising or tracking</Text>
        </View>
        <View style={[styles.card, { backgroundColor: `${colors.success}22` }]}>
          <Text style={{ color: colors.success, fontWeight: '600' }}>Your Data, Your Control</Text>
          <Text style={{ color: colors.muted, fontStyle: 'italic' }}>"Your data is private and secure. We store it only to power your experience - never to sell or share."</Text>
        </View>
        <TouchableOpacity
          style={{ alignItems: 'center', paddingVertical: 16 }}
          onPress={() => Linking.openURL('https://api.stacktrackergold.com/privacy')}
        >
          <Text style={{ color: '#007AFF', fontSize: scaledFonts.normal }}>View Complete Privacy Policy</Text>
        </TouchableOpacity>
      </ModalWrapper>

      {/* Help Guide Modal */}
      <ModalWrapper
        visible={showHelpModal}
        onClose={() => setShowHelpModal(false)}
        title="Help Guide"
        colors={colors}
        isDarkMode={isDarkMode}
      >
        <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
          <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Today Tab</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Portfolio Pulse â€” Daily P/L and portfolio snapshot</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Metal Movers â€” Spot price changes across all metals</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Vault Watch â€” COMEX warehouse inventory for Ag, Au, Pt</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Market Intelligence â€” AI-curated news and analysis</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Troy's Take â€” AI market summary delivered to your feed</Text>
        </View>

        <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
          <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Stack Tab</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Add holdings manually with the "+" button</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} AI Receipt Scanner â€” Snap a photo to auto-extract purchase data</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Swipe left on a holding to edit or delete</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Pull down to refresh live spot prices</Text>
          <View style={{ backgroundColor: 'rgba(251, 191, 36, 0.15)', padding: 10, borderRadius: 8, marginTop: 8 }}>
            <Text style={{ color: colors.gold, fontSize: scaledFonts.small, fontWeight: '600' }}>Tip: Digital screenshots of online receipts work best for scanning!</Text>
          </View>
        </View>

        <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
          <View style={{ flexDirection: 'row', alignItems: 'center', gap: 6, marginBottom: 8 }}>
            <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Analytics Tab</Text>
            <View style={{ backgroundColor: 'rgba(251, 191, 36, 0.2)', paddingHorizontal: 6, paddingVertical: 2, borderRadius: 4 }}>
              <Text style={{ color: colors.gold, fontSize: scaledFonts.tiny, fontWeight: '600' }}>GOLD</Text>
            </View>
          </View>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Troy's Analysis â€” AI analysis of your holdings</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Portfolio Value Chart â€” Track value over 1D to All Time</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Spot Price History â€” Historical charts for each metal</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Cost Basis Analysis â€” Total cost, P/L, and avg premium per metal</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Break-Even Analysis â€” Spot price needed to break even</Text>
        </View>

        <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
          <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Tools Tab</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Price Alerts â€” Push notifications when metals hit your target</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Share My Stack â€” Generate a shareable portfolio image</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Speculation Tool â€” Model portfolio value at hypothetical prices</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Junk Silver Calculator â€” Melt value for constitutional silver</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Stack Milestones â€” Set and track oz goals</Text>
        </View>

        <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
          <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Settings</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Notifications â€” Toggle Troy's Take, price alerts, breaking news</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Appearance â€” Light, dark, or auto theme</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Export & Backup â€” Backup, restore, or export CSV</Text>
        </View>

        {Platform.OS === 'ios' && (
          <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
            <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Widgets</Text>
            <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Home screen widgets with live portfolio value and spot prices</Text>
            <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Long-press home screen {'\u2192'} "+" {'\u2192'} search "Stack Tracker Gold"</Text>
            <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Small, medium, and large sizes available</Text>
          </View>
        )}

        <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
          <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Push Notifications</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Troy's Take â€” Daily market summary push</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Price Alerts â€” Triggered when your targets are hit</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Breaking News & COMEX â€” Major events and vault changes</Text>
          <Text style={[styles.privacyItem, { color: colors.muted, fontSize: scaledFonts.small, marginTop: 4 }]}>Manage in Settings {'\u2192'} Notifications</Text>
        </View>

        <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
          <Text style={[styles.cardTitle, { color: colors.text, fontSize: scaledFonts.medium }]}>Support</Text>
          <Text style={[styles.privacyItem, { color: colors.text, fontSize: scaledFonts.small }]}>{'\u2022'} Email stacktrackergold@gmail.com for help</Text>
        </View>
      </ModalWrapper>

      {/* Gold Paywall */}
      <GoldPaywall
        visible={showPaywallModal}
        onClose={() => setShowPaywallModal(false)}
        onPurchaseSuccess={checkEntitlements}
      />

      {/* Add Price Alert Modal */}
      <ModalWrapper
        visible={showAddAlertModal}
        onClose={() => {
          setShowAddAlertModal(false);
          setNewAlert({ metal: 'silver', targetPrice: '', direction: 'above' });
        }}
        title="Price Alerts"
        colors={colors}
        isDarkMode={isDarkMode}
      >
        {/* TODO v2.1: ATH alerts section removed â€” implement with backend tracking */}

        {/* Custom Price Alert */}
        <View style={{ marginBottom: 20 }}>
          <Text style={{ color: colors.text, fontWeight: '700', fontSize: 16, marginBottom: 12 }}>New Alert</Text>
          <Text style={{ color: colors.muted, fontSize: 12, marginBottom: 16 }}>
            Get notified when spot prices reach your target
          </Text>

          {/* Metal Selection */}
          <Text style={{ color: colors.text, fontWeight: '600', marginBottom: 8 }}>Metal</Text>
          <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8, marginBottom: 16 }}>
            {[
              { key: 'silver', label: 'Silver', color: colors.silver },
              { key: 'gold', label: 'Gold', color: colors.gold },
              { key: 'platinum', label: 'Platinum', color: colors.platinum },
              { key: 'palladium', label: 'Palladium', color: colors.palladium },
            ].map((m) => (
              <TouchableOpacity
                key={m.key}
                style={{
                  width: '47%',
                  paddingVertical: 12,
                  borderRadius: 8,
                  backgroundColor: newAlert.metal === m.key
                    ? m.color
                    : (isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)'),
                  alignItems: 'center',
                }}
                onPress={() => {
                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                  setNewAlert(prev => ({ ...prev, metal: m.key }));
                }}
              >
                <Text style={{
                  color: newAlert.metal === m.key ? '#000' : colors.text,
                  fontWeight: '600',
                }}>
                  {m.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>

          {/* Direction Selection */}
          <Text style={{ color: colors.text, fontWeight: '600', marginBottom: 8 }}>Alert When Price Goes...</Text>
          <View style={{ flexDirection: 'row', gap: 8, marginBottom: 16 }}>
            {[
              { key: 'above', label: 'â†‘ Above' },
              { key: 'below', label: 'â†“ Below' },
            ].map((option) => (
              <TouchableOpacity
                key={option.key}
                style={{
                  flex: 1,
                  paddingVertical: 12,
                  borderRadius: 8,
                  backgroundColor: newAlert.direction === option.key
                    ? (option.key === 'above' ? colors.success : colors.error)
                    : (isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)'),
                  alignItems: 'center',
                }}
                onPress={() => {
                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                  setNewAlert(prev => ({ ...prev, direction: option.key }));
                }}
              >
                <Text style={{
                  color: newAlert.direction === option.key ? '#fff' : colors.text,
                  fontWeight: '600',
                }}>
                  {option.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>

          {/* Target Price Input */}
          <Text style={{ color: colors.text, fontWeight: '600', marginBottom: 8 }}>Target Price ($/oz)</Text>
          <View style={{
            flexDirection: 'row',
            alignItems: 'center',
            backgroundColor: isDarkMode ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.05)',
            borderRadius: 8,
            paddingHorizontal: 12,
            borderWidth: 1,
            borderColor: colors.border,
          }}>
            <Text style={{ color: colors.text, fontSize: 16, marginRight: 4 }}>$</Text>
            <TextInput
              style={{ flex: 1, color: colors.text, fontSize: 16, paddingVertical: 14 }}
              value={newAlert.targetPrice}
              onChangeText={(value) => setNewAlert(prev => ({ ...prev, targetPrice: value }))}
              keyboardType="decimal-pad"
              placeholder={{ gold: '4500.00', silver: '75.00', platinum: '2100.00', palladium: '1740.00' }[newAlert.metal] || '75.00'}
              placeholderTextColor={colors.muted}
            />
          </View>
          <Text style={{ color: colors.muted, fontSize: 11, marginTop: 4 }}>
            Current {{ gold: 'gold', silver: 'silver', platinum: 'platinum', palladium: 'palladium' }[newAlert.metal]} spot: ${{ gold: goldSpot, silver: silverSpot, platinum: platinumSpot, palladium: palladiumSpot }[newAlert.metal]?.toFixed(2)}/oz
          </Text>
        </View>

        {/* Create / Update Alert Button */}
        <TouchableOpacity
          style={{
            backgroundColor: colors.gold,
            padding: 16,
            borderRadius: 10,
            alignItems: 'center',
          }}
          onPress={createPriceAlert}
        >
          <Text style={{ color: '#000', fontWeight: '700', fontSize: 16 }}>Create Alert</Text>
        </TouchableOpacity>

        {!expoPushToken && (
          <View style={{ marginTop: 16, alignItems: 'center' }}>
            <Text style={{ color: colors.error, fontSize: 12, textAlign: 'center', marginBottom: 10 }}>
              Push notifications not enabled. Tap below to allow notifications.
            </Text>
            <TouchableOpacity
              style={{
                backgroundColor: '#FF9500',
                paddingHorizontal: 20,
                paddingVertical: 10,
                borderRadius: 8,
              }}
              onPress={async () => {
                Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
                const token = await registerForPushNotifications();
                if (token) {
                  setExpoPushToken(token);
                  Alert.alert('Notifications Enabled', 'You will now receive price alert notifications.');
                } else {
                  Alert.alert('Notifications Blocked', 'Please enable notifications for Stack Tracker in your iOS Settings app.', [
                    { text: 'Open Settings', onPress: () => Linking.openSettings() },
                    { text: 'Cancel', style: 'cancel' },
                  ]);
                }
              }}
            >
              <Text style={{ color: '#fff', fontWeight: '700', fontSize: 14 }}>Enable Notifications</Text>
            </TouchableOpacity>
          </View>
        )}

        {/* Saved Alerts List */}
        {priceAlerts.length > 0 && (
          <View style={{ marginTop: 24 }}>
            <View style={{ height: 1, backgroundColor: colors.border, marginBottom: 16 }} />
            <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 }}>
              <Text style={{ color: colors.text, fontWeight: '700', fontSize: 16 }}>Your Alerts</Text>
              <TouchableOpacity onPress={clearAllAlerts} hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}>
                <Text style={{ color: '#F44336', fontSize: 13, fontWeight: '600' }}>Clear All</Text>
              </TouchableOpacity>
            </View>
            {priceAlerts.map((alert) => (
              <SwipeableAlertRow
                key={alert.id}
                alert={alert}
                colors={colors}
                onDelete={deletePriceAlertDirect}
                onToggle={togglePriceAlert}
                spotPrices={{ gold: goldSpot, silver: silverSpot, platinum: platinumSpot, palladium: palladiumSpot }}
              />
            ))}
          </View>
        )}
      </ModalWrapper>

      {/* Edit Milestones Modal */}
      <ModalWrapper
        visible={showMilestoneModal}
        onClose={() => {
          setShowMilestoneModal(false);
          setTempSilverMilestone('');
          setTempGoldMilestone('');
        }}
        title="Edit Stack Milestones"
        colors={colors}
        isDarkMode={isDarkMode}
      >
        <View style={{ marginBottom: 20 }}>
          <Text style={{ color: colors.muted, marginBottom: 16, fontSize: scaledFonts.small }}>
            Set custom goals for your stack. Leave blank to use default milestones.
          </Text>

          {/* Current Progress Summary */}
          <View style={{
            backgroundColor: isDarkMode ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.03)',
            padding: 12,
            borderRadius: 8,
            marginBottom: 20
          }}>
            <Text style={{ color: colors.muted, fontSize: scaledFonts.tiny, marginBottom: 4 }}>Current Stack</Text>
            <Text style={{ color: colors.silver, fontWeight: '600', fontSize: scaledFonts.normal }}>
              Silver: {totalSilverOzt.toFixed(1)} oz
            </Text>
            <Text style={{ color: colors.gold, fontWeight: '600', fontSize: scaledFonts.normal }}>
              Gold: {totalGoldOzt.toFixed(3)} oz
            </Text>
          </View>

          {/* Silver Milestone Input */}
          <Text style={{ color: colors.text, fontWeight: '600', marginBottom: 8, fontSize: scaledFonts.normal }}>Silver Goal (oz)</Text>
          <View style={{
            flexDirection: 'row',
            alignItems: 'center',
            backgroundColor: isDarkMode ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.05)',
            borderRadius: 8,
            paddingHorizontal: 12,
            borderWidth: 1,
            borderColor: colors.border,
            marginBottom: 12,
          }}>
            <TextInput
              style={{ flex: 1, color: colors.text, fontSize: scaledFonts.medium, paddingVertical: 14 }}
              value={tempSilverMilestone}
              onChangeText={setTempSilverMilestone}
              keyboardType="decimal-pad"
              placeholder={`Default: ${defaultSilverMilestones.find(m => totalSilverOzt < m) || 1000}`}
              placeholderTextColor={colors.muted}
            />
            <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>oz</Text>
          </View>

          {/* Quick Silver Suggestions */}
          <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8, marginBottom: 20 }}>
            {[100, 250, 500, 1000].map((val) => (
              <TouchableOpacity
                key={`silver-${val}`}
                style={{
                  paddingHorizontal: 12,
                  paddingVertical: 6,
                  borderRadius: 16,
                  backgroundColor: isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)',
                }}
                onPress={() => {
                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                  setTempSilverMilestone(val.toString());
                }}
              >
                <Text style={{ color: colors.silver, fontSize: scaledFonts.small }}>{val} oz</Text>
              </TouchableOpacity>
            ))}
          </View>

          {/* Gold Milestone Input */}
          <Text style={{ color: colors.text, fontWeight: '600', marginBottom: 8, fontSize: scaledFonts.normal }}>Gold Goal (oz)</Text>
          <View style={{
            flexDirection: 'row',
            alignItems: 'center',
            backgroundColor: isDarkMode ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.05)',
            borderRadius: 8,
            paddingHorizontal: 12,
            borderWidth: 1,
            borderColor: colors.border,
            marginBottom: 12,
          }}>
            <TextInput
              style={{ flex: 1, color: colors.text, fontSize: scaledFonts.medium, paddingVertical: 14 }}
              value={tempGoldMilestone}
              onChangeText={setTempGoldMilestone}
              keyboardType="decimal-pad"
              placeholder={`Default: ${defaultGoldMilestones.find(m => totalGoldOzt < m) || 100}`}
              placeholderTextColor={colors.muted}
            />
            <Text style={{ color: colors.muted, fontSize: scaledFonts.normal }}>oz</Text>
          </View>

          {/* Quick Gold Suggestions */}
          <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8, marginBottom: 20 }}>
            {[5, 10, 25, 50].map((val) => (
              <TouchableOpacity
                key={`gold-${val}`}
                style={{
                  paddingHorizontal: 12,
                  paddingVertical: 6,
                  borderRadius: 16,
                  backgroundColor: isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)',
                }}
                onPress={() => {
                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                  setTempGoldMilestone(val.toString());
                }}
              >
                <Text style={{ color: colors.gold, fontSize: scaledFonts.small }}>{val} oz</Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        {/* Save Button */}
        <TouchableOpacity
          style={{
            backgroundColor: colors.gold,
            padding: 16,
            borderRadius: 10,
            alignItems: 'center',
            marginBottom: 12,
          }}
          onPress={saveMilestones}
        >
          <Text style={{ color: '#000', fontWeight: '700', fontSize: scaledFonts.medium }}>Save Goals</Text>
        </TouchableOpacity>

        {/* Reset to Defaults Button */}
        {(customSilverMilestone || customGoldMilestone) && (
          <TouchableOpacity
            style={{
              padding: 12,
              borderRadius: 10,
              alignItems: 'center',
              backgroundColor: isDarkMode ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.03)',
            }}
            onPress={async () => {
              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
              setCustomSilverMilestone(null);
              setCustomGoldMilestone(null);
              setTempSilverMilestone('');
              setTempGoldMilestone('');
              await AsyncStorage.removeItem('stack_silver_milestone');
              await AsyncStorage.removeItem('stack_gold_milestone');
              setShowMilestoneModal(false);
            }}
          >
            <Text style={{ color: colors.muted, fontWeight: '500', fontSize: scaledFonts.normal }}>Reset to Default Milestones</Text>
          </TouchableOpacity>
        )}
      </ModalWrapper>

      {/* Scanned Items Preview Modal */}
      <ModalWrapper
        visible={showScannedItemsPreview}
        onClose={() => {
          setShowScannedItemsPreview(false);
          setScannedItems([]);
          setScannedMetadata({ purchaseDate: '', purchaseTime: '', dealer: '' });
        }}
        title="Receipt Scanned"
        colors={colors}
        isDarkMode={isDarkMode}
      >
        <View style={{ marginBottom: 16 }}>
          <Text style={{ color: colors.success, fontSize: 18, fontWeight: '600', marginBottom: 4 }}>
            Found {scannedItems.length} Item{scannedItems.length > 1 ? 's' : ''}
          </Text>
          {scannedMetadata.dealer && (
            <Text style={{ color: colors.muted, fontSize: 12 }}>Dealer: {scannedMetadata.dealer}</Text>
          )}
          {scannedMetadata.purchaseDate && (
            <Text style={{ color: colors.muted, fontSize: 12 }}>Date: {scannedMetadata.purchaseDate}{scannedMetadata.purchaseTime ? ` at ${scannedMetadata.purchaseTime}` : ''}</Text>
          )}
        </View>

        {scannedItems.map((item, index) => {
          const itemMetal = item.metal || 'silver';
          const itemColor = itemMetal === 'silver' ? colors.silver : colors.gold;

          return (
            <View key={index} style={[styles.card, { marginBottom: 12, padding: 12, borderLeftWidth: 3, borderLeftColor: itemColor }]}>
              <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: 8 }}>
                <View style={{ flex: 1 }}>
                  <Text style={{ color: colors.text, fontWeight: '600', fontSize: 14 }}>{item.productName || 'Unknown Item'}</Text>
                  <Text style={{ color: itemColor, fontSize: 12, marginTop: 2 }}>
                    {itemMetal.toUpperCase()} â€¢ {item.ozt ?? 0} oz{(item.quantity ?? 1) > 1 ? ` â€¢ Qty: ${item.quantity}` : ''}
                  </Text>
                </View>
              </View>

              {/* Editable Price Fields */}
              <View style={{ flexDirection: 'row', gap: 12, marginTop: 8 }}>
                <View style={{ flex: 1 }}>
                  <Text style={{ color: colors.muted, fontSize: 10, marginBottom: 4 }}>Unit Price</Text>
                  <View style={{ flexDirection: 'row', alignItems: 'center', backgroundColor: colors.cardBg, borderRadius: 6, paddingHorizontal: 8 }}>
                    <Text style={{ color: colors.text, fontSize: 14 }}>$</Text>
                    <TextInput
                      style={{ flex: 1, color: colors.text, fontSize: 14, paddingVertical: 8 }}
                      value={(item.unitPrice ?? 0).toFixed(2)}
                      keyboardType="decimal-pad"
                      onChangeText={(value) => updateScannedItemPrice(index, 'unitPrice', value)}
                      selectTextOnFocus
                    />
                  </View>
                </View>
                <View style={{ flex: 1 }}>
                  <Text style={{ color: colors.muted, fontSize: 10, marginBottom: 4 }}>Line Total{(item.quantity ?? 1) > 1 ? ` (Ã—${item.quantity})` : ''}</Text>
                  <View style={{ flexDirection: 'row', alignItems: 'center', backgroundColor: colors.cardBg, borderRadius: 6, paddingHorizontal: 8 }}>
                    <Text style={{ color: colors.text, fontSize: 14 }}>$</Text>
                    <TextInput
                      style={{ flex: 1, color: colors.text, fontSize: 14, paddingVertical: 8 }}
                      value={(item.extPrice ?? 0).toFixed(2)}
                      keyboardType="decimal-pad"
                      onChangeText={(value) => updateScannedItemPrice(index, 'extPrice', value)}
                      selectTextOnFocus
                    />
                  </View>
                </View>
              </View>

              {(item.spotPrice ?? 0) > 0 && (
                <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginTop: 8 }}>
                  <Text style={{ color: colors.muted, fontSize: 11 }}>
                    Spot: ${(item.spotPrice ?? 0).toFixed(2)}
                  </Text>
                  {(item.premium ?? 0) !== 0 && (
                    <Text style={{ color: (item.premium ?? 0) > 0 ? colors.gold : colors.error, fontSize: 11 }}>
                      Premium: ${(item.premium ?? 0).toFixed(2)}
                    </Text>
                  )}
                </View>
              )}

              {/* Price warning for suspicious values */}
              {item.priceWarning && (
                <View style={{ backgroundColor: 'rgba(239, 68, 68, 0.15)', padding: 8, borderRadius: 6, marginTop: 8 }}>
                  <Text style={{ color: colors.error, fontSize: 11 }}>{item.priceWarning}</Text>
                </View>
              )}

              <TouchableOpacity
                style={{
                  marginTop: 10,
                  paddingVertical: 6,
                  paddingHorizontal: 12,
                  backgroundColor: 'rgba(251,191,36,0.2)',
                  borderRadius: 6,
                  alignSelf: 'flex-start',
                }}
                onPress={() => editScannedItem(index)}
              >
                <Text style={{ color: colors.gold, fontSize: 12, fontWeight: '600' }}>Edit All Details</Text>
              </TouchableOpacity>
            </View>
          );
        })}

        {/* AI Disclaimer */}
        <Text style={{ color: colors.muted, fontSize: 11, textAlign: 'center', marginTop: 12, marginBottom: 8 }}>
          AI scanner may make mistakes. Please verify all values before adding.
        </Text>

        <View style={{ marginTop: 8 }}>
          <TouchableOpacity
            style={[styles.button, { backgroundColor: colors.success, marginBottom: 8 }]}
            onPress={confirmScannedItems}
          >
            <Text style={{ color: '#000', fontWeight: '600', fontSize: 16 }}>
              {scannedItems.length === 1
                ? 'Add Item'
                : `Add All ${scannedItems.length} Items`}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.buttonOutline]}
            onPress={() => {
              setShowScannedItemsPreview(false);
              setScannedItems([]);
              setScannedMetadata({ purchaseDate: '', purchaseTime: '', dealer: '' });
            }}
          >
            <Text style={{ color: colors.text }}>Cancel</Text>
          </TouchableOpacity>
        </View>
      </ModalWrapper>

      {/* Dealer Selector Modal */}
      <Modal visible={showDealerSelector} animationType="slide" transparent>
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, { backgroundColor: isDarkMode ? '#1a1a2e' : '#ffffff', maxHeight: '80%' }]}>
            {/* Header */}
            <View style={[styles.modalHeader, { borderBottomColor: colors.border }]}>
              <Text style={[styles.modalTitle, { color: colors.text }]}>Select Dealer</Text>
              <TouchableOpacity
                onPress={() => {
                  setShowDealerSelector(false);
                  setPendingImportFile(null);
                  setSelectedDealer(null);
                }}
                style={[styles.closeButton, { backgroundColor: isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)' }]}
                hitSlop={{ top: 20, bottom: 20, left: 20, right: 20 }}
              >
                <Text style={[styles.closeButtonText, { color: colors.text }]}>âœ•</Text>
              </TouchableOpacity>
            </View>

            <ScrollView style={{ padding: 20 }} showsVerticalScrollIndicator={false}>
              <Text style={{ color: colors.muted, marginBottom: 16, fontSize: 14 }}>
                We couldn't auto-detect the format. Select the dealer this CSV came from, or choose Generic if unsure.
              </Text>

              {Object.entries(DEALER_TEMPLATES)
                .filter(([key]) => key !== 'stacktracker') // Stack Tracker format is auto-detected
                .map(([key, template]) => (
                <TouchableOpacity
                  key={key}
                  style={[
                    styles.card,
                    {
                      backgroundColor: colors.cardBg,
                      borderColor: selectedDealer === key ? colors.gold : colors.border,
                      borderWidth: selectedDealer === key ? 2 : 1,
                      marginBottom: 12,
                      padding: 16,
                    },
                  ]}
                  onPress={() => setSelectedDealer(key)}
                >
                  <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Text style={{ color: colors.text, fontWeight: '600', fontSize: 16 }}>{template.name}</Text>
                    {selectedDealer === key && <Text style={{ color: colors.gold, fontSize: 18 }}>âœ“</Text>}
                  </View>
                  <Text style={{ color: colors.muted, fontSize: 12, marginTop: 4 }}>{template.instructions}</Text>
                </TouchableOpacity>
              ))}

              <View style={{ height: 20 }} />
            </ScrollView>

            {/* Footer buttons */}
            <View style={{ flexDirection: 'row', gap: 8, padding: 20, paddingTop: 0 }}>
              <TouchableOpacity
                style={[styles.buttonOutline, { flex: 1 }]}
                onPress={() => {
                  setShowDealerSelector(false);
                  setPendingImportFile(null);
                  setSelectedDealer(null);
                }}
              >
                <Text style={{ color: colors.text }}>Cancel</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.button, { flex: 1, backgroundColor: selectedDealer ? colors.success : colors.muted, opacity: selectedDealer ? 1 : 0.5 }]}
                onPress={() => selectedDealer && handleDealerSelected(selectedDealer)}
                disabled={!selectedDealer}
              >
                <Text style={{ color: '#000', fontWeight: '600' }}>Continue</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Import Preview Modal */}
      {/* Import Preview Modal - Custom structure for FlatList */}
      <Modal visible={showImportPreview} animationType="slide" transparent>
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, { backgroundColor: isDarkMode ? '#1a1a2e' : '#ffffff' }]}>
            {/* Header */}
            <View style={[styles.modalHeader, { borderBottomColor: colors.border }]}>
              <Text style={[styles.modalTitle, { color: colors.text }]}>Import Preview</Text>
              <TouchableOpacity
                onPress={() => {
                  setShowImportPreview(false);
                  setImportData([]);
                }}
                style={[styles.closeButton, { backgroundColor: isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)' }]}
                hitSlop={{ top: 20, bottom: 20, left: 20, right: 20 }}
              >
                <Text style={[styles.closeButtonText, { color: colors.text }]}>âœ•</Text>
              </TouchableOpacity>
            </View>

            {/* FlatList with header and footer */}
            <FlatList
              data={importData}
              keyExtractor={(item, index) => index.toString()}
              ListHeaderComponent={
                <Text style={{ color: colors.text, marginBottom: 16, fontWeight: '600', paddingHorizontal: 20 }}>
                  Found {importData.length} item{importData.length > 1 ? 's' : ''}. Tap any item to edit before importing:
                </Text>
              }
              contentContainerStyle={{ paddingBottom: 20 }}
              renderItem={({ item, index }) => {
                const itemColor = item.metal === 'silver' ? colors.silver : colors.gold;
                const hasAutoDetected = item.autoDetected && (item.autoDetected.metal || item.autoDetected.ozt);

                return (
                  <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border, marginBottom: 12, padding: 12, borderLeftWidth: 3, borderLeftColor: itemColor, marginHorizontal: 20 }]}>
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: 4 }}>
                      <View style={{ flex: 1 }}>
                        <Text style={{ color: colors.text, fontWeight: '600', fontSize: 14 }}>{item.productName}</Text>
                        <View style={{ flexDirection: 'row', alignItems: 'center', marginTop: 2, flexWrap: 'wrap', gap: 4 }}>
                          <Text style={{ color: itemColor, fontSize: 12 }}>
                            {item.metal.toUpperCase()} â€¢ {item.ozt} oz{item.quantity > 1 ? ` â€¢ Qty: ${item.quantity}` : ''}
                          </Text>
                          {item.autoDetected?.metal && (
                            <View style={{ backgroundColor: 'rgba(251,191,36,0.2)', paddingHorizontal: 6, paddingVertical: 2, borderRadius: 4 }}>
                              <Text style={{ color: colors.gold, fontSize: 9, fontWeight: '600' }}>AUTO-METAL</Text>
                            </View>
                          )}
                          {item.autoDetected?.ozt && (
                            <View style={{ backgroundColor: 'rgba(148,163,184,0.2)', paddingHorizontal: 6, paddingVertical: 2, borderRadius: 4 }}>
                              <Text style={{ color: colors.silver, fontSize: 9, fontWeight: '600' }}>AUTO-OZT</Text>
                            </View>
                          )}
                        </View>
                      </View>
                      <Text style={{ color: colors.text, fontWeight: '600', fontSize: 14 }}>
                        ${(item.unitPrice * item.quantity).toFixed(2)}
                      </Text>
                    </View>

                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginTop: 4 }}>
                      <Text style={{ color: colors.muted, fontSize: 11 }}>
                        ${item.unitPrice.toFixed(2)} per item
                      </Text>
                      {item.datePurchased && (
                        <Text style={{ color: colors.muted, fontSize: 11 }}>
                          {item.datePurchased}
                        </Text>
                      )}
                    </View>

                    {item.source && (
                      <Text style={{ color: colors.muted, fontSize: 11, marginTop: 2 }}>
                        From: {item.source}
                      </Text>
                    )}

                    <TouchableOpacity
                      style={{
                        marginTop: 8,
                        paddingVertical: 6,
                        paddingHorizontal: 12,
                        backgroundColor: 'rgba(251,191,36,0.2)',
                        borderRadius: 6,
                        alignSelf: 'flex-start',
                      }}
                      onPress={() => editImportedItem(index)}
                    >
                      <Text style={{ color: colors.gold, fontSize: 12, fontWeight: '600' }}>Edit</Text>
                    </TouchableOpacity>
                  </View>
                );
              }}
            />

            {/* Footer buttons */}
            <View style={{ flexDirection: 'row', gap: 8, padding: 20, paddingTop: 0 }}>
              <TouchableOpacity
                style={[styles.buttonOutline, { flex: 1 }]}
                onPress={() => {
                  setShowImportPreview(false);
                  setImportData([]);
                }}
              >
                <Text style={{ color: colors.text }}>Cancel</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.button, { flex: 1, backgroundColor: colors.success }]}
                onPress={confirmImport}
              >
                <Text style={{ color: '#000', fontWeight: '600' }}>Import {importData.length} Items</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Detail View Modal */}
      <ModalWrapper
        visible={showDetailView}
        onClose={() => {
          setShowDetailView(false);
          setDetailItem(null);
          setDetailMetal(null);
        }}
        title="Item Details"
        colors={colors}
        isDarkMode={isDarkMode}
      >
        {detailItem && (
          <>
            <View style={[styles.card, { backgroundColor: colors.cardBg, borderColor: colors.border }]}>
              <Text style={[styles.cardTitle, { fontSize: scaledFonts.xlarge, color: colors.text }]}>{detailItem.productName}</Text>
              {detailItem.datePurchased && (
                <View style={styles.statRow}>
                  <Text style={[styles.statRowLabel, { fontSize: scaledFonts.small }]}>Purchase Date</Text>
                  <Text style={[styles.statRowValue, { color: colors.text, fontSize: scaledFonts.normal }]}>
                    {formatDateDisplay(detailItem.datePurchased)}{detailItem.timePurchased ? ` at ${detailItem.timePurchased}` : ''}
                  </Text>
                </View>
              )}
              {detailItem.source && (
                <View style={styles.statRow}>
                  <Text style={[styles.statRowLabel, { fontSize: scaledFonts.small }]}>Dealer</Text>
                  <Text style={[styles.statRowValue, { color: colors.text, fontSize: scaledFonts.normal }]}>{detailItem.source}</Text>
                </View>
              )}
              <View style={[styles.divider, { backgroundColor: colors.border }]} />
              <View style={styles.statRow}>
                <Text style={[styles.statRowLabel, { fontSize: scaledFonts.small }]}>Quantity</Text>
                <Text style={[styles.statRowValue, { color: colors.text, fontSize: scaledFonts.normal }]}>{detailItem.quantity}</Text>
              </View>
              <View style={styles.statRow}>
                <Text style={[styles.statRowLabel, { fontSize: scaledFonts.small }]}>Unit Price</Text>
                <Text style={[styles.statRowValue, { color: colors.text, fontSize: scaledFonts.normal }]}>${formatCurrency(detailItem.unitPrice)}</Text>
              </View>
              <View style={styles.statRow}>
                <Text style={[styles.statRowLabel, { fontSize: scaledFonts.small }]}>Troy Ounces (each)</Text>
                <Text style={[styles.statRowValue, { color: colors.text, fontSize: scaledFonts.normal }]}>{detailItem.ozt} oz</Text>
              </View>
              <View style={styles.statRow}>
                <Text style={[styles.statRowLabel, { fontSize: scaledFonts.small }]}>Total Weight</Text>
                <Text style={[styles.statRowValue, { color: colors.text, fontSize: scaledFonts.normal }]}>{formatOunces(detailItem.ozt * detailItem.quantity)} oz</Text>
              </View>
              <View style={[styles.divider, { backgroundColor: colors.border }]} />
              {detailItem.taxes > 0 && (
                <View style={styles.statRow}>
                  <Text style={[styles.statRowLabel, { fontSize: scaledFonts.small }]}>Taxes</Text>
                  <Text style={[styles.statRowValue, { color: colors.text, fontSize: scaledFonts.normal }]}>${formatCurrency(detailItem.taxes)}</Text>
                </View>
              )}
              {detailItem.shipping > 0 && (
                <View style={styles.statRow}>
                  <Text style={[styles.statRowLabel, { fontSize: scaledFonts.small }]}>Shipping</Text>
                  <Text style={[styles.statRowValue, { color: colors.text, fontSize: scaledFonts.normal }]}>${formatCurrency(detailItem.shipping)}</Text>
                </View>
              )}
              <View style={[styles.divider, { backgroundColor: colors.border }]} />
              {(() => {
                const costBasis = getItemCostBasis(detailItem);
                const detailSpotMap = { silver: silverSpot, gold: goldSpot, platinum: platinumSpot, palladium: palladiumSpot };
                const meltValue = detailItem.ozt * detailItem.quantity * (detailSpotMap[detailMetal] || goldSpot);
                const gainLoss = meltValue - costBasis;
                const gainLossPct = costBasis > 0 ? (gainLoss / costBasis) * 100 : 0;
                const isGain = gainLoss >= 0;
                return (
                  <>
                    <View style={styles.statRow}>
                      <Text style={[styles.statRowLabel, { fontSize: scaledFonts.normal, fontWeight: '600' }]}>Total Cost Basis</Text>
                      <Text style={[styles.statRowValue, { fontSize: scaledFonts.medium, color: colors.text }]}>
                        ${formatCurrency(costBasis)}
                      </Text>
                    </View>
                    <View style={styles.statRow}>
                      <Text style={[styles.statRowLabel, { fontSize: scaledFonts.normal, fontWeight: '600' }]}>Current Value</Text>
                      <Text style={[styles.statRowValue, { fontSize: scaledFonts.medium, color: metalColorMap[detailMetal] || colors.gold }]}>
                        ${formatCurrency(meltValue)}
                      </Text>
                    </View>
                    <View style={[styles.divider, { backgroundColor: colors.border }]} />
                    <View style={styles.statRow}>
                      <Text style={[styles.statRowLabel, { fontSize: scaledFonts.normal, fontWeight: '600' }]}>Gain/Loss</Text>
                      <Text style={[styles.statRowValue, { fontSize: scaledFonts.medium, fontWeight: '700', color: isGain ? colors.success : colors.error }]}>
                        {isGain ? '+' : ''}{formatCurrency(gainLoss)} ({isGain ? '+' : ''}{gainLossPct.toFixed(1)}%)
                      </Text>
                    </View>
                  </>
                );
              })()}
            </View>

            <View style={{ flexDirection: 'row', gap: 8, marginTop: 8 }}>
              <TouchableOpacity
                style={[styles.button, { flex: 1, backgroundColor: metalColorMap[detailMetal] || colors.gold }]}
                onPress={() => {
                  setShowDetailView(false);
                  editItem(detailItem, detailMetal);
                }}
              >
                <Text style={{ color: '#000', fontWeight: '600', fontSize: scaledFonts.normal }}>Edit</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.buttonOutline, { flex: 1, borderColor: colors.error }]}
                onPress={() => deleteItem(detailItem.id, detailMetal)}
              >
                <Text style={{ color: colors.error, fontWeight: '600', fontSize: scaledFonts.normal }}>Delete</Text>
              </TouchableOpacity>
            </View>
          </>
        )}
      </ModalWrapper>

      {/* Sort Menu Modal */}
      <ModalWrapper
        visible={showSortMenu}
        onClose={() => setShowSortMenu(false)}
        title="Sort Holdings"
        colors={colors}
        isDarkMode={isDarkMode}
      >
        <TouchableOpacity
          style={[styles.card, sortBy === 'date-newest' && { backgroundColor: 'rgba(251,191,36,0.15)', borderColor: colors.gold }]}
          onPress={() => {
            setSortBy('date-newest');
            setShowSortMenu(false);
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
          }}
        >
          <Text style={[styles.cardTitle, { marginBottom: 0, color: colors.text }]}>Date (Newest First)</Text>
          <Text style={{ color: colors.muted, fontSize: 12, marginTop: 4 }}>Most recent purchases first</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.card, sortBy === 'date-oldest' && { backgroundColor: 'rgba(251,191,36,0.15)', borderColor: colors.gold }]}
          onPress={() => {
            setSortBy('date-oldest');
            setShowSortMenu(false);
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
          }}
        >
          <Text style={[styles.cardTitle, { marginBottom: 0, color: colors.text }]}>Date (Oldest First)</Text>
          <Text style={{ color: colors.muted, fontSize: 12, marginTop: 4 }}>Earliest purchases first</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.card, sortBy === 'value-high' && { backgroundColor: 'rgba(251,191,36,0.15)', borderColor: colors.gold }]}
          onPress={() => {
            setSortBy('value-high');
            setShowSortMenu(false);
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
          }}
        >
          <Text style={[styles.cardTitle, { marginBottom: 0, color: colors.text }]}>Value (High to Low)</Text>
          <Text style={{ color: colors.muted, fontSize: 12, marginTop: 4 }}>Highest value first</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.card, sortBy === 'value-low' && { backgroundColor: 'rgba(251,191,36,0.15)', borderColor: colors.gold }]}
          onPress={() => {
            setSortBy('value-low');
            setShowSortMenu(false);
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
          }}
        >
          <Text style={[styles.cardTitle, { marginBottom: 0, color: colors.text }]}>Value (Low to High)</Text>
          <Text style={{ color: colors.muted, fontSize: 12, marginTop: 4 }}>Lowest value first</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.card, sortBy === 'name' && { backgroundColor: 'rgba(251,191,36,0.15)', borderColor: colors.gold }]}
          onPress={() => {
            setSortBy('name');
            setShowSortMenu(false);
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
          }}
        >
          <Text style={[styles.cardTitle, { marginBottom: 0, color: colors.text }]}>Name (A-Z)</Text>
          <Text style={{ color: colors.muted, fontSize: 12, marginTop: 4 }}>Alphabetical by product name</Text>
        </TouchableOpacity>
      </ModalWrapper>


      {/* First Launch Tutorial */}
      <Tutorial
        visible={showTutorial}
        onComplete={handleTutorialComplete}
      />

      {/* v2.0 Update Tutorial */}
      <Tutorial
        visible={showV20Tutorial}
        onComplete={handleV20TutorialComplete}
        slides={v20TutorialSlides}
      />

      {/* Side Drawer */}
      {drawerOpen && (
        <>
          <Animated.View
            style={{
              position: 'absolute', top: 0, left: 0, right: 0, bottom: 0,
              backgroundColor: 'rgba(0,0,0,0.5)',
              opacity: drawerOverlayAnim,
              zIndex: 998,
            }}
          >
            <TouchableWithoutFeedback onPress={closeDrawer}>
              <View style={{ flex: 1 }} />
            </TouchableWithoutFeedback>
          </Animated.View>

          <Animated.View
            style={{
              position: 'absolute', top: 0, left: 0, bottom: 0,
              width: 300,
              backgroundColor: '#1a1a1a',
              transform: [{ translateX: drawerAnim }],
              zIndex: 999,
              paddingTop: insets.top,
            }}
          >
            {/* Drawer Header */}
            <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', paddingHorizontal: 16, paddingVertical: 14, borderBottomWidth: 1, borderBottomColor: 'rgba(212,168,67,0.15)' }}>
              <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                <Image source={require('./assets/icon.png')} style={{ width: 32, height: 32, borderRadius: 6 }} />
                <Text style={{ color: '#fff', fontSize: 16, fontWeight: '700', marginLeft: 10 }}>Stack Tracker Gold</Text>
              </View>
              <TouchableOpacity onPress={closeDrawer} hitSlop={{ top: 12, bottom: 12, left: 12, right: 12 }}>
                <Text style={{ color: '#71717a', fontSize: 22, fontWeight: '300' }}>âœ•</Text>
              </TouchableOpacity>
            </View>

            {/* Drawer Body */}
            <ScrollView style={{ flex: 1 }} showsVerticalScrollIndicator={false}>
              {drawerSections.map((section) => (
                <View key={section.key}>
                  <TouchableOpacity
                    onPress={() => {
                      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
                      setExpandedDrawerTab(expandedDrawerTab === section.key ? null : section.key);
                    }}
                    style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', paddingHorizontal: 16, paddingVertical: 14, borderBottomWidth: 1, borderBottomColor: 'rgba(255,255,255,0.05)' }}
                  >
                    <Text style={{ color: tab === section.key ? '#D4A843' : '#fff', fontSize: 16, fontWeight: '600' }}>{section.label}</Text>
                    <Text style={{ color: '#71717a', fontSize: 14 }}>{expandedDrawerTab === section.key ? 'â–¾' : 'â–¸'}</Text>
                  </TouchableOpacity>
                  {expandedDrawerTab === section.key && section.items.map((item) => (
                    <TouchableOpacity
                      key={item.key}
                      onPress={() => navigateToSection(section.key, item.key)}
                      style={{ paddingLeft: 32, paddingRight: 16, paddingVertical: 11 }}
                    >
                      <Text style={{ color: '#9ca3af', fontSize: 14 }}>{item.label}</Text>
                    </TouchableOpacity>
                  ))}
                </View>
              ))}
            </ScrollView>

            {/* Drawer Footer */}
            <View style={{ paddingHorizontal: 16, paddingVertical: 12, borderTopWidth: 1, borderTopColor: 'rgba(255,255,255,0.05)' }}>
              <Text style={{ color: '#71717a', fontSize: 12 }}>v2.0.0</Text>
            </View>
          </Animated.View>
        </>
      )}
    </SafeAreaView>
  );
}

// Export App wrapped with SafeAreaProvider, ErrorBoundary, and AuthProvider
export default function App() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <ErrorBoundary>
          <AuthProvider>
            <AppContent />
          </AuthProvider>
        </ErrorBoundary>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}

// ============================================
// STYLES
// ============================================

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#0f0f0f' },
  header: { backgroundColor: 'rgba(0,0,0,0.4)', borderBottomWidth: 1, borderBottomColor: 'rgba(255,255,255,0.1)', paddingHorizontal: 20, paddingTop: Platform.OS === 'android' ? StatusBar.currentHeight : 0 },
  headerContent: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingVertical: 16 },
  logo: { flexDirection: 'row', alignItems: 'center', gap: 12 },
  logoIcon: { width: 40, height: 40, borderRadius: 10, alignItems: 'center', justifyContent: 'center' },
  logoTitle: { color: '#fff', fontWeight: '700', fontSize: 18 },
  logoSubtitle: { color: '#71717a', fontSize: 11 },
  privacyBadge: { paddingHorizontal: 12, paddingVertical: 6, backgroundColor: 'rgba(34,197,94,0.15)', borderRadius: 20, borderWidth: 1, borderColor: 'rgba(34,197,94,0.3)' },
  content: { flex: 1, padding: 20 },
  upgradeBanner: {
    flexDirection: 'row',
    backgroundColor: '#fbbf24',
    alignItems: 'center',
    borderTopWidth: 1,
    borderTopColor: 'rgba(251, 191, 36, 0.3)',
    shadowColor: '#fbbf24',
    shadowOffset: { width: 0, height: -2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 8,
  },
  bottomTabs: { flexDirection: 'row', backgroundColor: 'rgba(0,0,0,0.8)', borderTopWidth: 1, borderTopColor: 'rgba(255,255,255,0.1)', paddingTop: 10 },
  bottomTab: { flex: 1, alignItems: 'center', justifyContent: 'center' },
  metalTabs: { flexDirection: 'row', gap: 8, marginBottom: 16 },
  metalTab: { flex: 1, padding: 12, borderRadius: 12, borderWidth: 2, borderColor: 'rgba(255,255,255,0.1)', alignItems: 'center' },
  card: { backgroundColor: 'rgba(255,255,255,0.05)', borderRadius: 16, padding: 20, marginBottom: 16, borderWidth: 1, borderColor: 'rgba(255,255,255,0.08)' },
  cardTitle: { fontSize: 16, fontWeight: '600', color: '#fff', marginBottom: 12 },
  statRow: { flexDirection: 'row', justifyContent: 'space-between', paddingVertical: 8 },
  statRowLabel: { color: '#71717a', fontSize: 13 },
  statRowValue: { color: '#fff', fontWeight: '600' },
  divider: { height: 1, backgroundColor: 'rgba(255,255,255,0.1)', marginVertical: 12 },
  button: { paddingVertical: 14, paddingHorizontal: 24, borderRadius: 12, alignItems: 'center', justifyContent: 'center' },
  buttonOutline: { paddingVertical: 14, paddingHorizontal: 24, borderRadius: 12, alignItems: 'center', justifyContent: 'center', borderWidth: 1, borderColor: 'rgba(255,255,255,0.2)' },
  itemCard: { backgroundColor: 'rgba(0,0,0,0.2)', borderRadius: 12, padding: 16, marginBottom: 12, borderWidth: 1, borderColor: 'rgba(255,255,255,0.05)', flexDirection: 'row', alignItems: 'center' },
  itemTitle: { color: '#fff', fontWeight: '600', marginBottom: 4 },
  itemSubtitle: { color: '#71717a', fontSize: 12 },
  itemValue: { fontWeight: '600', fontSize: 16 },
  emptyState: { alignItems: 'center', padding: 40 },
  floatingContainer: { marginBottom: 12 },
  floatingLabel: { color: '#a1a1aa', fontSize: 12, marginBottom: 6, fontWeight: '500' },
  inputRow: { flexDirection: 'row', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.3)', borderWidth: 1, borderColor: 'rgba(255,255,255,0.1)', borderRadius: 10, paddingHorizontal: 12 },
  floatingInput: { flex: 1, padding: 12, paddingLeft: 0, color: '#fff', fontSize: 14 },
  inputPrefix: { color: '#71717a', fontSize: 14, marginRight: 2 },

  // Modal styles - improved
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.95)', justifyContent: 'flex-start', paddingTop: Platform.OS === 'ios' ? 60 : 40 },
  modalKeyboardView: { flex: 1, backgroundColor: '#1a1a2e' },
  modalContent: {
    backgroundColor: '#1a1a2e',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    padding: 20,
    flex: 1,
    height: '100%'
  },
  modalHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 8, paddingBottom: 8, borderBottomWidth: 1, borderBottomColor: 'rgba(255,255,255,0.1)' },
  modalTitle: { color: '#fff', fontSize: 20, fontWeight: '700' },
  closeButton: { width: 44, height: 44, alignItems: 'center', justifyContent: 'center', backgroundColor: 'rgba(255,255,255,0.1)', borderRadius: 22 },
  closeButtonText: { color: '#fff', fontSize: 18, fontWeight: '600' },

  scanStatus: { padding: 12, borderRadius: 10, marginBottom: 16 },
  privacyItem: { color: '#a1a1aa', fontSize: 13, lineHeight: 24 },

  // Sticky button container for Add/Edit modal
  stickyButtonContainer: {
    paddingTop: 12,
    paddingBottom: Platform.OS === 'ios' ? 20 : 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.1)',
    backgroundColor: '#1a1a2e',
  },
});
